

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>state_utils &mdash; ctxalgoctp 0.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="ctxalgoctp 0.1 documentation" href="../index.html"/>
        <link rel="up" title="ctp" href="index.html"/>
        <link rel="next" title="constants" href="constants.html"/>
        <link rel="prev" title="roll" href="roll.html"/> 

  
  <script src="../static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="../index.html" class="icon icon-home"> ctxalgoctp
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">ctp</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="live/index.html">live</a></li>
<li class="toctree-l2"><a class="reference internal" href="factories/index.html">factories</a></li>
<li class="toctree-l2"><a class="reference internal" href="context_loaders/index.html">context_loaders</a></li>
<li class="toctree-l2"><a class="reference internal" href="code_gen/index.html">code_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="trade_executors/index.html">trade_executors</a></li>
<li class="toctree-l2"><a class="reference internal" href="logger/index.html">logger</a></li>
<li class="toctree-l2"><a class="reference internal" href="execution_drivers/index.html">execution_drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="data_producers/index.html">data_producers</a></li>
<li class="toctree-l2"><a class="reference internal" href="strategies/index.html">strategies</a></li>
<li class="toctree-l2"><a class="reference internal" href="trading_account_loaders/index.html">trading_account_loaders</a></li>
<li class="toctree-l2"><a class="reference internal" href="slippage_models.html">slippage_models</a></li>
<li class="toctree-l2"><a class="reference internal" href="strategy_utils.html">strategy_utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="exchanges.html">exchanges</a></li>
<li class="toctree-l2"><a class="reference internal" href="backtester.html">backtester</a></li>
<li class="toctree-l2"><a class="reference internal" href="trading_account.html">trading_account</a></li>
<li class="toctree-l2"><a class="reference internal" href="strategy_command_line_utils.html">strategy_command_line_utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="report_pdf_generator.html">report_pdf_generator</a></li>
<li class="toctree-l2"><a class="reference internal" href="position_utils.html">position_utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization.html">optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="offline_optimization.html">offline_optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="tick_and_bar_publisher.html">tick_and_bar_publisher</a></li>
<li class="toctree-l2"><a class="reference internal" href="market_data_feed.html">market_data_feed</a></li>
<li class="toctree-l2"><a class="reference internal" href="base.html">base</a></li>
<li class="toctree-l2"><a class="reference internal" href="order_cancellation.html">order_cancellation</a></li>
<li class="toctree-l2"><a class="reference internal" href="roll.html">roll</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">state_utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="constants.html">constants</a></li>
<li class="toctree-l2"><a class="reference internal" href="dominant_provider.html">dominant_provider</a></li>
<li class="toctree-l2"><a class="reference internal" href="datetime_utils.html">datetime_utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="strategy.html">strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="callback_base.html">callback_base</a></li>
<li class="toctree-l2"><a class="reference internal" href="market_order_simulator.html">market_order_simulator</a></li>
<li class="toctree-l2"><a class="reference internal" href="plain_backtester.html">plain_backtester</a></li>
<li class="toctree-l2"><a class="reference internal" href="live_strategy_utils.html">live_strategy_utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="backtesting_utils.html">backtesting_utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="comm.html">comm</a></li>
<li class="toctree-l2"><a class="reference internal" href="report_generator.html">report_generator</a></li>
<li class="toctree-l2"><a class="reference internal" href="utils.html">utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="future_info_provider.html">future_info_provider</a></li>
<li class="toctree-l2"><a class="reference internal" href="trading_constants.html">trading_constants</a></li>
<li class="toctree-l2"><a class="reference internal" href="report.html">report</a></li>
<li class="toctree-l2"><a class="reference internal" href="position_rebalancer.html">position_rebalancer</a></li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">ctxalgoctp</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">ctp</a> &raquo;</li>
      
    <li>state_utils</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../sources/ctp/state_utils.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-ctxalgoctp.ctp.state_utils">
<span id="state-utils"></span><h1>state_utils<a class="headerlink" href="#module-ctxalgoctp.ctp.state_utils" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">LimitOrderState</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">ctxalgolib.trading_utils.state.TemplateState</span></code></p>
<p>Initialize current.
:param strategy: AbstractStateBasedStrategy. The state machine.
:param name: string, the name of current state.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.out_edges">
<em class="property">static </em><code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.out_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.should_cancel_order">
<code class="descname">should_cancel_order</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.should_cancel_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.on_entry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.all_positions_with_actual_instrument_id">
<code class="descname">all_positions_with_actual_instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.all_positions_with_actual_instrument_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return currently holding positions in all traded instruments, including information about actual
instrument ids.
:return dict{string: dict{string: int}}, meaning {instrument_id: dict{actual_instrument_id: volume}}.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.contract_multiplier">
<code class="descname">contract_multiplier</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.contract_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Get multiplier of the given instrument.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return: int. The volume multiple.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.contract_value">
<code class="descname">contract_value</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.contract_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the contract value.
:param price: float, price of the instrument.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, contract value.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.default_period">
<code class="descname">default_period</code><span class="sig-paren">(</span><em>kind=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.default_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period for the given ohlc kind.
:param kind: string, can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based.</p>
<blockquote>
<div>If None, self.default_period_kind() is used.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int or float, default period. Will return None if there are multiple possible values.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.default_period_kind">
<code class="descname">default_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.default_period_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period kind.
:return: string, can be can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based,</p>
<blockquote>
<div>or None in case where no default is available.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>orders=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.in_market_period">
<code class="descname">in_market_period</code><span class="sig-paren">(</span><em>timestamp=None</em>, <em>instrument_id=None</em>, <em>trading_day=None</em>, <em>delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.in_market_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the given timestamp is within any of the market periods of the instrument.
:param timestamp: datetime, current timestamp, if None, use self.now().
:param instrument_id: string, instrument id, if None, use self.instrument_id().
:param trading_day: date, current trading day, if None, use self.trading_day().
:param delta: timedelta or int or float, if not None, checks this delta before a market period ends.</p>
<blockquote>
<div>If type is int or float, it means timedelta(seconds=int).</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.is_market_order_supported">
<code class="descname">is_market_order_supported</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.is_market_order_supported" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.margin_rate">
<code class="descname">margin_rate</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the margin rate for the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param direction: string, not used.
:return: float, margin rate.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.market_end_time">
<code class="descname">market_end_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.market_end_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">datetime, the time when the market ends.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.money_per_tick">
<code class="descname">money_per_tick</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>with_margin=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.money_per_tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the money for a tick movement of the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param with_margin: bool, If True, the returned value is multiplied by margin rate.
:return: float, the money for a tick movement of the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.order_book_height">
<code class="descname">order_book_height</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.order_book_height" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the height of the order book.
:param instrument_id: string, instrument id, if None, self.instrument_id() is used.
:param level: int, the order book level, 0 means the nearest level, 1 means the next level.
:return: int, the order book height in unit of tick size.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.pending_orders">
<code class="descname">pending_orders</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.pending_orders" title="Permalink to this definition">¶</a></dt>
<dd><p>Return pending orders.
:param instrument_id: string, the instrument id whose pending orders are to be returned.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string:, int}, meaning dict{direction: volume}.
Keys are direction &#8216;long&#8217; or &#8216;short&#8217;, values are pending volumes in that direction.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.position_difference">
<code class="descname">position_difference</code><span class="sig-paren">(</span><em>target_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.position_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return difference between holding position and target positions.
:param target_positions: dict{string: int}, keys are instrument ids, values are the positions that</p>
<blockquote>
<div>should be reached for those instruments (treated as single sided position).
If a position is None, it means its target position is not known, then in the result, there will
be an entry for this instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: dict{string: object}}, For each instrument whose current holding position is different
from the given target position, there is an entry in the result dict. For instruments whose holding
position is the same as the given target position, there is no entry in the result list.<p>Keys are those instruments, values are dicts with the following keys:
instrument_id: string, the instrument id, same as key.
target: int, the target position.
long: int, the current holding long position.
short: int, the current holding short position.
long_pending: int, the current pending position in the long direction.
short_pending: int, the current pending position in the short direction.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.required_contract_margin">
<code class="descname">required_contract_margin</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.required_contract_margin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the required margin to trade the instrument at price and volume.
:param price: float, instrument price.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, required margin.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.trading_days_between">
<code class="descname">trading_days_between</code><span class="sig-paren">(</span><em>start_date</em>, <em>end_date=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.trading_days_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trading days between start_date and end_date.
:param start_date: date, start date, inclusive.
:param end_date: date, end date, inclusive. If None, defaults to self.trading_day().
:return: [date], the trading days between the specified range.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">OpenLimitOrderState</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.state_utils.LimitOrderState" title="ctxalgoctp.ctp.state_utils.LimitOrderState"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.state_utils.LimitOrderState</span></code></a></p>
<p>Initialize current.
:param strategy: AbstractStateBasedStrategy. The state machine.
:param name: string, the name of current state.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.all_positions_with_actual_instrument_id">
<code class="descname">all_positions_with_actual_instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.all_positions_with_actual_instrument_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return currently holding positions in all traded instruments, including information about actual
instrument ids.
:return dict{string: dict{string: int}}, meaning {instrument_id: dict{actual_instrument_id: volume}}.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.contract_multiplier">
<code class="descname">contract_multiplier</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.contract_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Get multiplier of the given instrument.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return: int. The volume multiple.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.contract_value">
<code class="descname">contract_value</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.contract_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the contract value.
:param price: float, price of the instrument.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, contract value.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.default_period">
<code class="descname">default_period</code><span class="sig-paren">(</span><em>kind=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.default_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period for the given ohlc kind.
:param kind: string, can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based.</p>
<blockquote>
<div>If None, self.default_period_kind() is used.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int or float, default period. Will return None if there are multiple possible values.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.default_period_kind">
<code class="descname">default_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.default_period_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period kind.
:return: string, can be can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based,</p>
<blockquote>
<div>or None in case where no default is available.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>orders=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.in_market_period">
<code class="descname">in_market_period</code><span class="sig-paren">(</span><em>timestamp=None</em>, <em>instrument_id=None</em>, <em>trading_day=None</em>, <em>delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.in_market_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the given timestamp is within any of the market periods of the instrument.
:param timestamp: datetime, current timestamp, if None, use self.now().
:param instrument_id: string, instrument id, if None, use self.instrument_id().
:param trading_day: date, current trading day, if None, use self.trading_day().
:param delta: timedelta or int or float, if not None, checks this delta before a market period ends.</p>
<blockquote>
<div>If type is int or float, it means timedelta(seconds=int).</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_market_order_supported">
<code class="descname">is_market_order_supported</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_market_order_supported" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.margin_rate">
<code class="descname">margin_rate</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the margin rate for the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param direction: string, not used.
:return: float, margin rate.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.market_end_time">
<code class="descname">market_end_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.market_end_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">datetime, the time when the market ends.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.money_per_tick">
<code class="descname">money_per_tick</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>with_margin=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.money_per_tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the money for a tick movement of the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param with_margin: bool, If True, the returned value is multiplied by margin rate.
:return: float, the money for a tick movement of the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.on_entry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.order_book_height">
<code class="descname">order_book_height</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.order_book_height" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the height of the order book.
:param instrument_id: string, instrument id, if None, self.instrument_id() is used.
:param level: int, the order book level, 0 means the nearest level, 1 means the next level.
:return: int, the order book height in unit of tick size.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.out_edges">
<code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.out_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.pending_orders">
<code class="descname">pending_orders</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.pending_orders" title="Permalink to this definition">¶</a></dt>
<dd><p>Return pending orders.
:param instrument_id: string, the instrument id whose pending orders are to be returned.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string:, int}, meaning dict{direction: volume}.
Keys are direction &#8216;long&#8217; or &#8216;short&#8217;, values are pending volumes in that direction.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.position_difference">
<code class="descname">position_difference</code><span class="sig-paren">(</span><em>target_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.position_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return difference between holding position and target positions.
:param target_positions: dict{string: int}, keys are instrument ids, values are the positions that</p>
<blockquote>
<div>should be reached for those instruments (treated as single sided position).
If a position is None, it means its target position is not known, then in the result, there will
be an entry for this instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: dict{string: object}}, For each instrument whose current holding position is different
from the given target position, there is an entry in the result dict. For instruments whose holding
position is the same as the given target position, there is no entry in the result list.<p>Keys are those instruments, values are dicts with the following keys:
instrument_id: string, the instrument id, same as key.
target: int, the target position.
long: int, the current holding long position.
short: int, the current holding short position.
long_pending: int, the current pending position in the long direction.
short_pending: int, the current pending position in the short direction.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.required_contract_margin">
<code class="descname">required_contract_margin</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.required_contract_margin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the required margin to trade the instrument at price and volume.
:param price: float, instrument price.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, required margin.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.should_cancel_order">
<code class="descname">should_cancel_order</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.should_cancel_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.trading_days_between">
<code class="descname">trading_days_between</code><span class="sig-paren">(</span><em>start_date</em>, <em>end_date=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.trading_days_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trading days between start_date and end_date.
:param start_date: date, start date, inclusive.
:param end_date: date, end date, inclusive. If None, defaults to self.trading_day().
:return: [date], the trading days between the specified range.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">CloseLimitOrderState</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.state_utils.LimitOrderState" title="ctxalgoctp.ctp.state_utils.LimitOrderState"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.state_utils.LimitOrderState</span></code></a></p>
<p>Initialize current.
:param strategy: AbstractStateBasedStrategy. The state machine.
:param name: string, the name of current state.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.all_positions_with_actual_instrument_id">
<code class="descname">all_positions_with_actual_instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.all_positions_with_actual_instrument_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return currently holding positions in all traded instruments, including information about actual
instrument ids.
:return dict{string: dict{string: int}}, meaning {instrument_id: dict{actual_instrument_id: volume}}.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.contract_multiplier">
<code class="descname">contract_multiplier</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.contract_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Get multiplier of the given instrument.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return: int. The volume multiple.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.contract_value">
<code class="descname">contract_value</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.contract_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the contract value.
:param price: float, price of the instrument.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, contract value.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.default_period">
<code class="descname">default_period</code><span class="sig-paren">(</span><em>kind=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.default_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period for the given ohlc kind.
:param kind: string, can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based.</p>
<blockquote>
<div>If None, self.default_period_kind() is used.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int or float, default period. Will return None if there are multiple possible values.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.default_period_kind">
<code class="descname">default_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.default_period_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period kind.
:return: string, can be can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based,</p>
<blockquote>
<div>or None in case where no default is available.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>orders=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.in_market_period">
<code class="descname">in_market_period</code><span class="sig-paren">(</span><em>timestamp=None</em>, <em>instrument_id=None</em>, <em>trading_day=None</em>, <em>delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.in_market_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the given timestamp is within any of the market periods of the instrument.
:param timestamp: datetime, current timestamp, if None, use self.now().
:param instrument_id: string, instrument id, if None, use self.instrument_id().
:param trading_day: date, current trading day, if None, use self.trading_day().
:param delta: timedelta or int or float, if not None, checks this delta before a market period ends.</p>
<blockquote>
<div>If type is int or float, it means timedelta(seconds=int).</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_market_order_supported">
<code class="descname">is_market_order_supported</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_market_order_supported" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.margin_rate">
<code class="descname">margin_rate</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the margin rate for the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param direction: string, not used.
:return: float, margin rate.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.market_end_time">
<code class="descname">market_end_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.market_end_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">datetime, the time when the market ends.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.money_per_tick">
<code class="descname">money_per_tick</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>with_margin=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.money_per_tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the money for a tick movement of the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param with_margin: bool, If True, the returned value is multiplied by margin rate.
:return: float, the money for a tick movement of the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.on_entry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.order_book_height">
<code class="descname">order_book_height</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.order_book_height" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the height of the order book.
:param instrument_id: string, instrument id, if None, self.instrument_id() is used.
:param level: int, the order book level, 0 means the nearest level, 1 means the next level.
:return: int, the order book height in unit of tick size.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.out_edges">
<code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.out_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.pending_orders">
<code class="descname">pending_orders</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.pending_orders" title="Permalink to this definition">¶</a></dt>
<dd><p>Return pending orders.
:param instrument_id: string, the instrument id whose pending orders are to be returned.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string:, int}, meaning dict{direction: volume}.
Keys are direction &#8216;long&#8217; or &#8216;short&#8217;, values are pending volumes in that direction.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.position_difference">
<code class="descname">position_difference</code><span class="sig-paren">(</span><em>target_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.position_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return difference between holding position and target positions.
:param target_positions: dict{string: int}, keys are instrument ids, values are the positions that</p>
<blockquote>
<div>should be reached for those instruments (treated as single sided position).
If a position is None, it means its target position is not known, then in the result, there will
be an entry for this instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: dict{string: object}}, For each instrument whose current holding position is different
from the given target position, there is an entry in the result dict. For instruments whose holding
position is the same as the given target position, there is no entry in the result list.<p>Keys are those instruments, values are dicts with the following keys:
instrument_id: string, the instrument id, same as key.
target: int, the target position.
long: int, the current holding long position.
short: int, the current holding short position.
long_pending: int, the current pending position in the long direction.
short_pending: int, the current pending position in the short direction.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.required_contract_margin">
<code class="descname">required_contract_margin</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.required_contract_margin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the required margin to trade the instrument at price and volume.
:param price: float, instrument price.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, required margin.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.should_cancel_order">
<code class="descname">should_cancel_order</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.should_cancel_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.trading_days_between">
<code class="descname">trading_days_between</code><span class="sig-paren">(</span><em>start_date</em>, <em>end_date=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.trading_days_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trading days between start_date and end_date.
:param start_date: date, start date, inclusive.
:param end_date: date, end date, inclusive. If None, defaults to self.trading_day().
:return: [date], the trading days between the specified range.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">AbstractCancelOrderState</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">ctxalgolib.trading_utils.state.TemplateState</span></code></p>
<p>Initialize current.
:param strategy: AbstractStateBasedStrategy. The state machine.
:param name: string, the name of current state.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.on_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Do something when entry a state
:param state: string, the name of the entered state</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.all_positions_with_actual_instrument_id">
<code class="descname">all_positions_with_actual_instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.all_positions_with_actual_instrument_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return currently holding positions in all traded instruments, including information about actual
instrument ids.
:return dict{string: dict{string: int}}, meaning {instrument_id: dict{actual_instrument_id: volume}}.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.contract_multiplier">
<code class="descname">contract_multiplier</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.contract_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Get multiplier of the given instrument.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return: int. The volume multiple.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.contract_value">
<code class="descname">contract_value</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.contract_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the contract value.
:param price: float, price of the instrument.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, contract value.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.default_period">
<code class="descname">default_period</code><span class="sig-paren">(</span><em>kind=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.default_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period for the given ohlc kind.
:param kind: string, can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based.</p>
<blockquote>
<div>If None, self.default_period_kind() is used.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int or float, default period. Will return None if there are multiple possible values.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.default_period_kind">
<code class="descname">default_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.default_period_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period kind.
:return: string, can be can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based,</p>
<blockquote>
<div>or None in case where no default is available.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>orders=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.in_market_period">
<code class="descname">in_market_period</code><span class="sig-paren">(</span><em>timestamp=None</em>, <em>instrument_id=None</em>, <em>trading_day=None</em>, <em>delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.in_market_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the given timestamp is within any of the market periods of the instrument.
:param timestamp: datetime, current timestamp, if None, use self.now().
:param instrument_id: string, instrument id, if None, use self.instrument_id().
:param trading_day: date, current trading day, if None, use self.trading_day().
:param delta: timedelta or int or float, if not None, checks this delta before a market period ends.</p>
<blockquote>
<div>If type is int or float, it means timedelta(seconds=int).</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_market_order_supported">
<code class="descname">is_market_order_supported</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_market_order_supported" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.margin_rate">
<code class="descname">margin_rate</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the margin rate for the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param direction: string, not used.
:return: float, margin rate.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.market_end_time">
<code class="descname">market_end_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.market_end_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">datetime, the time when the market ends.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.money_per_tick">
<code class="descname">money_per_tick</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>with_margin=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.money_per_tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the money for a tick movement of the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param with_margin: bool, If True, the returned value is multiplied by margin rate.
:return: float, the money for a tick movement of the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.order_book_height">
<code class="descname">order_book_height</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.order_book_height" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the height of the order book.
:param instrument_id: string, instrument id, if None, self.instrument_id() is used.
:param level: int, the order book level, 0 means the nearest level, 1 means the next level.
:return: int, the order book height in unit of tick size.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.out_edges">
<code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.out_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of predefined and fixed out edges leaving current state.
:return: [string], the list of out edge names that can leave current state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.pending_orders">
<code class="descname">pending_orders</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.pending_orders" title="Permalink to this definition">¶</a></dt>
<dd><p>Return pending orders.
:param instrument_id: string, the instrument id whose pending orders are to be returned.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string:, int}, meaning dict{direction: volume}.
Keys are direction &#8216;long&#8217; or &#8216;short&#8217;, values are pending volumes in that direction.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.position_difference">
<code class="descname">position_difference</code><span class="sig-paren">(</span><em>target_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.position_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return difference between holding position and target positions.
:param target_positions: dict{string: int}, keys are instrument ids, values are the positions that</p>
<blockquote>
<div>should be reached for those instruments (treated as single sided position).
If a position is None, it means its target position is not known, then in the result, there will
be an entry for this instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: dict{string: object}}, For each instrument whose current holding position is different
from the given target position, there is an entry in the result dict. For instruments whose holding
position is the same as the given target position, there is no entry in the result list.<p>Keys are those instruments, values are dicts with the following keys:
instrument_id: string, the instrument id, same as key.
target: int, the target position.
long: int, the current holding long position.
short: int, the current holding short position.
long_pending: int, the current pending position in the long direction.
short_pending: int, the current pending position in the short direction.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.required_contract_margin">
<code class="descname">required_contract_margin</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.required_contract_margin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the required margin to trade the instrument at price and volume.
:param price: float, instrument price.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, required margin.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.trading_days_between">
<code class="descname">trading_days_between</code><span class="sig-paren">(</span><em>start_date</em>, <em>end_date=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.trading_days_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trading days between start_date and end_date.
:param start_date: date, start date, inclusive.
:param end_date: date, end date, inclusive. If None, defaults to self.trading_day().
:return: [date], the trading days between the specified range.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">CancelOrderState</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState" title="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.state_utils.AbstractCancelOrderState</span></code></a></p>
<p>Initialize current.
:param strategy: AbstractStateBasedStrategy. The state machine.
:param name: string, the name of current state.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.out_edges">
<em class="property">static </em><code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.out_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.all_positions_with_actual_instrument_id">
<code class="descname">all_positions_with_actual_instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.all_positions_with_actual_instrument_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return currently holding positions in all traded instruments, including information about actual
instrument ids.
:return dict{string: dict{string: int}}, meaning {instrument_id: dict{actual_instrument_id: volume}}.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.contract_multiplier">
<code class="descname">contract_multiplier</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.contract_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Get multiplier of the given instrument.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return: int. The volume multiple.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.contract_value">
<code class="descname">contract_value</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.contract_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the contract value.
:param price: float, price of the instrument.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, contract value.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.default_period">
<code class="descname">default_period</code><span class="sig-paren">(</span><em>kind=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.default_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period for the given ohlc kind.
:param kind: string, can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based.</p>
<blockquote>
<div>If None, self.default_period_kind() is used.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int or float, default period. Will return None if there are multiple possible values.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.default_period_kind">
<code class="descname">default_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.default_period_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period kind.
:return: string, can be can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based,</p>
<blockquote>
<div>or None in case where no default is available.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>orders=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.in_market_period">
<code class="descname">in_market_period</code><span class="sig-paren">(</span><em>timestamp=None</em>, <em>instrument_id=None</em>, <em>trading_day=None</em>, <em>delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.in_market_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the given timestamp is within any of the market periods of the instrument.
:param timestamp: datetime, current timestamp, if None, use self.now().
:param instrument_id: string, instrument id, if None, use self.instrument_id().
:param trading_day: date, current trading day, if None, use self.trading_day().
:param delta: timedelta or int or float, if not None, checks this delta before a market period ends.</p>
<blockquote>
<div>If type is int or float, it means timedelta(seconds=int).</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.is_market_order_supported">
<code class="descname">is_market_order_supported</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.is_market_order_supported" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.margin_rate">
<code class="descname">margin_rate</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the margin rate for the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param direction: string, not used.
:return: float, margin rate.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.market_end_time">
<code class="descname">market_end_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.market_end_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">datetime, the time when the market ends.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.money_per_tick">
<code class="descname">money_per_tick</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>with_margin=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.money_per_tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the money for a tick movement of the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param with_margin: bool, If True, the returned value is multiplied by margin rate.
:return: float, the money for a tick movement of the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.on_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Do something when entry a state
:param state: string, the name of the entered state</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.order_book_height">
<code class="descname">order_book_height</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.order_book_height" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the height of the order book.
:param instrument_id: string, instrument id, if None, self.instrument_id() is used.
:param level: int, the order book level, 0 means the nearest level, 1 means the next level.
:return: int, the order book height in unit of tick size.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.pending_orders">
<code class="descname">pending_orders</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.pending_orders" title="Permalink to this definition">¶</a></dt>
<dd><p>Return pending orders.
:param instrument_id: string, the instrument id whose pending orders are to be returned.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string:, int}, meaning dict{direction: volume}.
Keys are direction &#8216;long&#8217; or &#8216;short&#8217;, values are pending volumes in that direction.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.position_difference">
<code class="descname">position_difference</code><span class="sig-paren">(</span><em>target_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.position_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return difference between holding position and target positions.
:param target_positions: dict{string: int}, keys are instrument ids, values are the positions that</p>
<blockquote>
<div>should be reached for those instruments (treated as single sided position).
If a position is None, it means its target position is not known, then in the result, there will
be an entry for this instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: dict{string: object}}, For each instrument whose current holding position is different
from the given target position, there is an entry in the result dict. For instruments whose holding
position is the same as the given target position, there is no entry in the result list.<p>Keys are those instruments, values are dicts with the following keys:
instrument_id: string, the instrument id, same as key.
target: int, the target position.
long: int, the current holding long position.
short: int, the current holding short position.
long_pending: int, the current pending position in the long direction.
short_pending: int, the current pending position in the short direction.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.required_contract_margin">
<code class="descname">required_contract_margin</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.required_contract_margin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the required margin to trade the instrument at price and volume.
:param price: float, instrument price.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, required margin.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.trading_days_between">
<code class="descname">trading_days_between</code><span class="sig-paren">(</span><em>start_date</em>, <em>end_date=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.trading_days_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trading days between start_date and end_date.
:param start_date: date, start date, inclusive.
:param end_date: date, end date, inclusive. If None, defaults to self.trading_day().
:return: [date], the trading days between the specified range.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">CancelOrderState2</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState" title="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.state_utils.AbstractCancelOrderState</span></code></a></p>
<p>Initialize current.
:param strategy: AbstractStateBasedStrategy. The state machine.
:param name: string, the name of current state.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.out_edges">
<em class="property">static </em><code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.out_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.all_positions_with_actual_instrument_id">
<code class="descname">all_positions_with_actual_instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.all_positions_with_actual_instrument_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return currently holding positions in all traded instruments, including information about actual
instrument ids.
:return dict{string: dict{string: int}}, meaning {instrument_id: dict{actual_instrument_id: volume}}.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.contract_multiplier">
<code class="descname">contract_multiplier</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.contract_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Get multiplier of the given instrument.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return: int. The volume multiple.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.contract_value">
<code class="descname">contract_value</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.contract_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the contract value.
:param price: float, price of the instrument.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, contract value.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.default_period">
<code class="descname">default_period</code><span class="sig-paren">(</span><em>kind=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.default_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period for the given ohlc kind.
:param kind: string, can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based.</p>
<blockquote>
<div>If None, self.default_period_kind() is used.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int or float, default period. Will return None if there are multiple possible values.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.default_period_kind">
<code class="descname">default_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.default_period_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period kind.
:return: string, can be can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based,</p>
<blockquote>
<div>or None in case where no default is available.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>orders=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.in_market_period">
<code class="descname">in_market_period</code><span class="sig-paren">(</span><em>timestamp=None</em>, <em>instrument_id=None</em>, <em>trading_day=None</em>, <em>delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.in_market_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the given timestamp is within any of the market periods of the instrument.
:param timestamp: datetime, current timestamp, if None, use self.now().
:param instrument_id: string, instrument id, if None, use self.instrument_id().
:param trading_day: date, current trading day, if None, use self.trading_day().
:param delta: timedelta or int or float, if not None, checks this delta before a market period ends.</p>
<blockquote>
<div>If type is int or float, it means timedelta(seconds=int).</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.is_market_order_supported">
<code class="descname">is_market_order_supported</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.is_market_order_supported" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.margin_rate">
<code class="descname">margin_rate</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the margin rate for the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param direction: string, not used.
:return: float, margin rate.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.market_end_time">
<code class="descname">market_end_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.market_end_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">datetime, the time when the market ends.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.money_per_tick">
<code class="descname">money_per_tick</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>with_margin=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.money_per_tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the money for a tick movement of the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param with_margin: bool, If True, the returned value is multiplied by margin rate.
:return: float, the money for a tick movement of the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.on_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Do something when entry a state
:param state: string, the name of the entered state</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.order_book_height">
<code class="descname">order_book_height</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.order_book_height" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the height of the order book.
:param instrument_id: string, instrument id, if None, self.instrument_id() is used.
:param level: int, the order book level, 0 means the nearest level, 1 means the next level.
:return: int, the order book height in unit of tick size.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.pending_orders">
<code class="descname">pending_orders</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.pending_orders" title="Permalink to this definition">¶</a></dt>
<dd><p>Return pending orders.
:param instrument_id: string, the instrument id whose pending orders are to be returned.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string:, int}, meaning dict{direction: volume}.
Keys are direction &#8216;long&#8217; or &#8216;short&#8217;, values are pending volumes in that direction.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.position_difference">
<code class="descname">position_difference</code><span class="sig-paren">(</span><em>target_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.position_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return difference between holding position and target positions.
:param target_positions: dict{string: int}, keys are instrument ids, values are the positions that</p>
<blockquote>
<div>should be reached for those instruments (treated as single sided position).
If a position is None, it means its target position is not known, then in the result, there will
be an entry for this instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: dict{string: object}}, For each instrument whose current holding position is different
from the given target position, there is an entry in the result dict. For instruments whose holding
position is the same as the given target position, there is no entry in the result list.<p>Keys are those instruments, values are dicts with the following keys:
instrument_id: string, the instrument id, same as key.
target: int, the target position.
long: int, the current holding long position.
short: int, the current holding short position.
long_pending: int, the current pending position in the long direction.
short_pending: int, the current pending position in the short direction.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.required_contract_margin">
<code class="descname">required_contract_margin</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.required_contract_margin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the required margin to trade the instrument at price and volume.
:param price: float, instrument price.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, required margin.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.trading_days_between">
<code class="descname">trading_days_between</code><span class="sig-paren">(</span><em>start_date</em>, <em>end_date=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.trading_days_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trading days between start_date and end_date.
:param start_date: date, start date, inclusive.
:param end_date: date, end date, inclusive. If None, defaults to self.trading_day().
:return: [date], the trading days between the specified range.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">AbstractMarketOrderState</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">ctxalgolib.trading_utils.state.TemplateState</span></code></p>
<p>Initialize current.
:param strategy: AbstractStateBasedStrategy. The state machine.
:param name: string, the name of current state.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.out_edges">
<em class="property">static </em><code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.out_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_order_kind">
<code class="descname">get_order_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_order_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_instrument_ids">
<code class="descname">get_instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the list of instrument ids from self.data whose market orders need to be placed.
:return: [string], the list of instrument ids.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the volume for the market order from self.data for the given instrument id.
:param instrument_id: string, the instrument id.
:return: int, the volume, positive number means long volume, negative value means short volume.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_reason">
<code class="descname">get_reason</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_reason" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the reason for placing the market order for the given instrument id from self.data
:param instrument_id: string, the instrument id.
:return: string, the reason for placing the market order.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_orders">
<code class="descname">get_orders</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_orders" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.on_entry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.all_positions_with_actual_instrument_id">
<code class="descname">all_positions_with_actual_instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.all_positions_with_actual_instrument_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return currently holding positions in all traded instruments, including information about actual
instrument ids.
:return dict{string: dict{string: int}}, meaning {instrument_id: dict{actual_instrument_id: volume}}.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.contract_multiplier">
<code class="descname">contract_multiplier</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.contract_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Get multiplier of the given instrument.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return: int. The volume multiple.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.contract_value">
<code class="descname">contract_value</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.contract_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the contract value.
:param price: float, price of the instrument.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, contract value.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.default_period">
<code class="descname">default_period</code><span class="sig-paren">(</span><em>kind=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.default_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period for the given ohlc kind.
:param kind: string, can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based.</p>
<blockquote>
<div>If None, self.default_period_kind() is used.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int or float, default period. Will return None if there are multiple possible values.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.default_period_kind">
<code class="descname">default_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.default_period_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period kind.
:return: string, can be can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based,</p>
<blockquote>
<div>or None in case where no default is available.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>orders=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.in_market_period">
<code class="descname">in_market_period</code><span class="sig-paren">(</span><em>timestamp=None</em>, <em>instrument_id=None</em>, <em>trading_day=None</em>, <em>delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.in_market_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the given timestamp is within any of the market periods of the instrument.
:param timestamp: datetime, current timestamp, if None, use self.now().
:param instrument_id: string, instrument id, if None, use self.instrument_id().
:param trading_day: date, current trading day, if None, use self.trading_day().
:param delta: timedelta or int or float, if not None, checks this delta before a market period ends.</p>
<blockquote>
<div>If type is int or float, it means timedelta(seconds=int).</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_market_order_supported">
<code class="descname">is_market_order_supported</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_market_order_supported" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.margin_rate">
<code class="descname">margin_rate</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the margin rate for the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param direction: string, not used.
:return: float, margin rate.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.market_end_time">
<code class="descname">market_end_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.market_end_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">datetime, the time when the market ends.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.money_per_tick">
<code class="descname">money_per_tick</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>with_margin=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.money_per_tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the money for a tick movement of the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param with_margin: bool, If True, the returned value is multiplied by margin rate.
:return: float, the money for a tick movement of the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.order_book_height">
<code class="descname">order_book_height</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.order_book_height" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the height of the order book.
:param instrument_id: string, instrument id, if None, self.instrument_id() is used.
:param level: int, the order book level, 0 means the nearest level, 1 means the next level.
:return: int, the order book height in unit of tick size.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.pending_orders">
<code class="descname">pending_orders</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.pending_orders" title="Permalink to this definition">¶</a></dt>
<dd><p>Return pending orders.
:param instrument_id: string, the instrument id whose pending orders are to be returned.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string:, int}, meaning dict{direction: volume}.
Keys are direction &#8216;long&#8217; or &#8216;short&#8217;, values are pending volumes in that direction.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.position_difference">
<code class="descname">position_difference</code><span class="sig-paren">(</span><em>target_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.position_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return difference between holding position and target positions.
:param target_positions: dict{string: int}, keys are instrument ids, values are the positions that</p>
<blockquote>
<div>should be reached for those instruments (treated as single sided position).
If a position is None, it means its target position is not known, then in the result, there will
be an entry for this instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: dict{string: object}}, For each instrument whose current holding position is different
from the given target position, there is an entry in the result dict. For instruments whose holding
position is the same as the given target position, there is no entry in the result list.<p>Keys are those instruments, values are dicts with the following keys:
instrument_id: string, the instrument id, same as key.
target: int, the target position.
long: int, the current holding long position.
short: int, the current holding short position.
long_pending: int, the current pending position in the long direction.
short_pending: int, the current pending position in the short direction.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.required_contract_margin">
<code class="descname">required_contract_margin</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.required_contract_margin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the required margin to trade the instrument at price and volume.
:param price: float, instrument price.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, required margin.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.trading_days_between">
<code class="descname">trading_days_between</code><span class="sig-paren">(</span><em>start_date</em>, <em>end_date=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.trading_days_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trading days between start_date and end_date.
:param start_date: date, start date, inclusive.
:param end_date: date, end date, inclusive. If None, defaults to self.trading_day().
:return: [date], the trading days between the specified range.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">OpenMarketOrderState</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState" title="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.state_utils.AbstractMarketOrderState</span></code></a></p>
<p>Initialize current.
:param strategy: AbstractStateBasedStrategy. The state machine.
:param name: string, the name of current state.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_orders">
<code class="descname">get_orders</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_orders" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.all_positions_with_actual_instrument_id">
<code class="descname">all_positions_with_actual_instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.all_positions_with_actual_instrument_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return currently holding positions in all traded instruments, including information about actual
instrument ids.
:return dict{string: dict{string: int}}, meaning {instrument_id: dict{actual_instrument_id: volume}}.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.contract_multiplier">
<code class="descname">contract_multiplier</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.contract_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Get multiplier of the given instrument.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return: int. The volume multiple.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.contract_value">
<code class="descname">contract_value</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.contract_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the contract value.
:param price: float, price of the instrument.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, contract value.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.default_period">
<code class="descname">default_period</code><span class="sig-paren">(</span><em>kind=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.default_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period for the given ohlc kind.
:param kind: string, can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based.</p>
<blockquote>
<div>If None, self.default_period_kind() is used.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int or float, default period. Will return None if there are multiple possible values.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.default_period_kind">
<code class="descname">default_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.default_period_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period kind.
:return: string, can be can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based,</p>
<blockquote>
<div>or None in case where no default is available.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_instrument_ids">
<code class="descname">get_instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the list of instrument ids from self.data whose market orders need to be placed.
:return: [string], the list of instrument ids.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_order_kind">
<code class="descname">get_order_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_order_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_reason">
<code class="descname">get_reason</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_reason" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the reason for placing the market order for the given instrument id from self.data
:param instrument_id: string, the instrument id.
:return: string, the reason for placing the market order.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the volume for the market order from self.data for the given instrument id.
:param instrument_id: string, the instrument id.
:return: int, the volume, positive number means long volume, negative value means short volume.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>orders=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.in_market_period">
<code class="descname">in_market_period</code><span class="sig-paren">(</span><em>timestamp=None</em>, <em>instrument_id=None</em>, <em>trading_day=None</em>, <em>delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.in_market_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the given timestamp is within any of the market periods of the instrument.
:param timestamp: datetime, current timestamp, if None, use self.now().
:param instrument_id: string, instrument id, if None, use self.instrument_id().
:param trading_day: date, current trading day, if None, use self.trading_day().
:param delta: timedelta or int or float, if not None, checks this delta before a market period ends.</p>
<blockquote>
<div>If type is int or float, it means timedelta(seconds=int).</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_market_order_supported">
<code class="descname">is_market_order_supported</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_market_order_supported" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.margin_rate">
<code class="descname">margin_rate</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the margin rate for the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param direction: string, not used.
:return: float, margin rate.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.market_end_time">
<code class="descname">market_end_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.market_end_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">datetime, the time when the market ends.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.money_per_tick">
<code class="descname">money_per_tick</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>with_margin=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.money_per_tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the money for a tick movement of the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param with_margin: bool, If True, the returned value is multiplied by margin rate.
:return: float, the money for a tick movement of the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.on_entry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.order_book_height">
<code class="descname">order_book_height</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.order_book_height" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the height of the order book.
:param instrument_id: string, instrument id, if None, self.instrument_id() is used.
:param level: int, the order book level, 0 means the nearest level, 1 means the next level.
:return: int, the order book height in unit of tick size.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.out_edges">
<code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.out_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.pending_orders">
<code class="descname">pending_orders</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.pending_orders" title="Permalink to this definition">¶</a></dt>
<dd><p>Return pending orders.
:param instrument_id: string, the instrument id whose pending orders are to be returned.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string:, int}, meaning dict{direction: volume}.
Keys are direction &#8216;long&#8217; or &#8216;short&#8217;, values are pending volumes in that direction.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.position_difference">
<code class="descname">position_difference</code><span class="sig-paren">(</span><em>target_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.position_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return difference between holding position and target positions.
:param target_positions: dict{string: int}, keys are instrument ids, values are the positions that</p>
<blockquote>
<div>should be reached for those instruments (treated as single sided position).
If a position is None, it means its target position is not known, then in the result, there will
be an entry for this instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: dict{string: object}}, For each instrument whose current holding position is different
from the given target position, there is an entry in the result dict. For instruments whose holding
position is the same as the given target position, there is no entry in the result list.<p>Keys are those instruments, values are dicts with the following keys:
instrument_id: string, the instrument id, same as key.
target: int, the target position.
long: int, the current holding long position.
short: int, the current holding short position.
long_pending: int, the current pending position in the long direction.
short_pending: int, the current pending position in the short direction.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.required_contract_margin">
<code class="descname">required_contract_margin</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.required_contract_margin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the required margin to trade the instrument at price and volume.
:param price: float, instrument price.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, required margin.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.trading_days_between">
<code class="descname">trading_days_between</code><span class="sig-paren">(</span><em>start_date</em>, <em>end_date=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.trading_days_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trading days between start_date and end_date.
:param start_date: date, start date, inclusive.
:param end_date: date, end date, inclusive. If None, defaults to self.trading_day().
:return: [date], the trading days between the specified range.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">CloseMarketOrderState</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState" title="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.state_utils.AbstractMarketOrderState</span></code></a></p>
<p>Initialize current.
:param strategy: AbstractStateBasedStrategy. The state machine.
:param name: string, the name of current state.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_orders">
<code class="descname">get_orders</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_orders" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.all_positions_with_actual_instrument_id">
<code class="descname">all_positions_with_actual_instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.all_positions_with_actual_instrument_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return currently holding positions in all traded instruments, including information about actual
instrument ids.
:return dict{string: dict{string: int}}, meaning {instrument_id: dict{actual_instrument_id: volume}}.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.contract_multiplier">
<code class="descname">contract_multiplier</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.contract_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Get multiplier of the given instrument.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return: int. The volume multiple.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.contract_value">
<code class="descname">contract_value</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.contract_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the contract value.
:param price: float, price of the instrument.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, contract value.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.default_period">
<code class="descname">default_period</code><span class="sig-paren">(</span><em>kind=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.default_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period for the given ohlc kind.
:param kind: string, can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based.</p>
<blockquote>
<div>If None, self.default_period_kind() is used.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int or float, default period. Will return None if there are multiple possible values.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.default_period_kind">
<code class="descname">default_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.default_period_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period kind.
:return: string, can be can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based,</p>
<blockquote>
<div>or None in case where no default is available.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_instrument_ids">
<code class="descname">get_instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the list of instrument ids from self.data whose market orders need to be placed.
:return: [string], the list of instrument ids.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_order_kind">
<code class="descname">get_order_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_order_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_reason">
<code class="descname">get_reason</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_reason" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the reason for placing the market order for the given instrument id from self.data
:param instrument_id: string, the instrument id.
:return: string, the reason for placing the market order.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the volume for the market order from self.data for the given instrument id.
:param instrument_id: string, the instrument id.
:return: int, the volume, positive number means long volume, negative value means short volume.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>orders=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.in_market_period">
<code class="descname">in_market_period</code><span class="sig-paren">(</span><em>timestamp=None</em>, <em>instrument_id=None</em>, <em>trading_day=None</em>, <em>delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.in_market_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the given timestamp is within any of the market periods of the instrument.
:param timestamp: datetime, current timestamp, if None, use self.now().
:param instrument_id: string, instrument id, if None, use self.instrument_id().
:param trading_day: date, current trading day, if None, use self.trading_day().
:param delta: timedelta or int or float, if not None, checks this delta before a market period ends.</p>
<blockquote>
<div>If type is int or float, it means timedelta(seconds=int).</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_market_order_supported">
<code class="descname">is_market_order_supported</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_market_order_supported" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.margin_rate">
<code class="descname">margin_rate</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the margin rate for the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param direction: string, not used.
:return: float, margin rate.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.market_end_time">
<code class="descname">market_end_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.market_end_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">datetime, the time when the market ends.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.money_per_tick">
<code class="descname">money_per_tick</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>with_margin=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.money_per_tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the money for a tick movement of the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param with_margin: bool, If True, the returned value is multiplied by margin rate.
:return: float, the money for a tick movement of the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.on_entry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.order_book_height">
<code class="descname">order_book_height</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.order_book_height" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the height of the order book.
:param instrument_id: string, instrument id, if None, self.instrument_id() is used.
:param level: int, the order book level, 0 means the nearest level, 1 means the next level.
:return: int, the order book height in unit of tick size.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.out_edges">
<code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.out_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.pending_orders">
<code class="descname">pending_orders</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.pending_orders" title="Permalink to this definition">¶</a></dt>
<dd><p>Return pending orders.
:param instrument_id: string, the instrument id whose pending orders are to be returned.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string:, int}, meaning dict{direction: volume}.
Keys are direction &#8216;long&#8217; or &#8216;short&#8217;, values are pending volumes in that direction.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.position_difference">
<code class="descname">position_difference</code><span class="sig-paren">(</span><em>target_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.position_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return difference between holding position and target positions.
:param target_positions: dict{string: int}, keys are instrument ids, values are the positions that</p>
<blockquote>
<div>should be reached for those instruments (treated as single sided position).
If a position is None, it means its target position is not known, then in the result, there will
be an entry for this instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: dict{string: object}}, For each instrument whose current holding position is different
from the given target position, there is an entry in the result dict. For instruments whose holding
position is the same as the given target position, there is no entry in the result list.<p>Keys are those instruments, values are dicts with the following keys:
instrument_id: string, the instrument id, same as key.
target: int, the target position.
long: int, the current holding long position.
short: int, the current holding short position.
long_pending: int, the current pending position in the long direction.
short_pending: int, the current pending position in the short direction.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.required_contract_margin">
<code class="descname">required_contract_margin</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.required_contract_margin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the required margin to trade the instrument at price and volume.
:param price: float, instrument price.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, required margin.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.trading_days_between">
<code class="descname">trading_days_between</code><span class="sig-paren">(</span><em>start_date</em>, <em>end_date=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.trading_days_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trading days between start_date and end_date.
:param start_date: date, start date, inclusive.
:param end_date: date, end date, inclusive. If None, defaults to self.trading_day().
:return: [date], the trading days between the specified range.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">PlaceMarketOrdersState</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState" title="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.state_utils.AbstractMarketOrderState</span></code></a></p>
<p>Class that can place a set of market orders and wait for all the orders to be fully executed.
Those orders can be either open or close orders, and they can open or close different instruments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>strategy</strong> &#8211; AbstractStateBasedStrategy. The state machine.</li>
<li><strong>name</strong> &#8211; string, the name of current state.</li>
<li><strong>transitions</strong> &#8211; dict{string:string}, the transitions from current state.
Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_orders">
<code class="descname">get_orders</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_orders" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.all_positions_with_actual_instrument_id">
<code class="descname">all_positions_with_actual_instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.all_positions_with_actual_instrument_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return currently holding positions in all traded instruments, including information about actual
instrument ids.
:return dict{string: dict{string: int}}, meaning {instrument_id: dict{actual_instrument_id: volume}}.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.contract_multiplier">
<code class="descname">contract_multiplier</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.contract_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Get multiplier of the given instrument.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return: int. The volume multiple.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.contract_value">
<code class="descname">contract_value</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.contract_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the contract value.
:param price: float, price of the instrument.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, contract value.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.default_period">
<code class="descname">default_period</code><span class="sig-paren">(</span><em>kind=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.default_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period for the given ohlc kind.
:param kind: string, can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based.</p>
<blockquote>
<div>If None, self.default_period_kind() is used.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int or float, default period. Will return None if there are multiple possible values.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.default_period_kind">
<code class="descname">default_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.default_period_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default period kind.
:return: string, can be can be OhlcGeneratorConstants.time_based or OhlcGeneratorConstants.volatility_based,</p>
<blockquote>
<div>or None in case where no default is available.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_instrument_ids">
<code class="descname">get_instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the list of instrument ids from self.data whose market orders need to be placed.
:return: [string], the list of instrument ids.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_order_kind">
<code class="descname">get_order_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_order_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_reason">
<code class="descname">get_reason</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_reason" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the reason for placing the market order for the given instrument id from self.data
:param instrument_id: string, the instrument id.
:return: string, the reason for placing the market order.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the volume for the market order from self.data for the given instrument id.
:param instrument_id: string, the instrument id.
:return: int, the volume, positive number means long volume, negative value means short volume.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>orders=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.in_market_period">
<code class="descname">in_market_period</code><span class="sig-paren">(</span><em>timestamp=None</em>, <em>instrument_id=None</em>, <em>trading_day=None</em>, <em>delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.in_market_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the given timestamp is within any of the market periods of the instrument.
:param timestamp: datetime, current timestamp, if None, use self.now().
:param instrument_id: string, instrument id, if None, use self.instrument_id().
:param trading_day: date, current trading day, if None, use self.trading_day().
:param delta: timedelta or int or float, if not None, checks this delta before a market period ends.</p>
<blockquote>
<div>If type is int or float, it means timedelta(seconds=int).</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_market_order_supported">
<code class="descname">is_market_order_supported</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_market_order_supported" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.margin_rate">
<code class="descname">margin_rate</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the margin rate for the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param direction: string, not used.
:return: float, margin rate.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.market_end_time">
<code class="descname">market_end_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.market_end_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">datetime, the time when the market ends.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.money_per_tick">
<code class="descname">money_per_tick</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>with_margin=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.money_per_tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the money for a tick movement of the given instrument.
:param instrument_id: string, instrument id, if None, self.instrument_id() will be used.
:param with_margin: bool, If True, the returned value is multiplied by margin rate.
:return: float, the money for a tick movement of the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.on_entry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.order_book_height">
<code class="descname">order_book_height</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.order_book_height" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the height of the order book.
:param instrument_id: string, instrument id, if None, self.instrument_id() is used.
:param level: int, the order book level, 0 means the nearest level, 1 means the next level.
:return: int, the order book height in unit of tick size.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.out_edges">
<code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.out_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.pending_orders">
<code class="descname">pending_orders</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.pending_orders" title="Permalink to this definition">¶</a></dt>
<dd><p>Return pending orders.
:param instrument_id: string, the instrument id whose pending orders are to be returned.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string:, int}, meaning dict{direction: volume}.
Keys are direction &#8216;long&#8217; or &#8216;short&#8217;, values are pending volumes in that direction.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.position_difference">
<code class="descname">position_difference</code><span class="sig-paren">(</span><em>target_positions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.position_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return difference between holding position and target positions.
:param target_positions: dict{string: int}, keys are instrument ids, values are the positions that</p>
<blockquote>
<div>should be reached for those instruments (treated as single sided position).
If a position is None, it means its target position is not known, then in the result, there will
be an entry for this instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: dict{string: object}}, For each instrument whose current holding position is different
from the given target position, there is an entry in the result dict. For instruments whose holding
position is the same as the given target position, there is no entry in the result list.<p>Keys are those instruments, values are dicts with the following keys:
instrument_id: string, the instrument id, same as key.
target: int, the target position.
long: int, the current holding long position.
short: int, the current holding short position.
long_pending: int, the current pending position in the long direction.
short_pending: int, the current pending position in the short direction.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.required_contract_margin">
<code class="descname">required_contract_margin</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.required_contract_margin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the required margin to trade the instrument at price and volume.
:param price: float, instrument price.
:param volume: int, the volume, positive number means long position, negative number means short position.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, required margin.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.trading_days_between">
<code class="descname">trading_days_between</code><span class="sig-paren">(</span><em>start_date</em>, <em>end_date=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.trading_days_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trading days between start_date and end_date.
:param start_date: date, start date, inclusive.
:param end_date: date, end date, inclusive. If None, defaults to self.trading_day().
:return: [date], the trading days between the specified range.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, use self.default_period_kind().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.default_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="constants.html" class="btn btn-neutral float-right" title="constants" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="roll.html" class="btn btn-neutral" title="roll" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, .
      Last updated on Dec 16, 2016.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../static/jquery.js"></script>
      <script type="text/javascript" src="../static/underscore.js"></script>
      <script type="text/javascript" src="../static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>