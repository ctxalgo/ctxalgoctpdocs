

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ctxalgoctp api docs &mdash; ctxalgoctp 0.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="ctxalgoctp 0.1 documentation" href="#"/> 

  
  <script src="static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="#" class="icon icon-home"> ctxalgoctp
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">ctxalgoctp api docs</a></li>
</ul>
</div>
          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="#">ctxalgoctp</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="#">Docs</a> &raquo;</li>
      
    <li>ctxalgoctp api docs</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="sources/index.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="ctxalgoctp-api-docs">
<h1>ctxalgoctp api docs<a class="headerlink" href="#ctxalgoctp-api-docs" title="Permalink to this headline">¶</a></h1>
<p>automodule:: ctxalgoctp.ctp.backtester</p>
<span class="target" id="module-ctxalgoctp.ctp.backtesting"></span><dl class="class">
<dt id="ctxalgoctp.ctp.backtesting.CtpMarketBacktesting">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.backtesting.</code><code class="descname">CtpMarketBacktesting</code><span class="sig-paren">(</span><em>message_queue</em>, <em>local_path</em>, <em>server_address</em>, <em>broker_id</em>, <em>investor_id</em>, <em>password</em>, <em>logger</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpMarketBacktesting" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.base.AbstractCtpMarket" title="ctxalgoctp.ctp.base.AbstractCtpMarket"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.base.AbstractCtpMarket</span></code></a></p>
<p>This is an abstract for backtesting. Clients should inherit from this class to simulate the market.</p>
<p>Initialize market API with message queue.
:param message_queue: CtpMessageQueue, Message queue.
:param local_path: string, the local folder to store temp files.
:param server_address: string, the server address to connect to.
:param broker_id: string, Broker id.
:param investor_id: string, investor id.
:param password: string, investor password.</p>
<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpMarketBacktesting.connect">
<code class="descname">connect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpMarketBacktesting.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect to the marker server.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpMarketBacktesting.subscribe">
<code class="descname">subscribe</code><span class="sig-paren">(</span><em>future_ids</em>, <em>exchange_id=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpMarketBacktesting.subscribe" title="Permalink to this definition">¶</a></dt>
<dd><p>Subscribe market data for the given futures.
:param future_ids: [string], list of future ids.
:param exchange_id: string, exchange id</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpMarketBacktesting.unsubscribe">
<code class="descname">unsubscribe</code><span class="sig-paren">(</span><em>future_ids</em>, <em>exchange_id=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpMarketBacktesting.unsubscribe" title="Permalink to this definition">¶</a></dt>
<dd><p>Un-subscribe market data for the given futures.
:param future_ids: [string], list of future ids.
:param exchange_id: string, exchange id</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpMarketBacktesting.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpMarketBacktesting.release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release resources used by current market API.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpMarketBacktesting.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpMarketBacktesting.now" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.backtesting.CtpMarketBacktesting.connection_status">
<code class="descname">connection_status</code><em class="property"> = None</em><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpMarketBacktesting.connection_status" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.backtesting.CtpMarketBacktesting.front_id">
<code class="descname">front_id</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpMarketBacktesting.front_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.backtesting.CtpMarketBacktesting.session_id">
<code class="descname">session_id</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpMarketBacktesting.session_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.backtesting.</code><code class="descname">CtpTradingBacktesting</code><span class="sig-paren">(</span><em>message_queue</em>, <em>local_path</em>, <em>server_address</em>, <em>broker_id</em>, <em>investor_id</em>, <em>password</em>, <em>resume_type</em>, <em>user_product_info</em>, <em>auth_code</em>, <em>logger</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.base.AbstractCtpTrading" title="ctxalgoctp.ctp.base.AbstractCtpTrading"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.base.AbstractCtpTrading</span></code></a></p>
<p>This is an abstract for backtesting. Clients should inherit from this class to simulate the market.</p>
<p>Initialize market API with message queue.
:param message_queue: CtpMessageQueue, Message queue.
:param local_path: string, the local folder to store temp files.
:param server_address: string, the server address to connect to.
:param broker_id: string, Broker id.
:param investor_id: string, investor id.
:param password: string, investor password.
:param resume_type: resume type
:param user_product_info: the user&#8217;s product info
:param auth_code: auth code
:param logger: Logger.</p>
<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.connect">
<code class="descname">connect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>connect to the trading server
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.disconnect">
<code class="descname">disconnect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>disconnect from the trading server
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release resources used by current trading API.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.send_order">
<code class="descname">send_order</code><span class="sig-paren">(</span><em>order_ref</em>, <em>future_id</em>, <em>direction</em>, <em>comb_offset_flag</em>, <em>comb_hedge_flag</em>, <em>volume_total_original</em>, <em>limit_price</em>, <em>order_price_type</em>, <em>time_condition</em>, <em>contingent_condition</em>, <em>stop_price</em>, <em>volume_condition</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.send_order" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new order
:param order_ref: int, if order ref less than 0, it will auto generate an order ref
:param future_id: string, future id
:param direction: TThostFtdcDirectionType, THOST_FTDC_D_Buy or THOST_FTDC_D_Sell
:param comb_offset_flag: TThostFtdcCombOffsetFlagType
:param comb_hedge_flag: TThostFtdcCombHedgeFlagType
:param volume_total_original: TThostFtdcVolumeType
:param limit_price: double, Limit price
:param order_price_type: TThostFtdcOrderPriceTypeType
:param time_condition: TThostFtdcTimeConditionType
:param contingent_condition: TThostFtdcContingentConditionType
:param stop_price: double
:param volume_condition: TThostFtdcVolumeConditionType
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.cancel_order">
<code class="descname">cancel_order</code><span class="sig-paren">(</span><em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.cancel_order" title="Permalink to this definition">¶</a></dt>
<dd><p>cancel an order
:param order: CThostFtdcOrderField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_investor_position">
<code class="descname">get_investor_position</code><span class="sig-paren">(</span><em>future_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>get investor position
:param future_id: string
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_investor_position_detail">
<code class="descname">get_investor_position_detail</code><span class="sig-paren">(</span><em>future_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_investor_position_detail" title="Permalink to this definition">¶</a></dt>
<dd><p>get investor position detail
:param future_id: string
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_order">
<code class="descname">get_order</code><span class="sig-paren">(</span><em>future_id=''</em>, <em>exchange_id=''</em>, <em>order_sys_id=''</em>, <em>insert_time_start=''</em>, <em>insert_time_end=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_order" title="Permalink to this definition">¶</a></dt>
<dd><p>查询报单
:param future_id: string future id
:param exchange_id: string exchange id
:param order_sys_id: string order sys id
:param insert_time_start: string insert start time
:param insert_time_end: string insert end time
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_trade">
<code class="descname">get_trade</code><span class="sig-paren">(</span><em>future_id=''</em>, <em>exchange_id=''</em>, <em>trade_id=''</em>, <em>trade_time_start=''</em>, <em>trade_time_end=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>查询报单
:param future_id: string future id
:param exchange_id: string exchange id
:param trade_id: string trade id
:param trade_time_start: string trade start time
:param trade_time_end: string trade end time
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_trading_account">
<code class="descname">get_trading_account</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>get trading account info
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_instrument">
<code class="descname">get_instrument</code><span class="sig-paren">(</span><em>future_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>get future info
:param futrre_id: string
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_commission_rate">
<code class="descname">get_commission_rate</code><span class="sig-paren">(</span><em>future_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_commission_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>get future&#8217;s commission rate
:param future_id: string
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_margin_rate">
<code class="descname">get_margin_rate</code><span class="sig-paren">(</span><em>future_id</em>, <em>hedge_flag</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>get future margin rate
:param future_id: string
:param hedge_flag: TThostFtdcHedgeFlagType
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_deep_market_data">
<code class="descname">get_deep_market_data</code><span class="sig-paren">(</span><em>future_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_deep_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Subscribe market data for the given futures.
:param future_id: string
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.now" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.close_limit_order">
<code class="descname">close_limit_order</code><span class="sig-paren">(</span><em>future_id</em>, <em>price</em>, <em>volume</em>, <em>kind='Normal'</em>, <em>order_ref=-1</em>, <em>transaction_id=None</em>, <em>reason=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.close_limit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a limit order.
:param future_id: string, A single future id.
:param price: double, the price for the limit order.
:param volume: int, the volume for the limit order. Positive number means long position,</p>
<blockquote>
<div>negative number means short position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kind</strong> &#8211; LimitOrderKind. Normal means a normal limit order. FAK means Fill-and-kill, FOK means Fill-or-Kill.</td>
</tr>
</tbody>
</table>
<p>:param order_ref, the order reference number. -1 means that the system will assign a value.
:param transaction_id: string, transaction id.
:param reason: string, reason for placing the order.
:return: int, order reference number.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.close_market_order">
<code class="descname">close_market_order</code><span class="sig-paren">(</span><em>future_id</em>, <em>volume</em>, <em>order_ref=-1</em>, <em>transaction_id=None</em>, <em>reason=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.close_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Send an order to close a trade at market price.
:param future_id, string, a SINGLE future id.
:param volume: int, the volume to order, positive number means long position,</p>
<blockquote>
<div>negative number means short position.</div></blockquote>
<p>:param order_ref, the order reference number. -1 means that the system will assign a value.
:param transaction_id: string, transaction id.
:param reason: string, reason for placing the order.
:return: int, order reference number.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.connection_status">
<code class="descname">connection_status</code><em class="property"> = None</em><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.connection_status" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.front_id">
<code class="descname">front_id</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.front_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_order_commission_rate">
<code class="descname">get_order_commission_rate</code><span class="sig-paren">(</span><em>future_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.get_order_commission_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Get open and close order commission rate.
:param future_id: string, the future id.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.open_limit_order">
<code class="descname">open_limit_order</code><span class="sig-paren">(</span><em>future_id</em>, <em>price</em>, <em>volume</em>, <em>kind='Normal'</em>, <em>order_ref=-1</em>, <em>transaction_id=None</em>, <em>reason=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.open_limit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a limit order.
:param future_id: string, A single future id.
:param price: double, the price for the limit order.
:param volume: int, the volume for the limit order. Positive number means long position,</p>
<blockquote>
<div>negative number means short position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kind</strong> &#8211; LimitOrderKind. Normal means a normal limit order. FAK means Fill-and-kill, FOK means Fill-or-Kill.</td>
</tr>
</tbody>
</table>
<p>:param order_ref, the order reference number. -1 means that the system will assign a value.
:param transaction_id: string, transaction id.
:param reason: string, reason for placing the order.
:return: int, order reference number.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.open_market_order">
<code class="descname">open_market_order</code><span class="sig-paren">(</span><em>future_id</em>, <em>volume</em>, <em>order_ref=-1</em>, <em>transaction_id=None</em>, <em>reason=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.open_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Send an order to open a trade at market price.
:param future_id, string, a SINGLE future id.
:param volume: int, the volume to order, positive number means long position,</p>
<blockquote>
<div>negative number means short position.</div></blockquote>
<p>:param order_ref, the order reference number. -1 means that the system will assign a value.
:param transaction_id: string, transaction id.
:param reason: string, reason for placing the order.
:return: int, order reference number.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.session_id">
<code class="descname">session_id</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.backtesting.CtpTradingBacktesting.session_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.backtesting_utils"></span><dl class="function">
<dt id="ctxalgoctp.ctp.backtesting_utils.get_temp_folder">
<code class="descclassname">ctxalgoctp.ctp.backtesting_utils.</code><code class="descname">get_temp_folder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting_utils.get_temp_folder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a temporary folder and return its absolute path.
:return: string, the absolute path of the created temporary folder.</p>
</dd></dl>

<dl class="function">
<dt id="ctxalgoctp.ctp.backtesting_utils.get_data_source">
<code class="descclassname">ctxalgoctp.ctp.backtesting_utils.</code><code class="descname">get_data_source</code><span class="sig-paren">(</span><em>instrument_ids</em>, <em>base_folder</em>, <em>start_date</em>, <em>end_date</em>, <em>data_period</em>, <em>data_paths=None</em>, <em>line_parser=None</em>, <em>future_trading_utils=None</em>, <em>ohlc_reader=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting_utils.get_data_source" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the required data source.
:param instrument_ids: [string], the list of instrument ids whose trading data is retrieved.
:param base_folder: string, the folder to store downloaded data. The data is downloaded from CTX servers.
:param start_date: date or string in form of yyyy-mm-dd, the start date (inclusive) of the data.
:param end_date: date or string in form of yyyy-mm-dd, the end date (inclusive) of the data.
:param data_period: Periodicity, the periodicity of the data to download.
:param data_paths: dict{string: string}, meaning dict{instrument_id: data_file_path},</p>
<blockquote>
<div>it gives the external data for each of the instruments. For an instrument, if its data path is given here,
then the data won&#8217;t be downloaded from CTX servers. The data inside the given file is used directly.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>line_parser</strong> &#8211; Ignore this parameter.</li>
<li><strong>future_trading_utils</strong> &#8211; FutureTradingUtils, the trading utils which provide market periods information.</li>
<li><strong>ohlc_reader</strong> &#8211; AbstractOhlcReader, the reader to read an ohlc from file.
It can be a text reader or a binary reader.
If not None, use this reader to load ohlc data from file, and line_parser will not be used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">AbstractDataSource.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ctxalgoctp.ctp.backtesting_utils.safe_get_base_folder">
<code class="descclassname">ctxalgoctp.ctp.backtesting_utils.</code><code class="descname">safe_get_base_folder</code><span class="sig-paren">(</span><em>strategy_class</em>, <em>config</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting_utils.safe_get_base_folder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return default place for base folder.
:param strategy_class: class, the class of the strategy.
:param config: dict{string: object}, the strategy config.</p>
</dd></dl>

<dl class="function">
<dt id="ctxalgoctp.ctp.backtesting_utils.get_proper_backtest_data_period">
<code class="descclassname">ctxalgoctp.ctp.backtesting_utils.</code><code class="descname">get_proper_backtest_data_period</code><span class="sig-paren">(</span><em>backtest_data_period</em>, <em>config</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting_utils.get_proper_backtest_data_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to decide on a proper backtest data period.
:param backtest_data_period: Periodicity, if not None, return it directly.</p>
<blockquote>
<div>Otherwise, try to decide a proper backtest data period.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>config</strong> &#8211; dict{string: object}, the config object for the strategy.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Periodicity, the decided backtest data period, or None if no proper period can be decided.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ctxalgoctp.ctp.backtesting_utils.is_date_parameter_valid">
<code class="descclassname">ctxalgoctp.ctp.backtesting_utils.</code><code class="descname">is_date_parameter_valid</code><span class="sig-paren">(</span><em>date_spec</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting_utils.is_date_parameter_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is date_spec a valid date specification?
:param date_spec: date or string in form of yyyy-mm-dd.
:return: boolean.</p>
</dd></dl>

<dl class="function">
<dt id="ctxalgoctp.ctp.backtesting_utils.backtest">
<code class="descclassname">ctxalgoctp.ctp.backtesting_utils.</code><code class="descname">backtest</code><span class="sig-paren">(</span><em>strategy_class</em>, <em>config_getter</em>, <em>start_date</em>, <em>end_date</em>, <em>backtest_data_period=None</em>, <em>initial_capital=1000000.0</em>, <em>data_paths=None</em>, <em>line_parser=None</em>, <em>daily_start_time=None</em>, <em>daily_end_time=None</em>, <em>on_strategy_object_created=None</em>, <em>user=None</em>, <em>slippage_model=None</em>, <em>is_eager_order_execution=True</em>, <em>should_profile=False</em>, <em>has_commission=True</em>, <em>message_random_delay_enabled=False</em>, <em>should_print=True</em>, <em>slow_motion=None</em>, <em>strategy_callbacks=None</em>, <em>is_extrapolate_data_allowed=True</em>, <em>report_has_charting_url=True</em>, <em>perform_backtest=True</em>, <em>ohlc_reader=None</em>, <em>security_company=None</em>, <em>data_feed=None</em>, <em>log_in_console=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting_utils.backtest" title="Permalink to this definition">¶</a></dt>
<dd><p>Backtest your strategy.
:param strategy_class: class, the class of the strategy.
:param config_getter: A function pointer to return config to run strategy. Or a dict{string: object}, keys are</p>
<blockquote>
<div>parameter names, values are parameter values. If it is a function pointer, the function pointer takes no
arguments, and returns a dict{string: object}.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>start_date</strong> &#8211; date or string in form of yyyy-mm-dd, the start date (inclusive) for backtesting.</li>
<li><strong>end_date</strong> &#8211; date or string in form of yyyy-mm-dd, the end date (inclusive) for backtesting.</li>
<li><strong>backtest_data_period</strong> &#8211; Periodicity, the period for backtesting data.
If None, try to decide on a proper period.</li>
<li><strong>initial_capital</strong> &#8211; float, the initial capital used for the backtesting.</li>
<li><strong>data_paths</strong> &#8211; dict{string: string}, the list of data file paths for instrument_ids.
Keys are instrument ids, values are the data file paths for those instruments.
Used to provide external data files for the backtester.
In tick mode, the paths should be folders, in ohlc bar mode, the paths should be files.</li>
<li><strong>line_parser</strong> &#8211; <p>a function pointer which parses an ohlc line into data.
Function signature: string -&gt; (timestamp, open, high, low, <a href="#id1"><span class="problematic" id="id2">close_</span></a>, volume, amount)
The parameter to the function is a string representing a line in ohlc file.
The return value of the function is a tuple containing the parsed data:</p>
<blockquote>
<div>timestamp: datetime, the timestamp of the ohlc line.
open: float, the open price,
high: float, the high price,
low: float, the low price,
close: float, the close price,
volume: int, the volume,
amount: float, the amount of money that has been traded, if there is no amount data<blockquote>
<div>in the raw text, set this to 0.</div></blockquote>
</div></blockquote>
<p>If line parser is None, a default parser is used.</p>
</li>
<li><strong>daily_start_time</strong> &#8211; time, the time for the backtester to start every day.</li>
<li><strong>daily_end_time</strong> &#8211; time, the time for the backtester to end every day.</li>
<li><strong>on_strategy_object_created</strong> &#8211; function pointer, with a single parameter, which is the
currently created strategy object. This function will be invoked after the backtester creates
a new strategy instance. Used for setup things. For example, to setup a mission controller.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:param user, string, the trading account id. Usually you can leave it as None. You only need to</dt>
<dd>set an explicit trading account id if you want to test the control-flow component.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>slippage_model</strong> &#8211; AbstractSlippageModel, the slippage model to use for the backtester.
If None, VolumeBasedSlippageModel will be used.</li>
<li><strong>is_eager_order_execution</strong> &#8211; bool, indicates whether pending orders should be executed
at the current known price information, or the backtester waits until the next price to arrive
and then executes pending orders.</li>
<li><strong>should_profile</strong> &#8211; bool, if True, enable the profiler and output
the profiling information to console when backtesting finishes.</li>
<li><strong>has_commission</strong> &#8211; bool, if True, all trades have normal commission.
If False, all trades have zero commission. Useful for initial stage strategy research.</li>
<li><strong>message_random_delay_enabled</strong> &#8211; bool, should random delay of trading and market queue
messages be enabled?</li>
<li><strong>should_print</strong> &#8211; bool, if True, print backtesting result into console.</li>
<li><strong>slow_motion</strong> &#8211; SlowMotion, the slow motion config.</li>
<li><strong>strategy_callbacks</strong> &#8211; AbstractStrategyCallbacks, if not None, provides external strategy callbacks
which will be invoked when strategy level callbacks happen. It is useful to attach new behavior
to the existing strategy code without change the code itself.</li>
<li><strong>is_extrapolate_data_allowed</strong> &#8211; boolean, If True, when executing limit orders, allow the use of
ask and bid prices to fill orders for specified limit price even such price is not seen at traded prices.</li>
<li><strong>report_has_charting_url</strong> &#8211; boolean, if True, the returned report contains urls used for charting.
Generating charting urls takes time, so if you don&#8217;t need them, set this parameter to False.</li>
<li><strong>perform_backtest</strong> &#8211; boolean, if True, perform actual backtesting, if False, do not do any backtesting,
instead, go directly to backtesting result processing. This is useful when you already finished backtesting,
and want to do some processing of the backtesting result.</li>
<li><strong>ohlc_reader</strong> &#8211; AbstractOhlcReader, the reader to read an ohlc from file.
It can be a text reader or a binary reader.
If not None, use this reader to load ohlc data from file, and line_parser will not be used.</li>
<li><strong>security_company</strong> &#8211; string, the security company. Different security company may have different
rates for commission, margin, and this attribute is used to take that into account.
f None, use a default company.</li>
<li><strong>data_feed</strong> &#8211; AbstractDataFeed, data feed.</li>
<li><strong>log_in_console</strong> &#8211; bool, if True and if there is no logger provided in the strategy configuration,
create a default logger which prints logs into console.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return (CtpStrategyReport, AbstractDataSource), backtesting result report, and the data source used by</dt>
<dd>the backtesting sessions. The data source can be used to do charting later.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="ctxalgoctp.ctp.backtesting_utils.walk_forward_optimize">
<code class="descclassname">ctxalgoctp.ctp.backtesting_utils.</code><code class="descname">walk_forward_optimize</code><span class="sig-paren">(</span><em>strategy_class</em>, <em>config_getter</em>, <em>base_folder</em>, <em>start_date</em>, <em>end_date</em>, <em>optimizer</em>, <em>param_specs</em>, <em>objectives</em>, <em>training_window</em>, <em>testing_window</em>, <em>constraints=None</em>, <em>regularizers=None</em>, <em>testing_start_day=None</em>, <em>backtest_data_period=None</em>, <em>initial_capital=1000000.0</em>, <em>data_paths=None</em>, <em>line_parser=None</em>, <em>is_eager_order_execution=True</em>, <em>slippage_model=None</em>, <em>has_commission=True</em>, <em>strategy_callbacks=None</em>, <em>is_extrapolate_data_allowed=True</em>, <em>should_print=True</em>, <em>report_has_charting_url=True</em>, <em>progress_logger=None</em>, <em>ohlc_reader=None</em>, <em>security_company=None</em>, <em>data_feed=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting_utils.walk_forward_optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform walk-forward optimization.
:param strategy_class: Python class name, the class name for the strategy.
:param config_getter: A function to return config to run strategy. Or a dict{string: object}, keys are</p>
<blockquote>
<div>parameter names, values are parameter values.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>base_folder</strong> &#8211; string, the folder to store log file.</li>
<li><strong>start_date</strong> &#8211; date or string in form of yyyy-mm-dd, the start date (inclusive) for backtesting.</li>
<li><strong>end_date</strong> &#8211; date or string in form of yyyy-mm-dd, the end date (inclusive) for backtesting.</li>
<li><strong>optimizer</strong> &#8211; OptimizerConfig from ctxalgolib.ta.optimization.optimization_utils. It contains the
optimizer to use and its options. Use optimization_utils.OptimizerUtils to create the optimizer.</li>
<li><strong>param_specs</strong> &#8211; [ctxalgolib.ta.optimization.parameters.Parameter], the list of parameters used in optimization.</li>
<li><strong>objectives</strong> &#8211; [lambda], list of lambda functions used as optimization objectives (minimization).</li>
<li><strong>training_window</strong> &#8211; int, the length of training window in number of days.</li>
<li><strong>testing_window</strong> &#8211; int, the length of testing window in number of days.</li>
<li><strong>constraints</strong> &#8211; [lambda], list of lambda functions used as constraints over the parameters.</li>
<li><strong>regularizers</strong> &#8211; [cxalgolib.ta.optimization.regularizer.RegularizerBase], list of
regularizers for optimization parameters. None means no regularization.</li>
<li><strong>testing_start_day</strong> &#8211; int, 1-based first day when testing starts. If None, it starts from the first day.</li>
<li><strong>backtest_data_period</strong> &#8211; Periodicity, the period for backtesting data.
If None, try to decide a proper backtest data period.</li>
<li><strong>initial_capital</strong> &#8211; float, the initial capital.</li>
<li><strong>data_paths</strong> &#8211; dict{string: string}, the list of data file paths for instrument_ids.
Keys are instrument ids, values are the OHLC file paths for those instruments.
Used to provide external data files for the backtester.
In tick mode, the paths should be folders, in ohlc bar mode, the paths should be files.</li>
<li><strong>line_parser</strong> &#8211; <p>a function pointer which parses an ohlc line into data.
Function signature: string -&gt; (timestamp, open, high, low, <a href="#id3"><span class="problematic" id="id4">close_</span></a>, volume, amount)
The parameter to the function is a string representing a line in ohlc file.
The return value of the function is a tuple containing the parsed data:</p>
<blockquote>
<div>timestamp: datetime, the timestamp of the ohlc line.
open: float, the open price,
high: float, the high price,
low: float, the low price,
close: float, the close price,
volume: int, the volume,
amount: float, the amount of money that has been traded, if there is no amount data<blockquote>
<div>in the raw text, set this to 0.</div></blockquote>
</div></blockquote>
<p>If line parser is None, a default parser is used.</p>
</li>
<li><strong>is_eager_order_execution</strong> &#8211; bool, indicates whether pending orders should be executed
at the current known price information, or the backtester waits until the next price to arrive
and then executes pending orders.</li>
<li><strong>slippage_model</strong> &#8211; AbstractSlippageModel, the slippage model to use for the backtester.
If None, VolumeBasedSlippageModel will be used.</li>
<li><strong>has_commission</strong> &#8211; bool, if True, all trades have normal commission.
If False, all trades have zero commission. Useful for initial stage strategy research.</li>
<li><strong>strategy_callbacks</strong> &#8211; AbstractStrategyCallbacks, if not None, provides external strategy callbacks
which will be invoked when strategy level callbacks happen. It is useful to attach new behavior
to the existing strategy code without change the code itself.</li>
<li><strong>is_extrapolate_data_allowed</strong> &#8211; boolean, If True, when executing limit orders, allow the use of
ask and bid prices to fill orders for specified limit price even such price is not seen at traded prices.</li>
<li><strong>should_print</strong> &#8211; bool, if True, print backtesting result into console.</li>
<li><strong>report_has_charting_url</strong> &#8211; boolean, if True, the returned report contains urls used for charting.
Generating charting urls takes time, so if you don&#8217;t need them, set this parameter to False.</li>
<li><strong>progress_logger</strong> &#8211; LoggerHandler, the logger to output walk-forward progress.</li>
<li><strong>ohlc_reader</strong> &#8211; AbstractOhlcReader, the reader to read an ohlc from file.
It can be a text reader or a binary reader.
If not None, use this reader to load ohlc data from file, and line_parser will not be used.</li>
<li><strong>security_company</strong> &#8211; string, the security company. Different security company may have different
rates for commission, margin, and this attribute is used to take that into account.
f None, use a default company.</li>
<li><strong>data_feed</strong> &#8211; AbstractDataFeed, data feed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return (CtpStrategyReport, AbstractDataSource), backtesting result report, and the data source used by</dt>
<dd>the backtesting sessions. The data source can be used to do charting later.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="ctxalgoctp.ctp.backtesting_utils.simulate_or_live_trade">
<code class="descclassname">ctxalgoctp.ctp.backtesting_utils.</code><code class="descname">simulate_or_live_trade</code><span class="sig-paren">(</span><em>strategy_class</em>, <em>config_getter</em>, <em>base_folder</em>, <em>market_server</em>, <em>trading_server</em>, <em>user</em>, <em>password</em>, <em>broker_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting_utils.simulate_or_live_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate or live trade the strategy.
When the market_server, trading_server, user, password and broker_id are for simulation, then the strategy
will run against the simulation environment. If these arguments are for real trading, the the strategy
will run in live trade with real money.
:param strategy_class: class, the class of the strategy.
:param config_getter: A function to return config to run strategy.
:param market_server: string, the server name for market data. In form of <a class="reference external" href="tcp://ddd.ddd.ddd.ddd:port">tcp://ddd.ddd.ddd.ddd:port</a>.
:param trading_server: string, the server name for trading data. In form of <a class="reference external" href="tcp://ddd.ddd.ddd.ddd:port">tcp://ddd.ddd.ddd.ddd:port</a>.
:param user: string, user name.
:param password: string, password.
:param broker_id: string, broker_id.</p>
</dd></dl>

<dl class="function">
<dt id="ctxalgoctp.ctp.backtesting_utils.get_slippage_model">
<code class="descclassname">ctxalgoctp.ctp.backtesting_utils.</code><code class="descname">get_slippage_model</code><span class="sig-paren">(</span><em>name</em>, <em>parameters</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.backtesting_utils.get_slippage_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the slippage model defined by name and parameters.
:param name: string, name of the slippage model.
:param parameters: dict{string: object}, the parameters for the slippage model.</p>
<blockquote>
<div>Keys are parameter names, values are parameter values.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">AbstractSlippageModel.</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.base"></span><dl class="function">
<dt id="ctxalgoctp.ctp.base.pointer_to_object">
<code class="descclassname">ctxalgoctp.ctp.base.</code><code class="descname">pointer_to_object</code><span class="sig-paren">(</span><em>callbacks</em>, <em>logger</em>, <em>func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.pointer_to_object" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.base.OrderKind">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.base.</code><code class="descname">OrderKind</code><a class="headerlink" href="#ctxalgoctp.ctp.base.OrderKind" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="ctxalgoctp.ctp.base.OrderKind.Market">
<code class="descname">Market</code><em class="property"> = 'Market'</em><a class="headerlink" href="#ctxalgoctp.ctp.base.OrderKind.Market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.base.OrderKind.NormalLimit">
<code class="descname">NormalLimit</code><em class="property"> = 'Normal'</em><a class="headerlink" href="#ctxalgoctp.ctp.base.OrderKind.NormalLimit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.base.OrderKind.FillAndKill">
<code class="descname">FillAndKill</code><em class="property"> = 'FAK'</em><a class="headerlink" href="#ctxalgoctp.ctp.base.OrderKind.FillAndKill" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.base.OrderKind.FillOrKill">
<code class="descname">FillOrKill</code><em class="property"> = 'FOK'</em><a class="headerlink" href="#ctxalgoctp.ctp.base.OrderKind.FillOrKill" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.base.</code><code class="descname">CtpCallBacks</code><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks" title="Permalink to this definition">¶</a></dt>
<dd><p>The class for all callbacks for both market and trading APIs.
Sub-class should redefine needed callbacks to implement customized behavior.
Note:</p>
<blockquote>
<div><ol class="arabic simple">
<li>that some callbacks from the market API and trading API have the same name,
but we put them into different callbacks. See on_market_connected and on_trading_connected
as an example.</li>
</ol>
</div></blockquote>
<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_market_connected">
<code class="descname">on_market_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_market_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on market server connect status change
:param p_api: c_void_p
:param rsp_user_login: CThostFtdcRspUserLoginField
:param status: ConnectionStatus int
:param other_data: dict{string: object}, optional other data.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_market_disconnected">
<code class="descname">on_market_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_market_disconnected" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on market server disconnected
:param p_api: c_void_p
:param rsp_info: CThostFtdcRspInfoField
:param status: ConnectionStatus int
:param other_data: dict{string: object}, optional other data.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_market_rsp_error">
<code class="descname">on_market_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_market_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on market server when error occurred
:param p_api: c_void_p
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:param other_data: dict{string: object}, optional other data.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_market_rtn_depth_market_data">
<code class="descname">on_market_rtn_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_market_rtn_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on market server when receive market data
:param p_api:  c_void_p
:param depth_market_data: CThostFtdcDepthMarketDataField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_trading_connected">
<code class="descname">on_trading_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_trading_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on trading server connect status change
:param p_api: c_void_p
:param rsp_user_login: CThostFtdcRspUserLoginField
:param status: ConnectionStatus int
:param other_data: dict{string: object}, optional other data.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_trading_disconnected">
<code class="descname">on_trading_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_trading_disconnected" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on trading server disconnected
:param p_api: c_void_p
:param rsp_info: CThostFtdcRspInfoField
:param status: ConnectionStatus int
:param other_data: dict{string: object}, optional other data.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_error">
<code class="descname">on_trading_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on trading server when error occurred
:param p_api: c_void_p
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:param other_data: dict{string: object}, optional other data.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_trading_err_rtn_order_action">
<code class="descname">on_trading_err_rtn_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>order_action</em>, <em>res_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_trading_err_rtn_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>如果交易所认为撤单错误。由交易托管系统主动通知客户端，该方法会被调用。
:param p_api: c_void_p
:param order_action: CThostFtdcOrderActionField
:param res_info: CThostFtdcRspInfoField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_trading_err_rtn_order_insert">
<code class="descname">on_trading_err_rtn_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>res_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_trading_err_rtn_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>如果交易所认为报单错误。由交易托管系统主动通知客户端，该方法会被调用。
:param p_api: c_void_p
:param input_order: CThostFtdcInputOrderField
:param res_info: CThostFtdcRspInfoField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_order_action">
<code class="descname">on_trading_rsp_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order_action</em>, <em>res_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>交易托管系统收到撤单指令，如果没有通过参数校验，拒绝接受撤单指令。用户就会收到此消息，其中包含了错误编码和错误消息
:param p_api: c_void_p
:param order_action: CThostFtdcInputOrderActionField
:param res_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_order_insert">
<code class="descname">on_trading_rsp_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>res_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>交易托管系统收到报单指令，如果没有通过参数校验，拒绝接受报单指令。用户就会收到此消息，其中包含了错误编码和错误消息
:param p_api: c_void_p
:param input_order: CThostFtdcInputOrderField
:param res_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_depth_market_data">
<code class="descname">on_trading_rsp_qry_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询行情响应。当客户端发出请求查询行情指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param depth_market_data: CThostFtdcDepthMarketDataField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_instrument">
<code class="descname">on_trading_rsp_qry_instrument</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询合约响应。当客户端发出请求查询合约指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param instrument: CThostFtdcInstrumentField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_instrument_commission_rate">
<code class="descname">on_trading_rsp_qry_instrument_commission_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_commission_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_instrument_commission_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询手续费响应。
:param p_api: c_void_p
:param instrument_commission_rate: CThostFtdcInstrumentCommissionRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_instrument_margin_rate">
<code class="descname">on_trading_rsp_qry_instrument_margin_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_margin_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_instrument_margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询保证金响应。
:param p_api: c_void_p
:param instrument_margin_rate: CThostFtdcInstrumentMarginRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_instrument_order_comm_rate">
<code class="descname">on_trading_rsp_qry_instrument_order_comm_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_order_comm_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_instrument_order_comm_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询下单撤单手续费响应。
:param p_api: c_void_p
:param instrument_order_comm_rate: CThostFtdcInstrumentOrderCommRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_investor_position">
<code class="descname">on_trading_rsp_qry_investor_position</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>投资者持仓查询应答。当客户端发出投资者持仓查询指令后，后交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param investor_position: CThostFtdcInvestorPositionField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_investor_position_detail">
<code class="descname">on_trading_rsp_qry_investor_position_detail</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position_detail</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_investor_position_detail" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询投资者持仓明细响应。当客户端发出请求请求查询投资者持仓明细指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api:c_void_p
:param investor_position_detail: CThostFtdcInvestorPositionDetailField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_trading_account">
<code class="descname">on_trading_rsp_qry_trading_account</code><span class="sig-paren">(</span><em>p_api</em>, <em>trading_account</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询资金账户响应。当客户端发出请求查询资金账户指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param trading_account: CThostFtdcTradingAccountField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rtn_order">
<code class="descname">on_trading_rtn_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rtn_order" title="Permalink to this definition">¶</a></dt>
<dd><p>报单回报。当客户端进行报单录入、报单操作及其它原因（如部分成交）导致报单状态发生变化时，交易托管系统会主动通知客户端，该方法会被调用。
:param p_api: c_void_p
:param order: CThostFtdcOrderField</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rtn_trade">
<code class="descname">on_trading_rtn_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rtn_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>成交回报。当发生成交时交易托管系统会通知客户端，该方法会被调用。
:param p_api: c_void_p
:param trade:CThostFtdcTradeField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_order">
<code class="descname">on_trading_rsp_qry_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_order" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询报单响应
:param p_api: c_void_p
:param order: CThostFtdcOrderField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_trade">
<code class="descname">on_trading_rsp_qry_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_trading_rsp_qry_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询成交响应
:param p_api: c_void_p
:param trade: CThostFtdcTradeField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_mission_control">
<code class="descname">on_mission_control</code><span class="sig-paren">(</span><em>message</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_mission_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when a message from control center is arrived.
:param message: string, the message from the the control center.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpCallBacks.on_idle_event">
<code class="descname">on_idle_event</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpCallBacks.on_idle_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when there is no event from the outside.
:return:</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.base.CtpMessageQueue">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.base.</code><code class="descname">CtpMessageQueue</code><span class="sig-paren">(</span><em>callbacks</em>, <em>is_backtesting</em>, <em>c2ctp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpMessageQueue" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize message queue.
:param callbacks: list of CtpCallBacks, the callbacks.
:param is_backtesting: boolean, True if the queue is created in backtesting.
:param c2ctp: pointer, pointer to the underlying c API.</p>
<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpMessageQueue.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpMessageQueue.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear all messages in current message queue.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpMessageQueue.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpMessageQueue.release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release resourced used by current message queue.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpMessageQueue.process_first_message">
<code class="descname">process_first_message</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpMessageQueue.process_first_message" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the first message in the queue (if any).
Invoke corresponding callback function for that message.
:return bool, True if there is some message in the queue to process. False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpMessageQueue.start_pulling">
<code class="descname">start_pulling</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpMessageQueue.start_pulling" title="Permalink to this definition">¶</a></dt>
<dd><p>Start pulling messages from the server and call corresponding callback functions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpMessageQueue.stop_pulling">
<code class="descname">stop_pulling</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpMessageQueue.stop_pulling" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop pulling of messages.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpMessageQueue.enqueue">
<code class="descname">enqueue</code><span class="sig-paren">(</span><em>func_name</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpMessageQueue.enqueue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.CtpMessageQueue.invoke_log">
<code class="descname">invoke_log</code><span class="sig-paren">(</span><em>caller_class</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.CtpMessageQueue.invoke_log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.base.AbstractCtpMarket">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.base.</code><code class="descname">AbstractCtpMarket</code><span class="sig-paren">(</span><em>message_queue</em>, <em>local_path</em>, <em>server_address</em>, <em>broker_id</em>, <em>investor_id</em>, <em>password</em>, <em>logger</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpMarket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Initialize market API with message queue.
:param message_queue: CtpMessageQueue, Message queue.
:param local_path: string, the local folder to store temp files.
:param server_address: string, the server address to connect to.
:param broker_id: string, Broker id.
:param investor_id: string, investor id.
:param password: string, investor password.
:param logger: Logger</p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.base.AbstractCtpMarket.connection_status">
<code class="descname">connection_status</code><em class="property"> = None</em><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpMarket.connection_status" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.base.AbstractCtpMarket.front_id">
<code class="descname">front_id</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpMarket.front_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.base.AbstractCtpMarket.session_id">
<code class="descname">session_id</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpMarket.session_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpMarket.connect">
<code class="descname">connect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpMarket.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect to the marker server.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpMarket.subscribe">
<code class="descname">subscribe</code><span class="sig-paren">(</span><em>future_ids</em>, <em>exchange_id=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpMarket.subscribe" title="Permalink to this definition">¶</a></dt>
<dd><p>Subscribe market data for the given futures.
:param future_ids: [string], list of future ids.
:param exchange_id: string, exchange id</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpMarket.unsubscribe">
<code class="descname">unsubscribe</code><span class="sig-paren">(</span><em>future_ids</em>, <em>exchange_id=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpMarket.unsubscribe" title="Permalink to this definition">¶</a></dt>
<dd><p>Un-subscribe market data for the given futures.
:param future_ids: [string], list of future ids.
:param exchange_id: string, exchange id</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpMarket.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpMarket.release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release resources used by current market API.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpMarket.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpMarket.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current time stamp.
:return: datetime</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.base.</code><code class="descname">AbstractCtpTrading</code><span class="sig-paren">(</span><em>message_queue</em>, <em>local_path</em>, <em>server_address</em>, <em>broker_id</em>, <em>investor_id</em>, <em>password</em>, <em>resume_type</em>, <em>user_product_info</em>, <em>auth_code</em>, <em>logger</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Initialize market API with message queue.
:param message_queue: CtpMessageQueue, Message queue.
:param local_path: string, the local folder to store temp files.
:param server_address: string, the server address to connect to.
:param broker_id: string, Broker id.
:param investor_id: string, investor id.
:param password: string, investor password.
:param resume_type: resume type
:param user_product_info: the user&#8217;s product info
:param auth_code: auth code
:param logger: Logger</p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.connection_status">
<code class="descname">connection_status</code><em class="property"> = None</em><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.connection_status" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.front_id">
<code class="descname">front_id</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.front_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.session_id">
<code class="descname">session_id</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.session_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.connect">
<code class="descname">connect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>connect to the trading server
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.disconnect">
<code class="descname">disconnect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>disconnect from the trading server
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release resources used by current trading API.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.open_market_order">
<code class="descname">open_market_order</code><span class="sig-paren">(</span><em>future_id</em>, <em>volume</em>, <em>order_ref=-1</em>, <em>transaction_id=None</em>, <em>reason=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.open_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Send an order to open a trade at market price.
:param future_id, string, a SINGLE future id.
:param volume: int, the volume to order, positive number means long position,</p>
<blockquote>
<div>negative number means short position.</div></blockquote>
<p>:param order_ref, the order reference number. -1 means that the system will assign a value.
:param transaction_id: string, transaction id.
:param reason: string, reason for placing the order.
:return: int, order reference number.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.close_market_order">
<code class="descname">close_market_order</code><span class="sig-paren">(</span><em>future_id</em>, <em>volume</em>, <em>order_ref=-1</em>, <em>transaction_id=None</em>, <em>reason=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.close_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Send an order to close a trade at market price.
:param future_id, string, a SINGLE future id.
:param volume: int, the volume to order, positive number means long position,</p>
<blockquote>
<div>negative number means short position.</div></blockquote>
<p>:param order_ref, the order reference number. -1 means that the system will assign a value.
:param transaction_id: string, transaction id.
:param reason: string, reason for placing the order.
:return: int, order reference number.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.open_limit_order">
<code class="descname">open_limit_order</code><span class="sig-paren">(</span><em>future_id</em>, <em>price</em>, <em>volume</em>, <em>kind='Normal'</em>, <em>order_ref=-1</em>, <em>transaction_id=None</em>, <em>reason=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.open_limit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a limit order.
:param future_id: string, A single future id.
:param price: double, the price for the limit order.
:param volume: int, the volume for the limit order. Positive number means long position,</p>
<blockquote>
<div>negative number means short position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kind</strong> &#8211; LimitOrderKind. Normal means a normal limit order. FAK means Fill-and-kill, FOK means Fill-or-Kill.</td>
</tr>
</tbody>
</table>
<p>:param order_ref, the order reference number. -1 means that the system will assign a value.
:param transaction_id: string, transaction id.
:param reason: string, reason for placing the order.
:return: int, order reference number.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.close_limit_order">
<code class="descname">close_limit_order</code><span class="sig-paren">(</span><em>future_id</em>, <em>price</em>, <em>volume</em>, <em>kind='Normal'</em>, <em>order_ref=-1</em>, <em>transaction_id=None</em>, <em>reason=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.close_limit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a limit order.
:param future_id: string, A single future id.
:param price: double, the price for the limit order.
:param volume: int, the volume for the limit order. Positive number means long position,</p>
<blockquote>
<div>negative number means short position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kind</strong> &#8211; LimitOrderKind. Normal means a normal limit order. FAK means Fill-and-kill, FOK means Fill-or-Kill.</td>
</tr>
</tbody>
</table>
<p>:param order_ref, the order reference number. -1 means that the system will assign a value.
:param transaction_id: string, transaction id.
:param reason: string, reason for placing the order.
:return: int, order reference number.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.send_order">
<code class="descname">send_order</code><span class="sig-paren">(</span><em>order_ref</em>, <em>future_id</em>, <em>direction</em>, <em>comb_offset_flag</em>, <em>comb_hedge_flag</em>, <em>volume_total_original</em>, <em>limit_price</em>, <em>order_price_type</em>, <em>time_condition</em>, <em>contingent_condition</em>, <em>stop_price</em>, <em>volume_condition</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.send_order" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new order
:param order_ref: int, if order ref less than 0, it will auto generate an order ref
:param future_id: string, future id
:param direction: TThostFtdcDirectionType, THOST_FTDC_D_Buy or THOST_FTDC_D_Sell
:param comb_offset_flag: TThostFtdcCombOffsetFlagType
:param comb_hedge_flag: TThostFtdcCombHedgeFlagType
:param volume_total_original: TThostFtdcVolumeType
:param limit_price: double, Limit price
:param order_price_type: TThostFtdcOrderPriceTypeType
:param time_condition: TThostFtdcTimeConditionType
:param contingent_condition: TThostFtdcContingentConditionType
:param stop_price: double
:param volume_condition: TThostFtdcVolumeConditionType
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.cancel_order">
<code class="descname">cancel_order</code><span class="sig-paren">(</span><em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.cancel_order" title="Permalink to this definition">¶</a></dt>
<dd><p>cancel an order
:param order: CThostFtdcOrderField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.get_investor_position">
<code class="descname">get_investor_position</code><span class="sig-paren">(</span><em>future_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.get_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>get investor position
:param future_id: string
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.get_investor_position_detail">
<code class="descname">get_investor_position_detail</code><span class="sig-paren">(</span><em>future_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.get_investor_position_detail" title="Permalink to this definition">¶</a></dt>
<dd><p>get investor position detail
:param future_id: string
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.get_order">
<code class="descname">get_order</code><span class="sig-paren">(</span><em>future_id=''</em>, <em>exchange_id=''</em>, <em>order_sys_id=''</em>, <em>insert_time_start=''</em>, <em>insert_time_end=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.get_order" title="Permalink to this definition">¶</a></dt>
<dd><p>查询报单
:param future_id: string future id
:param exchange_id: string exchange id
:param order_sys_id: string order sys id
:param insert_time_start: string insert start time
:param insert_time_end: string insert end time
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.get_trade">
<code class="descname">get_trade</code><span class="sig-paren">(</span><em>future_id=''</em>, <em>exchange_id=''</em>, <em>trade_id=''</em>, <em>trade_time_start=''</em>, <em>trade_time_end=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.get_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>查询报单
:param future_id: string future id
:param exchange_id: string exchange id
:param trade_id: string trade id
:param trade_time_start: string trade start time
:param trade_time_end: string trade end time
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.get_trading_account">
<code class="descname">get_trading_account</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.get_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>get trading account info
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.get_instrument">
<code class="descname">get_instrument</code><span class="sig-paren">(</span><em>future_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.get_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>get future info
:param futrre_id: string
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.get_commission_rate">
<code class="descname">get_commission_rate</code><span class="sig-paren">(</span><em>future_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.get_commission_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>get future&#8217;s commission rate
:param future_id: string
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.get_margin_rate">
<code class="descname">get_margin_rate</code><span class="sig-paren">(</span><em>future_id</em>, <em>hedge_flag</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.get_margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>get future margin rate
:param future_id: string
:param hedge_flag: TThostFtdcHedgeFlagType
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.get_order_commission_rate">
<code class="descname">get_order_commission_rate</code><span class="sig-paren">(</span><em>future_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.get_order_commission_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Get open and close order commission rate.
:param future_id: string, the future id.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.get_deep_market_data">
<code class="descname">get_deep_market_data</code><span class="sig-paren">(</span><em>future_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.get_deep_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Subscribe market data for the given futures.
:param future_id: string
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.base.AbstractCtpTrading.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.base.AbstractCtpTrading.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current time stamp.
:return: datetime</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.comm"></span><dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcBrokerIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcBrokerIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcBrokerIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcInvestorIDType是一个投资者代码类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_11</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcInvestorIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcInvestorIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcInvestorIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcOrderActionRefType是一个报单操作引用类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_13</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcOrderActionRefType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcOrderActionRefType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcOrderActionRefType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcOrderRefType是一个报单引用类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcOrderRefType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcOrderRefType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcOrderRefType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcRequestIDType是一个请求编号类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_13</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcRequestIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcRequestIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcRequestIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcFrontIDType是一个前置编号类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcFrontIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcFrontIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcFrontIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcSessionIDType是一个会话编号类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcSessionIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcSessionIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcSessionIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcExchangeIDType是一个交易所代码类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcExchangeIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcExchangeIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcExchangeIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcOrderSysIDType是一个报单编号类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_9</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcOrderSysIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcOrderSysIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcOrderSysIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcActionFlagType是一个操作标志类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_21</span></code></p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_AF_Modify">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_AF_Modify</code><em class="property"> = c_char('3')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_AF_Modify" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcPriceType是一个价格类型</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcPriceType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcPriceType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcPriceType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcVolumeType是一个数量类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_double</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcVolumeType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcVolumeType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcVolumeType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcUserIDType是一个用户代码类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcUserIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcUserIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcUserIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcInstrumentIDType是一个合约代码类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_16</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcInstrumentIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcInstrumentIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcInstrumentIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcInstrumentNameType是一个合约名称类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_31</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcInstrumentNameType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcInstrumentNameType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcInstrumentNameType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcExchangeInstIDType是一个合约在交易所的代码类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_21</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcExchangeInstIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcExchangeInstIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcExchangeInstIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcProductClassType是一个产品类型类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_31</span></code></p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_PC_EFP">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_PC_EFP</code><em class="property"> = c_char('5')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_PC_EFP" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcYearType是一个年份类型</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcYearType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcYearType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcYearType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcMonthType是一个月份类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcMonthType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcMonthType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcMonthType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcVolumeMultipleType是一个合约数量乘数类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcVolumeMultipleType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcVolumeMultipleType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcVolumeMultipleType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcDateType是一个日期类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcDateType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcDateType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcDateType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcInstLifePhaseType是一个合约生命周期状态类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_9</span></code></p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_IP_Expired">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_IP_Expired</code><em class="property"> = c_char('3')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_IP_Expired" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcBoolType是一个布尔型类型</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcBoolType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcBoolType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcBoolType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcPositionDateType是一个持仓日期类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_PSD_History">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_PSD_History</code><em class="property"> = c_char('2')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_PSD_History" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcPositionTypeType是一个持仓类型类型</p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_PT_Gross">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_PT_Gross</code><em class="property"> = c_char('2')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_PT_Gross" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcPositionDateTypeType是一个持仓日期类型类型</p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_PDT_NoUseHistory">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_PDT_NoUseHistory</code><em class="property"> = c_char('2')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_PDT_NoUseHistory" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcRatioType是一个比率类型</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcRatioType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcRatioType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcRatioType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcMaxMarginSideAlgorithmType是一个大额单边保证金算法类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_double</span></code></p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_MMSA_YES">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_MMSA_YES</code><em class="property"> = c_char('1')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_MMSA_YES" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcOptionsTypeType是一个期权类型类型</p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_IR_Single">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_IR_Single</code><em class="property"> = c_char('3')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_IR_Single" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcHedgeFlagType是一个投机套保标志类型</p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_HF_Hedge">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_HF_Hedge</code><em class="property"> = c_char('3')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_HF_Hedge" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcMoneyType是一个资金类型</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcMoneyType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcMoneyType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcMoneyType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcPosiDirectionType是一个持仓多空方向类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_double</span></code></p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_PD_Short">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_PD_Short</code><em class="property"> = c_char('3')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_PD_Short" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcSettlementIDType是一个结算编号类型</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcSettlementIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcSettlementIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcSettlementIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcDirectionType是一个买卖方向类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_D_Sell">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_D_Sell</code><em class="property"> = c_char('1')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_D_Sell" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcTradeIDType是一个成交编号类型</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcTradeIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcTradeIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcTradeIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcTradeTypeType是一个成交类型类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_21</span></code></p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_TRDT_CombinationDerived">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_TRDT_CombinationDerived</code><em class="property"> = c_char('4')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_TRDT_CombinationDerived" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcOrderPriceTypeType是一个报单价格条件类型</p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_OPT_BidPrice1PlusThreeTicks">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_OPT_BidPrice1PlusThreeTicks</code><em class="property"> = c_char('F')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_OPT_BidPrice1PlusThreeTicks" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcCombOffsetFlagType是一个组合开平标志类型</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcCombOffsetFlagType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcCombOffsetFlagType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcCombOffsetFlagType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcCombHedgeFlagType是一个组合投机套保标志类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_5</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcCombHedgeFlagType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcCombHedgeFlagType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcCombHedgeFlagType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcTimeConditionType是一个有效期类型类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_5</span></code></p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_TC_GFA">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_TC_GFA</code><em class="property"> = c_char('6')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_TC_GFA" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcVolumeConditionType是一个成交量类型类型</p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_VC_CV">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_VC_CV</code><em class="property"> = c_char('3')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_VC_CV" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcContingentConditionType是一个触发条件类型</p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_CC_BidPriceLesserEqualStopPrice">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_CC_BidPriceLesserEqualStopPrice</code><em class="property"> = c_char('H')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_CC_BidPriceLesserEqualStopPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcForceCloseReasonType是一个强平原因类型</p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_FCC_PersonDeliv">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_FCC_PersonDeliv</code><em class="property"> = c_char('7')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_FCC_PersonDeliv" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcBusinessUnitType是一个业务单元类型</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcBusinessUnitType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcBusinessUnitType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcBusinessUnitType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcOrderLocalIDType是一个本地报单编号类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_21</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcOrderLocalIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcOrderLocalIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcOrderLocalIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcParticipantIDType是一个会员代码类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_13</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcParticipantIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcParticipantIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcParticipantIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcClientIDType是一个交易编码类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_11</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcClientIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcClientIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcClientIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcTraderIDType是一个交易所交易员代码类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_11</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcTraderIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcTraderIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcTraderIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcInstallIDType是一个安装编号类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_21</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcInstallIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcInstallIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcInstallIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcOrderSubmitStatusType是一个报单提交状态类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_OSS_ModifyRejected">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_OSS_ModifyRejected</code><em class="property"> = c_char('6')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_OSS_ModifyRejected" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcSequenceNoType是一个序号类型</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcSequenceNoType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcSequenceNoType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcSequenceNoType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcOrderSourceType是一个报单来源类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_OSRC_Administrator">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_OSRC_Administrator</code><em class="property"> = c_char('1')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_OSRC_Administrator" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcOrderStatusType是一个报单状态类型</p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_OST_Touched">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_OST_Touched</code><em class="property"> = c_char('c')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_OST_Touched" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcOrderTypeType是一个报单类型类型</p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_ORDT_Swap">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_ORDT_Swap</code><em class="property"> = c_char('5')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_ORDT_Swap" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcTimeType是一个时间类型</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcTimeType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcTimeType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcTimeType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcProductInfoType是一个产品信息类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_9</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcProductInfoType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcProductInfoType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcProductInfoType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcErrorMsgType是一个错误信息类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_11</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcErrorMsgType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcErrorMsgType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcErrorMsgType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcTradingRoleType是一个交易角色类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_81</span></code></p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_ER_Maker">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_ER_Maker</code><em class="property"> = c_char('3')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_ER_Maker" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcOffsetFlagType是一个开平标志类型</p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_OF_LocalForceClose">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_OF_LocalForceClose</code><em class="property"> = c_char('6')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_OF_LocalForceClose" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcPriceSourceType是一个成交价来源类型</p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_PSRC_Sell">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_PSRC_Sell</code><em class="property"> = c_char('2')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_PSRC_Sell" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcTradeSourceType是一个成交来源类型</p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_TSRC_QUERY">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_TSRC_QUERY</code><em class="property"> = c_char('1')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_TSRC_QUERY" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcAccountIDType是一个投资者帐号类型</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcAccountIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcAccountIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcAccountIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcCurrencyIDType是一个币种代码类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_13</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcCurrencyIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcCurrencyIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcCurrencyIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcSettlementGroupIDType是一个结算组代码类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_4</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcSettlementGroupIDType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcSettlementGroupIDType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcSettlementGroupIDType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcInstrumentStatusType是一个合约交易状态类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_char_Array_9</span></code></p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_IS_Closed">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_IS_Closed</code><em class="property"> = c_char('6')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_IS_Closed" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcTradingSegmentSNType是一个交易阶段编号类型</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.TThostFtdcTradingSegmentSNType">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">TThostFtdcTradingSegmentSNType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.TThostFtdcTradingSegmentSNType" title="Permalink to this definition">¶</a></dt>
<dd><p>TFtdcInstStatusEnterReasonType是一个品种进入交易状态原因类型</p>
<p>alias of <code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_FTDC_IER_Fuse">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_FTDC_IER_Fuse</code><em class="property"> = c_char('3')</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_FTDC_IER_Fuse" title="Permalink to this definition">¶</a></dt>
<dd><p>THOST_TE_RESUME_TYPE为枚举类型</p>
</dd></dl>

<dl class="data">
<dt id="ctxalgoctp.ctp.comm.THOST_TERT_QUICK">
<code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">THOST_TERT_QUICK</code><em class="property"> = c_int(2)</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.THOST_TERT_QUICK" title="Permalink to this definition">¶</a></dt>
<dd><p>连接状态枚举</p>
</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">CThostFtdcRspUserLoginField</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">_ctypes.Structure</span></code></p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.BrokerID">
<code class="descname">BrokerID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.BrokerID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.CZCETime">
<code class="descname">CZCETime</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.CZCETime" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.DCETime">
<code class="descname">DCETime</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.DCETime" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.FFEXTime">
<code class="descname">FFEXTime</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.FFEXTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.FrontID">
<code class="descname">FrontID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.FrontID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.INETime">
<code class="descname">INETime</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.INETime" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.LoginTime">
<code class="descname">LoginTime</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.LoginTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.MaxOrderRef">
<code class="descname">MaxOrderRef</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.MaxOrderRef" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.SHFETime">
<code class="descname">SHFETime</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.SHFETime" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.SessionID">
<code class="descname">SessionID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.SessionID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.SystemName">
<code class="descname">SystemName</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.SystemName" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.TradingDay">
<code class="descname">TradingDay</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.TradingDay" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.UserID">
<code class="descname">UserID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcRspUserLoginField.UserID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcRspInfoField">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">CThostFtdcRspInfoField</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcRspInfoField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">_ctypes.Structure</span></code></p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcRspInfoField.ErrorID">
<code class="descname">ErrorID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcRspInfoField.ErrorID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcRspInfoField.ErrorMsg">
<code class="descname">ErrorMsg</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcRspInfoField.ErrorMsg" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">CThostFtdcOrderActionField</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">_ctypes.Structure</span></code></p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.ActionDate">
<code class="descname">ActionDate</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.ActionDate" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.ActionFlag">
<code class="descname">ActionFlag</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.ActionFlag" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.ActionLocalID">
<code class="descname">ActionLocalID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.ActionLocalID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.ActionTime">
<code class="descname">ActionTime</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.ActionTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.BrokerID">
<code class="descname">BrokerID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.BrokerID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.BusinessUnit">
<code class="descname">BusinessUnit</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.BusinessUnit" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.ClientID">
<code class="descname">ClientID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.ClientID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.ExchangeID">
<code class="descname">ExchangeID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.ExchangeID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.FrontID">
<code class="descname">FrontID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.FrontID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.InstallID">
<code class="descname">InstallID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.InstallID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.InstrumentID">
<code class="descname">InstrumentID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.InstrumentID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.InvestorID">
<code class="descname">InvestorID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.InvestorID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.LimitPrice">
<code class="descname">LimitPrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.LimitPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.OrderActionRef">
<code class="descname">OrderActionRef</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.OrderActionRef" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.OrderActionStatus">
<code class="descname">OrderActionStatus</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.OrderActionStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.OrderLocalID">
<code class="descname">OrderLocalID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.OrderLocalID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.OrderRef">
<code class="descname">OrderRef</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.OrderRef" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.OrderSysID">
<code class="descname">OrderSysID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.OrderSysID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.ParticipantID">
<code class="descname">ParticipantID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.ParticipantID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.RequestID">
<code class="descname">RequestID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.RequestID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.SessionID">
<code class="descname">SessionID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.SessionID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.StatusMsg">
<code class="descname">StatusMsg</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.StatusMsg" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.TraderID">
<code class="descname">TraderID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.TraderID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.UserID">
<code class="descname">UserID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.UserID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.VolumeChange">
<code class="descname">VolumeChange</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderActionField.VolumeChange" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">CThostFtdcInputOrderField</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">_ctypes.Structure</span></code></p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.BrokerID">
<code class="descname">BrokerID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.BrokerID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.BusinessUnit">
<code class="descname">BusinessUnit</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.BusinessUnit" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.CombHedgeFlag">
<code class="descname">CombHedgeFlag</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.CombHedgeFlag" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.CombOffsetFlag">
<code class="descname">CombOffsetFlag</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.CombOffsetFlag" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.ContingentCondition">
<code class="descname">ContingentCondition</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.ContingentCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.Direction">
<code class="descname">Direction</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.Direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.ForceCloseReason">
<code class="descname">ForceCloseReason</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.ForceCloseReason" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.InstrumentID">
<code class="descname">InstrumentID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.InstrumentID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.InvestorID">
<code class="descname">InvestorID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.InvestorID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.IsAutoSuspend">
<code class="descname">IsAutoSuspend</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.IsAutoSuspend" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.IsSwapOrder">
<code class="descname">IsSwapOrder</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.IsSwapOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.LimitPrice">
<code class="descname">LimitPrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.LimitPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.MinVolume">
<code class="descname">MinVolume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.MinVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.OrderPriceType">
<code class="descname">OrderPriceType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.OrderPriceType" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.OrderRef">
<code class="descname">OrderRef</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.OrderRef" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.RequestID">
<code class="descname">RequestID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.RequestID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.StopPrice">
<code class="descname">StopPrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.StopPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.TimeCondition">
<code class="descname">TimeCondition</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.TimeCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.UserForceClose">
<code class="descname">UserForceClose</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.UserForceClose" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.UserID">
<code class="descname">UserID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.UserID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.VolumeCondition">
<code class="descname">VolumeCondition</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.VolumeCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.VolumeTotalOriginal">
<code class="descname">VolumeTotalOriginal</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderField.VolumeTotalOriginal" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">CThostFtdcInputOrderActionField</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">_ctypes.Structure</span></code></p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.ActionFlag">
<code class="descname">ActionFlag</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.ActionFlag" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.BrokerID">
<code class="descname">BrokerID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.BrokerID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.ExchangeID">
<code class="descname">ExchangeID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.ExchangeID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.FrontID">
<code class="descname">FrontID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.FrontID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.InstrumentID">
<code class="descname">InstrumentID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.InstrumentID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.InvestorID">
<code class="descname">InvestorID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.InvestorID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.LimitPrice">
<code class="descname">LimitPrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.LimitPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.OrderActionRef">
<code class="descname">OrderActionRef</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.OrderActionRef" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.OrderRef">
<code class="descname">OrderRef</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.OrderRef" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.OrderSysID">
<code class="descname">OrderSysID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.OrderSysID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.RequestID">
<code class="descname">RequestID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.RequestID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.SessionID">
<code class="descname">SessionID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.SessionID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.UserID">
<code class="descname">UserID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.UserID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.VolumeChange">
<code class="descname">VolumeChange</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInputOrderActionField.VolumeChange" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">CThostFtdcDepthMarketDataField</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">_ctypes.Structure</span></code></p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.ActionDay">
<code class="descname">ActionDay</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.ActionDay" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskPrice1">
<code class="descname">AskPrice1</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskPrice1" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskPrice2">
<code class="descname">AskPrice2</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskPrice2" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskPrice3">
<code class="descname">AskPrice3</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskPrice3" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskPrice4">
<code class="descname">AskPrice4</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskPrice4" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskPrice5">
<code class="descname">AskPrice5</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskPrice5" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskVolume1">
<code class="descname">AskVolume1</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskVolume1" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskVolume2">
<code class="descname">AskVolume2</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskVolume2" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskVolume3">
<code class="descname">AskVolume3</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskVolume3" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskVolume4">
<code class="descname">AskVolume4</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskVolume4" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskVolume5">
<code class="descname">AskVolume5</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AskVolume5" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AveragePrice">
<code class="descname">AveragePrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.AveragePrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidPrice1">
<code class="descname">BidPrice1</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidPrice1" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidPrice2">
<code class="descname">BidPrice2</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidPrice2" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidPrice3">
<code class="descname">BidPrice3</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidPrice3" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidPrice4">
<code class="descname">BidPrice4</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidPrice4" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidPrice5">
<code class="descname">BidPrice5</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidPrice5" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidVolume1">
<code class="descname">BidVolume1</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidVolume1" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidVolume2">
<code class="descname">BidVolume2</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidVolume2" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidVolume3">
<code class="descname">BidVolume3</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidVolume3" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidVolume4">
<code class="descname">BidVolume4</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidVolume4" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidVolume5">
<code class="descname">BidVolume5</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.BidVolume5" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.ClosePrice">
<code class="descname">ClosePrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.ClosePrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.CurrDelta">
<code class="descname">CurrDelta</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.CurrDelta" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.ExchangeID">
<code class="descname">ExchangeID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.ExchangeID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.ExchangeInstID">
<code class="descname">ExchangeInstID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.ExchangeInstID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.HighestPrice">
<code class="descname">HighestPrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.HighestPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.InstrumentID">
<code class="descname">InstrumentID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.InstrumentID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.LastPrice">
<code class="descname">LastPrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.LastPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.LowerLimitPrice">
<code class="descname">LowerLimitPrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.LowerLimitPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.LowestPrice">
<code class="descname">LowestPrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.LowestPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.OpenInterest">
<code class="descname">OpenInterest</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.OpenInterest" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.OpenPrice">
<code class="descname">OpenPrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.OpenPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.PreClosePrice">
<code class="descname">PreClosePrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.PreClosePrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.PreDelta">
<code class="descname">PreDelta</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.PreDelta" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.PreOpenInterest">
<code class="descname">PreOpenInterest</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.PreOpenInterest" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.PreSettlementPrice">
<code class="descname">PreSettlementPrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.PreSettlementPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.SettlementPrice">
<code class="descname">SettlementPrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.SettlementPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.TradingDay">
<code class="descname">TradingDay</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.TradingDay" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.Turnover">
<code class="descname">Turnover</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.Turnover" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.UpdateMillisec">
<code class="descname">UpdateMillisec</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.UpdateMillisec" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.UpdateTime">
<code class="descname">UpdateTime</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.UpdateTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.UpperLimitPrice">
<code class="descname">UpperLimitPrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.UpperLimitPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.Volume">
<code class="descname">Volume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcDepthMarketDataField.Volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">CThostFtdcInstrumentField</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">_ctypes.Structure</span></code></p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.CreateDate">
<code class="descname">CreateDate</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.CreateDate" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.DeliveryMonth">
<code class="descname">DeliveryMonth</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.DeliveryMonth" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.DeliveryYear">
<code class="descname">DeliveryYear</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.DeliveryYear" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.EndDelivDate">
<code class="descname">EndDelivDate</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.EndDelivDate" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.ExchangeID">
<code class="descname">ExchangeID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.ExchangeID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.ExchangeInstID">
<code class="descname">ExchangeInstID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.ExchangeInstID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.ExpireDate">
<code class="descname">ExpireDate</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.ExpireDate" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.InstLifePhase">
<code class="descname">InstLifePhase</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.InstLifePhase" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.InstrumentID">
<code class="descname">InstrumentID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.InstrumentID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.InstrumentName">
<code class="descname">InstrumentName</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.InstrumentName" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.IsTrading">
<code class="descname">IsTrading</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.IsTrading" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.LongMarginRatio">
<code class="descname">LongMarginRatio</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.LongMarginRatio" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.MaxLimitOrderVolume">
<code class="descname">MaxLimitOrderVolume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.MaxLimitOrderVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.MaxMarginSideAlgorithm">
<code class="descname">MaxMarginSideAlgorithm</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.MaxMarginSideAlgorithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.MaxMarketOrderVolume">
<code class="descname">MaxMarketOrderVolume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.MaxMarketOrderVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.MinLimitOrderVolume">
<code class="descname">MinLimitOrderVolume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.MinLimitOrderVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.MinMarketOrderVolume">
<code class="descname">MinMarketOrderVolume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.MinMarketOrderVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.OpenDate">
<code class="descname">OpenDate</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.OpenDate" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.PositionDateType">
<code class="descname">PositionDateType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.PositionDateType" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.PositionType">
<code class="descname">PositionType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.PositionType" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.PriceTick">
<code class="descname">PriceTick</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.PriceTick" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.ProductClass">
<code class="descname">ProductClass</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.ProductClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.ProductID">
<code class="descname">ProductID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.ProductID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.ShortMarginRatio">
<code class="descname">ShortMarginRatio</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.ShortMarginRatio" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.StartDelivDate">
<code class="descname">StartDelivDate</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.StartDelivDate" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.VolumeMultiple">
<code class="descname">VolumeMultiple</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentField.VolumeMultiple" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">CThostFtdcInstrumentCommissionRateField</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">_ctypes.Structure</span></code></p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.BrokerID">
<code class="descname">BrokerID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.BrokerID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.CloseRatioByMoney">
<code class="descname">CloseRatioByMoney</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.CloseRatioByMoney" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.CloseRatioByVolume">
<code class="descname">CloseRatioByVolume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.CloseRatioByVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.CloseTodayRatioByMoney">
<code class="descname">CloseTodayRatioByMoney</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.CloseTodayRatioByMoney" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.CloseTodayRatioByVolume">
<code class="descname">CloseTodayRatioByVolume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.CloseTodayRatioByVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.InstrumentID">
<code class="descname">InstrumentID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.InstrumentID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.InvestorID">
<code class="descname">InvestorID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.InvestorID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.InvestorRange">
<code class="descname">InvestorRange</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.InvestorRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.OpenRatioByMoney">
<code class="descname">OpenRatioByMoney</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.OpenRatioByMoney" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.OpenRatioByVolume">
<code class="descname">OpenRatioByVolume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentCommissionRateField.OpenRatioByVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">CThostFtdcInstrumentMarginRateField</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">_ctypes.Structure</span></code></p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.BrokerID">
<code class="descname">BrokerID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.BrokerID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.HedgeFlag">
<code class="descname">HedgeFlag</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.HedgeFlag" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.InstrumentID">
<code class="descname">InstrumentID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.InstrumentID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.InvestorID">
<code class="descname">InvestorID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.InvestorID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.InvestorRange">
<code class="descname">InvestorRange</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.InvestorRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.IsRelative">
<code class="descname">IsRelative</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.IsRelative" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.LongMarginRatioByMoney">
<code class="descname">LongMarginRatioByMoney</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.LongMarginRatioByMoney" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.LongMarginRatioByVolume">
<code class="descname">LongMarginRatioByVolume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.LongMarginRatioByVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.ShortMarginRatioByMoney">
<code class="descname">ShortMarginRatioByMoney</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.ShortMarginRatioByMoney" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.ShortMarginRatioByVolume">
<code class="descname">ShortMarginRatioByVolume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentMarginRateField.ShortMarginRatioByVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentOrderCommRateField">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">CThostFtdcInstrumentOrderCommRateField</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentOrderCommRateField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">_ctypes.Structure</span></code></p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentOrderCommRateField.BrokerID">
<code class="descname">BrokerID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentOrderCommRateField.BrokerID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentOrderCommRateField.HedgeFlag">
<code class="descname">HedgeFlag</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentOrderCommRateField.HedgeFlag" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentOrderCommRateField.InstrumentID">
<code class="descname">InstrumentID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentOrderCommRateField.InstrumentID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentOrderCommRateField.InvestorID">
<code class="descname">InvestorID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentOrderCommRateField.InvestorID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentOrderCommRateField.InvestorRange">
<code class="descname">InvestorRange</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentOrderCommRateField.InvestorRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentOrderCommRateField.OrderActionCommByVolume">
<code class="descname">OrderActionCommByVolume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentOrderCommRateField.OrderActionCommByVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentOrderCommRateField.OrderCommByVolume">
<code class="descname">OrderCommByVolume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentOrderCommRateField.OrderCommByVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">CThostFtdcInvestorPositionField</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">_ctypes.Structure</span></code></p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.BrokerID">
<code class="descname">BrokerID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.BrokerID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.CashIn">
<code class="descname">CashIn</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.CashIn" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.CloseAmount">
<code class="descname">CloseAmount</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.CloseAmount" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.CloseProfit">
<code class="descname">CloseProfit</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.CloseProfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.CloseProfitByDate">
<code class="descname">CloseProfitByDate</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.CloseProfitByDate" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.CloseProfitByTrade">
<code class="descname">CloseProfitByTrade</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.CloseProfitByTrade" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.CloseVolume">
<code class="descname">CloseVolume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.CloseVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.CombLongFrozen">
<code class="descname">CombLongFrozen</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.CombLongFrozen" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.CombPosition">
<code class="descname">CombPosition</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.CombPosition" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.CombShortFrozen">
<code class="descname">CombShortFrozen</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.CombShortFrozen" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.Commission">
<code class="descname">Commission</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.Commission" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.ExchangeMargin">
<code class="descname">ExchangeMargin</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.ExchangeMargin" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.FrozenCash">
<code class="descname">FrozenCash</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.FrozenCash" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.FrozenCommission">
<code class="descname">FrozenCommission</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.FrozenCommission" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.FrozenMargin">
<code class="descname">FrozenMargin</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.FrozenMargin" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.HedgeFlag">
<code class="descname">HedgeFlag</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.HedgeFlag" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.InstrumentID">
<code class="descname">InstrumentID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.InstrumentID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.InvestorID">
<code class="descname">InvestorID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.InvestorID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.LongFrozen">
<code class="descname">LongFrozen</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.LongFrozen" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.LongFrozenAmount">
<code class="descname">LongFrozenAmount</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.LongFrozenAmount" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.MarginRateByMoney">
<code class="descname">MarginRateByMoney</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.MarginRateByMoney" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.MarginRateByVolume">
<code class="descname">MarginRateByVolume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.MarginRateByVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.OpenAmount">
<code class="descname">OpenAmount</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.OpenAmount" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.OpenCost">
<code class="descname">OpenCost</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.OpenCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.OpenVolume">
<code class="descname">OpenVolume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.OpenVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.PosiDirection">
<code class="descname">PosiDirection</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.PosiDirection" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.Position">
<code class="descname">Position</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.Position" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.PositionCost">
<code class="descname">PositionCost</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.PositionCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.PositionDate">
<code class="descname">PositionDate</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.PositionDate" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.PositionProfit">
<code class="descname">PositionProfit</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.PositionProfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.PreMargin">
<code class="descname">PreMargin</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.PreMargin" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.PreSettlementPrice">
<code class="descname">PreSettlementPrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.PreSettlementPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.SettlementID">
<code class="descname">SettlementID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.SettlementID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.SettlementPrice">
<code class="descname">SettlementPrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.SettlementPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.ShortFrozen">
<code class="descname">ShortFrozen</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.ShortFrozen" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.ShortFrozenAmount">
<code class="descname">ShortFrozenAmount</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.ShortFrozenAmount" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.TodayPosition">
<code class="descname">TodayPosition</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.TodayPosition" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.TradingDay">
<code class="descname">TradingDay</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.TradingDay" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.UseMargin">
<code class="descname">UseMargin</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.UseMargin" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.YdPosition">
<code class="descname">YdPosition</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionField.YdPosition" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">CThostFtdcInvestorPositionDetailField</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">_ctypes.Structure</span></code></p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.BrokerID">
<code class="descname">BrokerID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.BrokerID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.CloseAmount">
<code class="descname">CloseAmount</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.CloseAmount" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.CloseProfitByDate">
<code class="descname">CloseProfitByDate</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.CloseProfitByDate" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.CloseProfitByTrade">
<code class="descname">CloseProfitByTrade</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.CloseProfitByTrade" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.CloseVolume">
<code class="descname">CloseVolume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.CloseVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.CombInstrumentID">
<code class="descname">CombInstrumentID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.CombInstrumentID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.Direction">
<code class="descname">Direction</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.Direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.ExchMargin">
<code class="descname">ExchMargin</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.ExchMargin" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.ExchangeID">
<code class="descname">ExchangeID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.ExchangeID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.HedgeFlag">
<code class="descname">HedgeFlag</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.HedgeFlag" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.InstrumentID">
<code class="descname">InstrumentID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.InstrumentID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.InvestorID">
<code class="descname">InvestorID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.InvestorID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.LastSettlementPrice">
<code class="descname">LastSettlementPrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.LastSettlementPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.Margin">
<code class="descname">Margin</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.Margin" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.MarginRateByMoney">
<code class="descname">MarginRateByMoney</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.MarginRateByMoney" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.MarginRateByVolume">
<code class="descname">MarginRateByVolume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.MarginRateByVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.OpenDate">
<code class="descname">OpenDate</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.OpenDate" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.OpenPrice">
<code class="descname">OpenPrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.OpenPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.PositionProfitByDate">
<code class="descname">PositionProfitByDate</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.PositionProfitByDate" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.PositionProfitByTrade">
<code class="descname">PositionProfitByTrade</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.PositionProfitByTrade" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.SettlementID">
<code class="descname">SettlementID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.SettlementID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.SettlementPrice">
<code class="descname">SettlementPrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.SettlementPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.TradeID">
<code class="descname">TradeID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.TradeID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.TradeType">
<code class="descname">TradeType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.TradeType" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.TradingDay">
<code class="descname">TradingDay</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.TradingDay" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.Volume">
<code class="descname">Volume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInvestorPositionDetailField.Volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">CThostFtdcOrderField</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">_ctypes.Structure</span></code></p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.ActiveTime">
<code class="descname">ActiveTime</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.ActiveTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.ActiveTraderID">
<code class="descname">ActiveTraderID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.ActiveTraderID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.ActiveUserID">
<code class="descname">ActiveUserID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.ActiveUserID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.BrokerID">
<code class="descname">BrokerID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.BrokerID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.BrokerOrderSeq">
<code class="descname">BrokerOrderSeq</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.BrokerOrderSeq" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.BusinessUnit">
<code class="descname">BusinessUnit</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.BusinessUnit" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.CancelTime">
<code class="descname">CancelTime</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.CancelTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.ClearingPartID">
<code class="descname">ClearingPartID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.ClearingPartID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.ClientID">
<code class="descname">ClientID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.ClientID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.CombHedgeFlag">
<code class="descname">CombHedgeFlag</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.CombHedgeFlag" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.CombOffsetFlag">
<code class="descname">CombOffsetFlag</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.CombOffsetFlag" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.ContingentCondition">
<code class="descname">ContingentCondition</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.ContingentCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.Direction">
<code class="descname">Direction</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.Direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.ExchangeID">
<code class="descname">ExchangeID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.ExchangeID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.ExchangeInstID">
<code class="descname">ExchangeInstID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.ExchangeInstID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.ForceCloseReason">
<code class="descname">ForceCloseReason</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.ForceCloseReason" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.FrontID">
<code class="descname">FrontID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.FrontID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.GTDDate">
<code class="descname">GTDDate</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.GTDDate" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.InsertDate">
<code class="descname">InsertDate</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.InsertDate" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.InsertTime">
<code class="descname">InsertTime</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.InsertTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.InstallID">
<code class="descname">InstallID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.InstallID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.InstrumentID">
<code class="descname">InstrumentID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.InstrumentID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.InvestorID">
<code class="descname">InvestorID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.InvestorID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.IsAutoSuspend">
<code class="descname">IsAutoSuspend</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.IsAutoSuspend" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.IsSwapOrder">
<code class="descname">IsSwapOrder</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.IsSwapOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.LimitPrice">
<code class="descname">LimitPrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.LimitPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.MinVolume">
<code class="descname">MinVolume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.MinVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.NotifySequence">
<code class="descname">NotifySequence</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.NotifySequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.OrderLocalID">
<code class="descname">OrderLocalID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.OrderLocalID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.OrderPriceType">
<code class="descname">OrderPriceType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.OrderPriceType" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.OrderRef">
<code class="descname">OrderRef</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.OrderRef" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.OrderSource">
<code class="descname">OrderSource</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.OrderSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.OrderStatus">
<code class="descname">OrderStatus</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.OrderStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.OrderSubmitStatus">
<code class="descname">OrderSubmitStatus</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.OrderSubmitStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.OrderSysID">
<code class="descname">OrderSysID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.OrderSysID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.OrderType">
<code class="descname">OrderType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.OrderType" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.ParticipantID">
<code class="descname">ParticipantID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.ParticipantID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.RelativeOrderSysID">
<code class="descname">RelativeOrderSysID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.RelativeOrderSysID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.RequestID">
<code class="descname">RequestID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.RequestID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.SequenceNo">
<code class="descname">SequenceNo</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.SequenceNo" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.SessionID">
<code class="descname">SessionID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.SessionID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.SettlementID">
<code class="descname">SettlementID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.SettlementID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.StatusMsg">
<code class="descname">StatusMsg</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.StatusMsg" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.StopPrice">
<code class="descname">StopPrice</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.StopPrice" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.SuspendTime">
<code class="descname">SuspendTime</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.SuspendTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.TimeCondition">
<code class="descname">TimeCondition</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.TimeCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.TraderID">
<code class="descname">TraderID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.TraderID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.TradingDay">
<code class="descname">TradingDay</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.TradingDay" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.UpdateTime">
<code class="descname">UpdateTime</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.UpdateTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.UserForceClose">
<code class="descname">UserForceClose</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.UserForceClose" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.UserID">
<code class="descname">UserID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.UserID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.UserProductInfo">
<code class="descname">UserProductInfo</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.UserProductInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.VolumeCondition">
<code class="descname">VolumeCondition</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.VolumeCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.VolumeTotal">
<code class="descname">VolumeTotal</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.VolumeTotal" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.VolumeTotalOriginal">
<code class="descname">VolumeTotalOriginal</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.VolumeTotalOriginal" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.VolumeTraded">
<code class="descname">VolumeTraded</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.VolumeTraded" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcOrderField.ZCETotalTradedVolume">
<code class="descname">ZCETotalTradedVolume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcOrderField.ZCETotalTradedVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">CThostFtdcTradeField</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">_ctypes.Structure</span></code></p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.BrokerID">
<code class="descname">BrokerID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.BrokerID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.BrokerOrderSeq">
<code class="descname">BrokerOrderSeq</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.BrokerOrderSeq" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.BusinessUnit">
<code class="descname">BusinessUnit</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.BusinessUnit" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.ClearingPartID">
<code class="descname">ClearingPartID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.ClearingPartID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.ClientID">
<code class="descname">ClientID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.ClientID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.Direction">
<code class="descname">Direction</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.Direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.ExchangeID">
<code class="descname">ExchangeID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.ExchangeID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.ExchangeInstID">
<code class="descname">ExchangeInstID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.ExchangeInstID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.HedgeFlag">
<code class="descname">HedgeFlag</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.HedgeFlag" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.InstrumentID">
<code class="descname">InstrumentID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.InstrumentID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.InvestorID">
<code class="descname">InvestorID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.InvestorID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.OffsetFlag">
<code class="descname">OffsetFlag</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.OffsetFlag" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.OrderLocalID">
<code class="descname">OrderLocalID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.OrderLocalID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.OrderRef">
<code class="descname">OrderRef</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.OrderRef" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.OrderSysID">
<code class="descname">OrderSysID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.OrderSysID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.ParticipantID">
<code class="descname">ParticipantID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.ParticipantID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.Price">
<code class="descname">Price</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.Price" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.PriceSource">
<code class="descname">PriceSource</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.PriceSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.SequenceNo">
<code class="descname">SequenceNo</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.SequenceNo" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.SettlementID">
<code class="descname">SettlementID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.SettlementID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.TradeDate">
<code class="descname">TradeDate</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.TradeDate" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.TradeID">
<code class="descname">TradeID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.TradeID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.TradeSource">
<code class="descname">TradeSource</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.TradeSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.TradeTime">
<code class="descname">TradeTime</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.TradeTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.TradeType">
<code class="descname">TradeType</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.TradeType" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.TraderID">
<code class="descname">TraderID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.TraderID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.TradingDay">
<code class="descname">TradingDay</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.TradingDay" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.TradingRole">
<code class="descname">TradingRole</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.TradingRole" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.UserID">
<code class="descname">UserID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.UserID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradeField.Volume">
<code class="descname">Volume</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradeField.Volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">CThostFtdcTradingAccountField</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">_ctypes.Structure</span></code></p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.AccountID">
<code class="descname">AccountID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.AccountID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.Available">
<code class="descname">Available</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.Available" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.Balance">
<code class="descname">Balance</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.Balance" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.BrokerID">
<code class="descname">BrokerID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.BrokerID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.CashIn">
<code class="descname">CashIn</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.CashIn" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.CloseProfit">
<code class="descname">CloseProfit</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.CloseProfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.Commission">
<code class="descname">Commission</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.Commission" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.Credit">
<code class="descname">Credit</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.Credit" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.CurrMargin">
<code class="descname">CurrMargin</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.CurrMargin" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.CurrencyID">
<code class="descname">CurrencyID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.CurrencyID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.DeliveryMargin">
<code class="descname">DeliveryMargin</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.DeliveryMargin" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.Deposit">
<code class="descname">Deposit</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.Deposit" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.ExchangeDeliveryMargin">
<code class="descname">ExchangeDeliveryMargin</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.ExchangeDeliveryMargin" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.ExchangeMargin">
<code class="descname">ExchangeMargin</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.ExchangeMargin" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.FrozenCash">
<code class="descname">FrozenCash</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.FrozenCash" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.FrozenCommission">
<code class="descname">FrozenCommission</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.FrozenCommission" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.FrozenMargin">
<code class="descname">FrozenMargin</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.FrozenMargin" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.FundMortgageAvailable">
<code class="descname">FundMortgageAvailable</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.FundMortgageAvailable" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.FundMortgageIn">
<code class="descname">FundMortgageIn</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.FundMortgageIn" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.FundMortgageOut">
<code class="descname">FundMortgageOut</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.FundMortgageOut" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.Interest">
<code class="descname">Interest</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.Interest" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.InterestBase">
<code class="descname">InterestBase</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.InterestBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.Mortgage">
<code class="descname">Mortgage</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.Mortgage" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.MortgageableFund">
<code class="descname">MortgageableFund</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.MortgageableFund" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.OptionCloseProfit">
<code class="descname">OptionCloseProfit</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.OptionCloseProfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.OptionValue">
<code class="descname">OptionValue</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.OptionValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.PositionProfit">
<code class="descname">PositionProfit</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.PositionProfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.PreBalance">
<code class="descname">PreBalance</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.PreBalance" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.PreCredit">
<code class="descname">PreCredit</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.PreCredit" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.PreDeposit">
<code class="descname">PreDeposit</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.PreDeposit" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.PreFundMortgageIn">
<code class="descname">PreFundMortgageIn</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.PreFundMortgageIn" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.PreFundMortgageOut">
<code class="descname">PreFundMortgageOut</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.PreFundMortgageOut" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.PreMargin">
<code class="descname">PreMargin</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.PreMargin" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.PreMortgage">
<code class="descname">PreMortgage</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.PreMortgage" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.Reserve">
<code class="descname">Reserve</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.Reserve" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.ReserveBalance">
<code class="descname">ReserveBalance</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.ReserveBalance" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.SettlementID">
<code class="descname">SettlementID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.SettlementID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.SpecProductCloseProfit">
<code class="descname">SpecProductCloseProfit</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.SpecProductCloseProfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.SpecProductCommission">
<code class="descname">SpecProductCommission</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.SpecProductCommission" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.SpecProductExchangeMargin">
<code class="descname">SpecProductExchangeMargin</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.SpecProductExchangeMargin" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.SpecProductFrozenCommission">
<code class="descname">SpecProductFrozenCommission</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.SpecProductFrozenCommission" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.SpecProductFrozenMargin">
<code class="descname">SpecProductFrozenMargin</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.SpecProductFrozenMargin" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.SpecProductMargin">
<code class="descname">SpecProductMargin</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.SpecProductMargin" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.SpecProductPositionProfit">
<code class="descname">SpecProductPositionProfit</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.SpecProductPositionProfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.SpecProductPositionProfitByAlg">
<code class="descname">SpecProductPositionProfitByAlg</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.SpecProductPositionProfitByAlg" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.TradingDay">
<code class="descname">TradingDay</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.TradingDay" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.Withdraw">
<code class="descname">Withdraw</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.Withdraw" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.WithdrawQuota">
<code class="descname">WithdrawQuota</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcTradingAccountField.WithdrawQuota" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentStatusField">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">CThostFtdcInstrumentStatusField</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentStatusField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">_ctypes.Structure</span></code></p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentStatusField.EnterReason">
<code class="descname">EnterReason</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentStatusField.EnterReason" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentStatusField.EnterTime">
<code class="descname">EnterTime</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentStatusField.EnterTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentStatusField.ExchangeID">
<code class="descname">ExchangeID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentStatusField.ExchangeID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentStatusField.ExchangeInstID">
<code class="descname">ExchangeInstID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentStatusField.ExchangeInstID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentStatusField.InstrumentID">
<code class="descname">InstrumentID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentStatusField.InstrumentID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentStatusField.InstrumentStatus">
<code class="descname">InstrumentStatus</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentStatusField.InstrumentStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentStatusField.SettlementGroupID">
<code class="descname">SettlementGroupID</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentStatusField.SettlementGroupID" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CThostFtdcInstrumentStatusField.TradingSegmentSN">
<code class="descname">TradingSegmentSN</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CThostFtdcInstrumentStatusField.TradingSegmentSN" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure/Union member</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.comm.CtpComm">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.comm.</code><code class="descname">CtpComm</code><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="ctxalgoctp.ctp.comm.CtpComm.msgQueue2Callback">
<code class="descname">msgQueue2Callback</code><em class="property"> = {}</em><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.msgQueue2Callback" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.preserve_callbacks">
<em class="property">static </em><code class="descname">preserve_callbacks</code><span class="sig-paren">(</span><em>p_msg_queue</em>, <em>p_callback</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.preserve_callbacks" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.clear_callbacks">
<em class="property">static </em><code class="descname">clear_callbacks</code><span class="sig-paren">(</span><em>p_msg_queue</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.clear_callbacks" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.CreateMsgQueue">
<em class="property">static </em><code class="descname">CreateMsgQueue</code><span class="sig-paren">(</span><em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.CreateMsgQueue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnConnect">
<em class="property">static </em><code class="descname">RegOnConnect</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnConnect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnDisconnect">
<em class="property">static </em><code class="descname">RegOnDisconnect</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnDisconnect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnErrRtnOrderAction">
<em class="property">static </em><code class="descname">RegOnErrRtnOrderAction</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnErrRtnOrderAction" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnErrRtnOrderInsert">
<em class="property">static </em><code class="descname">RegOnErrRtnOrderInsert</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnErrRtnOrderInsert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnRspError">
<em class="property">static </em><code class="descname">RegOnRspError</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnRspError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnRspOrderAction">
<em class="property">static </em><code class="descname">RegOnRspOrderAction</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnRspOrderAction" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnRspOrderInsert">
<em class="property">static </em><code class="descname">RegOnRspOrderInsert</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnRspOrderInsert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryDepthMarketData">
<em class="property">static </em><code class="descname">RegOnRspQryDepthMarketData</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryDepthMarketData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryInstrument">
<em class="property">static </em><code class="descname">RegOnRspQryInstrument</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryInstrument" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryInstrumentCommissionRate">
<em class="property">static </em><code class="descname">RegOnRspQryInstrumentCommissionRate</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryInstrumentCommissionRate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryInstrumentMarginRate">
<em class="property">static </em><code class="descname">RegOnRspQryInstrumentMarginRate</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryInstrumentMarginRate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryInstrumentOrderCommRate">
<em class="property">static </em><code class="descname">RegOnRspQryInstrumentOrderCommRate</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryInstrumentOrderCommRate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryInvestorPosition">
<em class="property">static </em><code class="descname">RegOnRspQryInvestorPosition</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryInvestorPosition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryInvestorPositionDetail">
<em class="property">static </em><code class="descname">RegOnRspQryInvestorPositionDetail</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryInvestorPositionDetail" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryOrder">
<em class="property">static </em><code class="descname">RegOnRspQryOrder</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryOrder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryTrade">
<em class="property">static </em><code class="descname">RegOnRspQryTrade</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryTrade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryTradingAccount">
<em class="property">static </em><code class="descname">RegOnRspQryTradingAccount</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnRspQryTradingAccount" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnRtnDepthMarketData">
<em class="property">static </em><code class="descname">RegOnRtnDepthMarketData</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnRtnDepthMarketData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnRtnInstrumentStatus">
<em class="property">static </em><code class="descname">RegOnRtnInstrumentStatus</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnRtnInstrumentStatus" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnRtnOrder">
<em class="property">static </em><code class="descname">RegOnRtnOrder</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnRtnOrder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.RegOnRtnTrade">
<em class="property">static </em><code class="descname">RegOnRtnTrade</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>pCallback</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.RegOnRtnTrade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.ReleaseMsgQueue">
<em class="property">static </em><code class="descname">ReleaseMsgQueue</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.ReleaseMsgQueue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.ClearMsgQueue">
<em class="property">static </em><code class="descname">ClearMsgQueue</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.ClearMsgQueue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.ProcessMsgQueue">
<em class="property">static </em><code class="descname">ProcessMsgQueue</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.ProcessMsgQueue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.StartMsgQueue">
<em class="property">static </em><code class="descname">StartMsgQueue</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.StartMsgQueue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.comm.CtpComm.StopMsgQueue">
<em class="property">static </em><code class="descname">StopMsgQueue</code><span class="sig-paren">(</span><em>pMsgQueue</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.comm.CtpComm.StopMsgQueue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.constants"></span><dl class="class">
<dt id="ctxalgoctp.ctp.constants.Constants">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.constants.</code><code class="descname">Constants</code><a class="headerlink" href="#ctxalgoctp.ctp.constants.Constants" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="ctxalgoctp.ctp.constants.Constants.txt_log_file_name">
<code class="descname">txt_log_file_name</code><em class="property"> = 'output.txt'</em><a class="headerlink" href="#ctxalgoctp.ctp.constants.Constants.txt_log_file_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.constants.Constants.bin_log_file_name">
<code class="descname">bin_log_file_name</code><em class="property"> = 'output.bin'</em><a class="headerlink" href="#ctxalgoctp.ctp.constants.Constants.bin_log_file_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.constants.Constants.context_file_name">
<code class="descname">context_file_name</code><em class="property"> = 'context.txt'</em><a class="headerlink" href="#ctxalgoctp.ctp.constants.Constants.context_file_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.constants.Constants.account_file_name">
<code class="descname">account_file_name</code><em class="property"> = 'account.txt'</em><a class="headerlink" href="#ctxalgoctp.ctp.constants.Constants.account_file_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.constants.Constants.strategy_period">
<code class="descname">strategy_period</code><em class="property"> = 'strategy_period'</em><a class="headerlink" href="#ctxalgoctp.ctp.constants.Constants.strategy_period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.constants.Constants.parameters">
<code class="descname">parameters</code><em class="property"> = 'parameters'</em><a class="headerlink" href="#ctxalgoctp.ctp.constants.Constants.parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.constants.Constants.logger">
<code class="descname">logger</code><em class="property"> = 'logger'</em><a class="headerlink" href="#ctxalgoctp.ctp.constants.Constants.logger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.constants.Constants.description">
<code class="descname">description</code><em class="property"> = 'description'</em><a class="headerlink" href="#ctxalgoctp.ctp.constants.Constants.description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.constants.Constants.base_folder">
<code class="descname">base_folder</code><em class="property"> = 'base_folder'</em><a class="headerlink" href="#ctxalgoctp.ctp.constants.Constants.base_folder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.constants.Constants.instrument_id">
<code class="descname">instrument_id</code><em class="property"> = 'instrument_id'</em><a class="headerlink" href="#ctxalgoctp.ctp.constants.Constants.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.constants.Constants.instrument_ids">
<code class="descname">instrument_ids</code><em class="property"> = 'instrument_ids'</em><a class="headerlink" href="#ctxalgoctp.ctp.constants.Constants.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.constants.Constants.ohlc_periods">
<code class="descname">ohlc_periods</code><em class="property"> = 'ohlc_periods'</em><a class="headerlink" href="#ctxalgoctp.ctp.constants.Constants.ohlc_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.constants.Constants.periods">
<code class="descname">periods</code><em class="property"> = 'periods'</em><a class="headerlink" href="#ctxalgoctp.ctp.constants.Constants.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.constants.Constants.strategy_period_kind">
<code class="descname">strategy_period_kind</code><em class="property"> = 'strategy_period_kind'</em><a class="headerlink" href="#ctxalgoctp.ctp.constants.Constants.strategy_period_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.factory"></span><dl class="class">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpTimeGenerator">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.factory.</code><code class="descname">AbstractCtpTimeGenerator</code><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpTimeGenerator" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpTimeGenerator.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpTimeGenerator.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current time stamp.
Return: timestamp</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.factory.</code><code class="descname">AbstractCtpFactory</code><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract class to generate CtpMarket and CtpTrading classes. Used to
switch between real trading classes and backtesting classes.</p>
<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.set_max_initialization_time">
<code class="descname">set_max_initialization_time</code><span class="sig-paren">(</span><em>duration</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.set_max_initialization_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.max_initialization_time">
<code class="descname">max_initialization_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.max_initialization_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.set_max_initialization_retries">
<code class="descname">set_max_initialization_retries</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.set_max_initialization_retries" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.max_initialization_retries">
<code class="descname">max_initialization_retries</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.max_initialization_retries" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.set_security_company">
<code class="descname">set_security_company</code><span class="sig-paren">(</span><em>company</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.set_security_company" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>company</strong> &#8211; string, security company. None means a default company.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.security_company">
<code class="descname">security_company</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.security_company" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.is_supported_instrument_id">
<code class="descname">is_supported_instrument_id</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.is_supported_instrument_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Is instrument_id a supported instrument?
:param instrument_id: string, instrument id.
:return: bool.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.set_is_tick_data_feed_needed">
<code class="descname">set_is_tick_data_feed_needed</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.set_is_tick_data_feed_needed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.is_tick_data_feed_needed">
<code class="descname">is_tick_data_feed_needed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.is_tick_data_feed_needed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.create_message_queue">
<code class="descname">create_message_queue</code><span class="sig-paren">(</span><em>callbacks</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.create_message_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a message queue instance.
:param callbacks: CtpCallbacks.
:return: CtpMessageQueue.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.create_market">
<code class="descname">create_market</code><span class="sig-paren">(</span><em>msg_queue</em>, <em>ctp_folder</em>, <em>logger</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.create_market" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an AbstractCtpMarket object.
:param msg_queue: CtpMessageQueue, the message queue for CTP functions.
:param ctp_folder: string, the folder for CTP to store data.
:param logger: Logger, the logger.
:return: AbstractCtpMarket.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.create_trading">
<code class="descname">create_trading</code><span class="sig-paren">(</span><em>message_queue</em>, <em>local_path</em>, <em>resume_type</em>, <em>user_product_info</em>, <em>auth_code</em>, <em>logger</em>, <em>dt</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.create_trading" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>message_queue</strong> &#8211; </li>
<li><strong>local_path</strong> &#8211; </li>
<li><strong>resume_type</strong> &#8211; </li>
<li><strong>user_product_info</strong> &#8211; </li>
<li><strong>auth_code</strong> &#8211; </li>
<li><strong>logger</strong> &#8211; Logger, the logger.</li>
<li><strong>dt</strong> &#8211; timestamp</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.get_time_generator">
<code class="descname">get_time_generator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.get_time_generator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.is_market_data_ohlc_bar">
<code class="descname">is_market_data_ohlc_bar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.is_market_data_ohlc_bar" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the market data a full ohlc bar with open, high, low, close and volume values?
Typically, most of backtesting data contains fully ohlc bars. Then this should be set to True.
For real-time, the market data is point data, and not full ohlc bars. In this case, this should be False.
Return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.is_backtesting">
<code class="descname">is_backtesting</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.is_backtesting" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current factory for backtesting?
Return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.put_historical_ohlcs">
<code class="descname">put_historical_ohlcs</code><span class="sig-paren">(</span><em>future_id</em>, <em>new_ohlcs</em>, <em>max_bar</em>, <em>kind</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.put_historical_ohlcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Put ohlc bars into the ohlc cache in current object. This is only used in backtesting.
In real time trading, this method is no-operation.
:param future_id: string, the future id.
:param new_ohlcs: dict from Periodicity to OHLC.
:param max_bar: int, the maximal number of bars to keep for all ohlc objects.</p>
<blockquote>
<div>If an internal ohlc exceeds this length, it will be trimmed.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kind</strong> &#8211; string, kind of ohlc. Valid values are &#8216;time-based&#8217;, &#8216;volatility-based&#8217; from
OhlcGeneratorConstants.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.get_historical_ohlcs">
<code class="descname">get_historical_ohlcs</code><span class="sig-paren">(</span><em>future_id</em>, <em>periods</em>, <em>max_bar</em>, <em>kind</em>, <em>with_open_interests=False</em>, <em>order_book_level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.get_historical_ohlcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return ohlc objects with given periods. This is only used in backtesting. In real time trading,
this method is no-operation.
:param future_id: string, the future id.
:param periods: [Periodicity], the list of periodicities under which ohlc objects are to be returned.
:param max_bar: int, the maximum number of bars for each of the retrieved ohlc.
:param kind: string, kind of ohlc. Valid values are &#8216;time-based&#8217;, &#8216;volatility-based&#8217; from</p>
<blockquote>
<div>OhlcGeneratorConstants.</div></blockquote>
<p>:return dict from Periodicity to OHLC object.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.get_trading_account">
<code class="descname">get_trading_account</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.get_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trading account (only used for backtesting).</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.get_trading_account_id">
<code class="descname">get_trading_account_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.get_trading_account_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trading account id.
:return: string, the trading account id.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.get_trading_account_type">
<code class="descname">get_trading_account_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.get_trading_account_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trading account type.
:return: string, the trading account type. Return future because this is a future trading layer.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.get_broker_id">
<code class="descname">get_broker_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.get_broker_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the broker id.
:return sring, the broker id.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.has_commission">
<code class="descname">has_commission</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.has_commission" title="Permalink to this definition">¶</a></dt>
<dd><p>Should we use 0 commission for all the trades?
This is only used for backtesting, to do early stage strategy research.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.has_data_subscription">
<code class="descname">has_data_subscription</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.has_data_subscription" title="Permalink to this definition">¶</a></dt>
<dd><p>Is there any data subscription registered?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.add_data_subscription">
<code class="descname">add_data_subscription</code><span class="sig-paren">(</span><em>data_subscription</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.add_data_subscription" title="Permalink to this definition">¶</a></dt>
<dd><p>Add data subscription into current.
:param data_subscription: AbstractDataSubscriber, the data subscription.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.poll_subscribed_data">
<code class="descname">poll_subscribed_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.poll_subscribed_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Poll from registered data subscriptions.
:return: boolean, True if there is some data available, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.set_mission_control">
<code class="descname">set_mission_control</code><span class="sig-paren">(</span><em>mission_control</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.set_mission_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Set mission control into current.
:param mission_control: MissionControl.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.mission_control">
<code class="descname">mission_control</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.mission_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current mission control.
:return: MissionControl, the registered mission control.</p>
<blockquote>
<div>Return None if no mission control is registered.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.set_market_data_feed">
<code class="descname">set_market_data_feed</code><span class="sig-paren">(</span><em>market_data_feed</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.set_market_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.data_feed to data_feed.
If market_data_feed is not None, the strategy will not connect to CTP market server. Instead, it will
receive market data from the market data feed&#8217;s zeromq queue.
The default setting is the there is no market_data_feed, so the strategy by default will connect
to CTP market server to get tick data.
:param market_data_feed: MarketDataFeed.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.set_bar_feed">
<code class="descname">set_bar_feed</code><span class="sig-paren">(</span><em>bar_feed</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.set_bar_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Set bar feed with bar_feed. Bar feed is an zeromq based data publisher which publishes
time-based and volatility-based ohlc bars.
:param bar_feed: BarFeed.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.market_data_feed">
<code class="descname">market_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.market_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the registered market data feed.
:return: MarketDataFeed. None if no market data feed is set.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.bar_feed">
<code class="descname">bar_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.bar_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.has_mission_control">
<code class="descname">has_mission_control</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.has_mission_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the mission control setup?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.has_market_data_feed">
<code class="descname">has_market_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.has_market_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the market data feed setup?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.has_bar_feed">
<code class="descname">has_bar_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.has_bar_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.should_get_commission_ratio">
<code class="descname">should_get_commission_ratio</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.should_get_commission_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Should we get commission ratio information from CTP?
This only effect real trading. In real trading some CTP providers does not offer this ability. In this case,
# set this to False, so CTX will use internally stored commission information.
:return: bool.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.should_get_order_comm_rate">
<code class="descname">should_get_order_comm_rate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.should_get_order_comm_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Should we get order comm rate information from CTP?
This only effect real trading. In real trading some CTP providers does not offer this ability. In this case,
# set this to False, so CTX will use internally stored information.
:return: bool.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.set_should_get_commission_ratio">
<code class="descname">set_should_get_commission_ratio</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.set_should_get_commission_ratio" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.set_should_get_order_comm_rate">
<code class="descname">set_should_get_order_comm_rate</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.set_should_get_order_comm_rate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.is_ready_for_backtest">
<code class="descname">is_ready_for_backtest</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.is_ready_for_backtest" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current strategy ready for consuming backtesting data?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.set_is_ready_for_backtest">
<code class="descname">set_is_ready_for_backtest</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.set_is_ready_for_backtest" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of self.is_ready_for_backtest().
:param v: boolean, the value to set.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.future_trading_utils">
<code class="descname">future_trading_utils</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.future_trading_utils" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.store_context">
<code class="descname">store_context</code><span class="sig-paren">(</span><em>context</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.store_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Store context object into file.
:param context: dict{string: object}, context object.
:param path: string, the file path to store data.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.load_context">
<code class="descname">load_context</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.load_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Load context from file.
:param path: string, the file path to load data.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.data_feed">
<code class="descname">data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set data feed.
:return: AbstractDataFeed, the data feed, will be None if no data feed is set.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.AbstractCtpFactory.account_initial_capital">
<code class="descname">account_initial_capital</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory.account_initial_capital" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the initial capital of the trading account.
:return: float, initial capital.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.factory.CtpTimeGeneratorReal">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.factory.</code><code class="descname">CtpTimeGeneratorReal</code><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpTimeGeneratorReal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.factory.AbstractCtpTimeGenerator" title="ctxalgoctp.ctp.factory.AbstractCtpTimeGenerator"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.factory.AbstractCtpTimeGenerator</span></code></a></p>
<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpTimeGeneratorReal.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpTimeGeneratorReal.now" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.factory.</code><code class="descname">CtpFactoryReal</code><span class="sig-paren">(</span><em>account</em>, <em>security_company=None</em>, <em>data_feed=None</em>, <em>account_initial_capital=1000000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.factory.AbstractCtpFactory" title="ctxalgoctp.ctp.factory.AbstractCtpFactory"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.factory.AbstractCtpFactory</span></code></a></p>
<p>This factory returns real CTP market and trading classes.</p>
<p>Initialize current.
:param account: dict{string: object}, information of the trading account.</p>
<blockquote>
<div>The dict must have the following keys: market_server, trading_server, user, password, broker_id.
market_server: string, the server for market data.
trading_server: string, the server for trading data.
user: string, user name.
password: string, password.
broker_id: string, broker id.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>security_company</strong> &#8211; string, security company name.</li>
<li><strong>data_feed</strong> &#8211; AbstractDataFeed, the data feed.</li>
<li><strong>account_initial_capital</strong> &#8211; float, the initial capital for the trading account.
This is used to make sure the strategy report will use the current initial capital to
calculate metrics.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.account_initial_capital">
<code class="descname">account_initial_capital</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.account_initial_capital" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.create_message_queue">
<code class="descname">create_message_queue</code><span class="sig-paren">(</span><em>callbacks</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.create_message_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a message queue instance.
:return: CtpMessageQueue.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.create_market">
<code class="descname">create_market</code><span class="sig-paren">(</span><em>msg_queue</em>, <em>ctp_folder</em>, <em>logger</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.create_market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.create_trading">
<code class="descname">create_trading</code><span class="sig-paren">(</span><em>message_queue</em>, <em>local_path</em>, <em>resume_type</em>, <em>user_product_info</em>, <em>auth_code</em>, <em>logger</em>, <em>dt</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.create_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.get_time_generator">
<code class="descname">get_time_generator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.get_time_generator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.is_market_data_ohlc_bar">
<code class="descname">is_market_data_ohlc_bar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.is_market_data_ohlc_bar" title="Permalink to this definition">¶</a></dt>
<dd><p>In real time trading, the retrieved market data is not full ohlc bars.
So this method returns False.
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.is_backtesting">
<code class="descname">is_backtesting</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.is_backtesting" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.put_historical_ohlcs">
<code class="descname">put_historical_ohlcs</code><span class="sig-paren">(</span><em>future_id</em>, <em>new_ohlcs</em>, <em>max_bar</em>, <em>kind</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.put_historical_ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.get_historical_ohlcs">
<code class="descname">get_historical_ohlcs</code><span class="sig-paren">(</span><em>future_id</em>, <em>periods</em>, <em>max_bar</em>, <em>kind</em>, <em>with_open_interests=False</em>, <em>order_book_level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.get_historical_ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.get_trading_account">
<code class="descname">get_trading_account</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.get_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trading account (only used for backtesting).</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.get_trading_account_id">
<code class="descname">get_trading_account_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.get_trading_account_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.get_broker_id">
<code class="descname">get_broker_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.get_broker_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.has_commission">
<code class="descname">has_commission</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.has_commission" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.is_ready_for_backtest">
<code class="descname">is_ready_for_backtest</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.is_ready_for_backtest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.set_is_ready_for_backtest">
<code class="descname">set_is_ready_for_backtest</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.set_is_ready_for_backtest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.add_data_subscription">
<code class="descname">add_data_subscription</code><span class="sig-paren">(</span><em>data_subscription</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.add_data_subscription" title="Permalink to this definition">¶</a></dt>
<dd><p>Add data subscription into current.
:param data_subscription: AbstractDataSubscriber, the data subscription.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.bar_feed">
<code class="descname">bar_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.bar_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.future_trading_utils">
<code class="descname">future_trading_utils</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.future_trading_utils" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.get_trading_account_type">
<code class="descname">get_trading_account_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.get_trading_account_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trading account type.
:return: string, the trading account type. Return future because this is a future trading layer.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.has_bar_feed">
<code class="descname">has_bar_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.has_bar_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.has_data_subscription">
<code class="descname">has_data_subscription</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.has_data_subscription" title="Permalink to this definition">¶</a></dt>
<dd><p>Is there any data subscription registered?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.has_market_data_feed">
<code class="descname">has_market_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.has_market_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the market data feed setup?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.has_mission_control">
<code class="descname">has_mission_control</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.has_mission_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the mission control setup?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.is_supported_instrument_id">
<code class="descname">is_supported_instrument_id</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.is_supported_instrument_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Is instrument_id a supported instrument?
:param instrument_id: string, instrument id.
:return: bool.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.is_tick_data_feed_needed">
<code class="descname">is_tick_data_feed_needed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.is_tick_data_feed_needed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.market_data_feed">
<code class="descname">market_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.market_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the registered market data feed.
:return: MarketDataFeed. None if no market data feed is set.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.max_initialization_retries">
<code class="descname">max_initialization_retries</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.max_initialization_retries" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.max_initialization_time">
<code class="descname">max_initialization_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.max_initialization_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.mission_control">
<code class="descname">mission_control</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.mission_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current mission control.
:return: MissionControl, the registered mission control.</p>
<blockquote>
<div>Return None if no mission control is registered.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.poll_subscribed_data">
<code class="descname">poll_subscribed_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.poll_subscribed_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Poll from registered data subscriptions.
:return: boolean, True if there is some data available, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.security_company">
<code class="descname">security_company</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.security_company" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.set_bar_feed">
<code class="descname">set_bar_feed</code><span class="sig-paren">(</span><em>bar_feed</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.set_bar_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Set bar feed with bar_feed. Bar feed is an zeromq based data publisher which publishes
time-based and volatility-based ohlc bars.
:param bar_feed: BarFeed.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.set_is_tick_data_feed_needed">
<code class="descname">set_is_tick_data_feed_needed</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.set_is_tick_data_feed_needed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.set_market_data_feed">
<code class="descname">set_market_data_feed</code><span class="sig-paren">(</span><em>market_data_feed</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.set_market_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.data_feed to data_feed.
If market_data_feed is not None, the strategy will not connect to CTP market server. Instead, it will
receive market data from the market data feed&#8217;s zeromq queue.
The default setting is the there is no market_data_feed, so the strategy by default will connect
to CTP market server to get tick data.
:param market_data_feed: MarketDataFeed.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.set_max_initialization_retries">
<code class="descname">set_max_initialization_retries</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.set_max_initialization_retries" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.set_max_initialization_time">
<code class="descname">set_max_initialization_time</code><span class="sig-paren">(</span><em>duration</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.set_max_initialization_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.set_mission_control">
<code class="descname">set_mission_control</code><span class="sig-paren">(</span><em>mission_control</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.set_mission_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Set mission control into current.
:param mission_control: MissionControl.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.set_security_company">
<code class="descname">set_security_company</code><span class="sig-paren">(</span><em>company</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.set_security_company" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>company</strong> &#8211; string, security company. None means a default company.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.set_should_get_commission_ratio">
<code class="descname">set_should_get_commission_ratio</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.set_should_get_commission_ratio" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.set_should_get_order_comm_rate">
<code class="descname">set_should_get_order_comm_rate</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.set_should_get_order_comm_rate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.should_get_commission_ratio">
<code class="descname">should_get_commission_ratio</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.should_get_commission_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Should we get commission ratio information from CTP?
This only effect real trading. In real trading some CTP providers does not offer this ability. In this case,
# set this to False, so CTX will use internally stored commission information.
:return: bool.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.should_get_order_comm_rate">
<code class="descname">should_get_order_comm_rate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.should_get_order_comm_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Should we get order comm rate information from CTP?
This only effect real trading. In real trading some CTP providers does not offer this ability. In this case,
# set this to False, so CTX will use internally stored information.
:return: bool.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.store_context">
<code class="descname">store_context</code><span class="sig-paren">(</span><em>context</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.store_context" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.load_context">
<code class="descname">load_context</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.load_context" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.factory.CtpFactoryReal.data_feed">
<code class="descname">data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.factory.CtpFactoryReal.data_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.optimization"></span><dl class="function">
<dt id="ctxalgoctp.ctp.optimization.make_walk_forward_config">
<code class="descclassname">ctxalgoctp.ctp.optimization.</code><code class="descname">make_walk_forward_config</code><span class="sig-paren">(</span><em>train_window</em>, <em>pred_window</em>, <em>param_specs</em>, <em>funs</em>, <em>pred_start_days=None</em>, <em>optimizer=None</em>, <em>optimizer_options=None</em>, <em>cons=None</em>, <em>regularizers=None</em>, <em>output_folder='training'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.optimization.make_walk_forward_config" title="Permalink to this definition">¶</a></dt>
<dd><p>A utility function to make a dictionary about walk forward configuration.
The optimizer argument can be either an optimizer object or a string that specifies the optimizer
name. Specifically: &#8220;brute-force&#8221;: BruteForceOptimizer , &#8220;random-guess&#8221;: RandomGuessOptimizer,
&#8220;simulated-annealing&#8221;: SimulatedAnnealingOptimizer, &#8220;hill-climbing&#8221;: HillClimbingOptimizer.</p>
</dd></dl>

<dl class="function">
<dt id="ctxalgoctp.ctp.optimization.objective_factory">
<code class="descclassname">ctxalgoctp.ctp.optimization.</code><code class="descname">objective_factory</code><span class="sig-paren">(</span><em>start_date</em>, <em>end_date</em>, <em>last_param</em>, <em>data_source_factory</em>, <em>strategy_class</em>, <em>config</em>, <em>param_specs</em>, <em>funs</em>, <em>cons</em>, <em>regularizers</em>, <em>slippage_model=None</em>, <em>has_commission=True</em>, <em>daily_start_time=None</em>, <em>daily_end_time=None</em>, <em>message_random_delay_enabled=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.optimization.objective_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an objective object given start_date, end_date and previous
parameter value.</p>
<p>This function can be used as a lambda function in the walk forward
backtesting.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start_date</strong> &#8211; start date of the rolling window for the backtesting.</li>
<li><strong>end_date</strong> &#8211; end date of the rolling window for the backtesting.</li>
<li><strong>last_param</strong> &#8211; numpy array of the parameter value in the last rolling
window.</li>
<li><strong>data_source_factory</strong> &#8211; function, returns the data source within
[start_date, end_date)</li>
<li><strong>config, param_specs, funs, cons, regularizers</strong> (<em>strategy_class,</em>) &#8211; the same as in CtpBacktestingObjective.</li>
<li><strong>daily_start_time</strong> &#8211; time, the time when the backtester simulation starts everyday.
(Because walk-forward optimization uses backtester internally).
If None, a default value is used.</li>
<li><strong>daily_end_time</strong> &#8211; time, the time when the backtester simulation ends everyday.
If None, a default value is used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a CtpBacktestingObjective object.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.optimization.CtpBacktestingObjective">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.optimization.</code><code class="descname">CtpBacktestingObjective</code><span class="sig-paren">(</span><em>data_source</em>, <em>strategy_class</em>, <em>config</em>, <em>param_specs</em>, <em>funs</em>, <em>cons=None</em>, <em>regularizers=None</em>, <em>slippage_model=None</em>, <em>has_commission=True</em>, <em>daily_start_time=None</em>, <em>daily_end_time=None</em>, <em>message_random_delay_enabled=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.optimization.CtpBacktestingObjective" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">ctxalgolib.ta.optimization.objective.ObjectiveBase</span></code></p>
<p>Objective function for strategy optimization in backtesting.</p>
<p>A function or constraint specification should be a lambda function and the argument names should be strings
that are recognizable by CtpBacktestingObjective. Supported argument names are:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Performance metrics in the backtesting summary report. For example, &#8216;transaction_count&#8217;, &#8216;max_drawdown&#8217;,</li>
</ol>
<blockquote>
<div>&#8216;max_drawdown_percent&#8217;, &#8216;net_profit&#8217;, &#8216;average_net_profit_by_transaction&#8217;, &#8216;maximum drawdown duration&#8217;</div></blockquote>
<ol class="arabic simple" start="2">
<li>Parameter name in param_specs</li>
<li>Internal representation of the parameters in the format &#8216;[parameter name]_internal&#8217;</li>
<li>Others that are defined separately (we should keep these strings in a list and prepare to add more strings
later): &#8216;maximum drawdown duration&#8217;: maximum drawdown duration in seconds.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data_source</strong> &#8211; </li>
<li><strong>strategy_class</strong> &#8211; </li>
<li><strong>config</strong> &#8211; strategy configuration.</li>
<li><strong>param_specs</strong> &#8211; ParameterVector object that specifies parameters
to be optimized in the config[&#8216;parameters&#8217;] dict.</li>
<li><strong>funs</strong> &#8211; a list of lambda functions to specify report entries (with arguments) as function output.</li>
<li><strong>cons</strong> &#8211; a list of lambda function to specify report entries (with arguments) as constraint output.</li>
<li><strong>regularizers</strong> &#8211; list of regularizer objective object, each for one parameter, or None if not used.</li>
<li><strong>slippage_model</strong> &#8211; AbstractSlippageModel, the slippage model to use for the backtester.
If None, VolumeBasedSlippageModel will be used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ctxalgoctp.ctp.optimization.CtpBacktestingObjective.eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.optimization.CtpBacktestingObjective.eval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.optimization.CtpBacktestingObjective.energy">
<code class="descname">energy</code><span class="sig-paren">(</span><em>foutput</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.optimization.CtpBacktestingObjective.energy" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>foutput</strong> &#8211; one output of all objectvie functions</td>
</tr>
<tr class="field-even field"><th class="field-name">Return float:</th><td class="field-body">energy value of foutput</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.optimization.CtpBacktestingObjective.equals">
<code class="descname">equals</code><span class="sig-paren">(</span><em>foutputs1</em>, <em>foutputs2</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.optimization.CtpBacktestingObjective.equals" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>foutputs1</strong> &#8211; one output of all objectvie functions</li>
<li><strong>foutputs2</strong> &#8211; another output of all objectvie functions</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return True, if foutputs &#8216;qeuals to&#8217; foutputs2; otherwise False.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.optimization.CtpBacktestingObjective.less_then">
<code class="descname">less_then</code><span class="sig-paren">(</span><em>foutputs1</em>, <em>foutputs2</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.optimization.CtpBacktestingObjective.less_then" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>foutputs1</strong> &#8211; one output of all objectvie functions</li>
<li><strong>foutputs2</strong> &#8211; another output of all objectvie functions</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return True, if foutputs &#8216;less then&#8217; foutputs2; otherwise False.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.plain_backtester"></span><dl class="class">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.plain_backtester.</code><code class="descname">PlainBacktester</code><span class="sig-paren">(</span><em>account=None</em>, <em>initial_capital=1000000.0</em>, <em>has_commission=True</em>, <em>instrument_ids=None</em>, <em>slippage_model=None</em>, <em>data_feed=None</em>, <em>security_company=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">ctxalgolib.trading_utils.strategy_queries.AbstractStrategyQueries</span></code></p>
<p>Plain backtester, used when you want to do a quick strategy prototype by just iterating over ohlc bars.</p>
<p>Initialize current.
:param account: TradingAccount, provide a trading account for the backtester to use.</p>
<blockquote>
<div>If None, a default trading account with initial_capital and has_commission will be created.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>initial_capital</strong> &#8211; float, the initial capital to use.</li>
<li><strong>has_commission</strong> &#8211; boolean, if True, no trading commission will be applied.</li>
<li><strong>instrument_ids</strong> &#8211; [string], the list of instrument ids that are to be traded.</li>
<li><strong>slippage_model</strong> &#8211; AbstractSlippageModel, the slippage model to use.
If None, there is no slippage for all the trades.</li>
<li><strong>data_feed</strong> &#8211; AbstractDataFeed, external data feed. If None, then no data feed is set.</li>
<li><strong>security_company</strong> &#8211; string, security company, which offers different commissions to different instruments.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.set_instrument_id">
<code class="descname">set_instrument_id</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.set_instrument_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Set THE ONLY traded instrument.
:param instrument_id: string, instrument id.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.set_instrument_ids">
<code class="descname">set_instrument_ids</code><span class="sig-paren">(</span><em>instrument_ids</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.set_instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the list of traded instruments.
:param instrument_ids: [string], instrument ids.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.get_positions">
<code class="descname">get_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.get_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the instrument positions.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: dict{string: OHLC}, keys are position directions &#8216;long&#8217; or &#8216;short&#8217;. Values are position OHLCs.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.get_transactions">
<code class="descname">get_transactions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.get_transactions" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the list of transactions.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: [AbstractTransaction].</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.update_price">
<code class="descname">update_price</code><span class="sig-paren">(</span><em>price=None</em>, <em>volume=None</em>, <em>timestamp=None</em>, <em>instrument_id=None</em>, <em>ohlcs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.update_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the observed instrument price into current backtester.
Call this method when you have a new ohlc bar for an instrument. The new price is used to
update balance, profit related information in current backtester.
:param price: float, instrument price.</p>
<blockquote>
<div>If None, use data from ohlcs.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>volume</strong> &#8211; int, the traded volume.
If None, use data from ohlcs.</li>
<li><strong>timestamp</strong> &#8211; datetime, current timestamp.
If None, use data from ohlcs.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
<li><strong>ohlcs</strong> &#8211; dict{string: OHLC}, keys are instrument ids, values are ohlcs.
If not None, use the information from here to update prices for multiple instruments; and
ignore price, volume and timestamp parameters.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.change_position_to">
<code class="descname">change_position_to</code><span class="sig-paren">(</span><em>price</em>, <em>new_position</em>, <em>timestamp</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.change_position_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the position of the given instrument to new_position.
:param price: float, if None, newly placed orders are market orders, otherwise, limit orders.
:param price: float, the instrument price.
:param new_position: int, the new position for the instrument.
:param timestamp: datetime, current timestamp.
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.open_position">
<code class="descname">open_position</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>timestamp</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.open_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Open position.
:param price: float, instrument price.
:param volume: int, volume to open, positive number means long position, negative number means short position.
:param timestamp: datetime, current timestamp.
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.close_position">
<code class="descname">close_position</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>timestamp</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.close_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Close position.
:param price: float, instrument price.
:param volume: int, volume to close, positive number means long position, negative number means short position.
:param timestamp: datetime, current timestamp.
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.strategy_period_kind">
<code class="descname">strategy_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.strategy_period_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.strategy_period">
<code class="descname">strategy_period</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.strategy_period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.strategy_ohlc">
<code class="descname">strategy_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.strategy_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.balance_ohlc">
<code class="descname">balance_ohlc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.balance_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.margin_ohlc">
<code class="descname">margin_ohlc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.margin_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.return_ohlc">
<code class="descname">return_ohlc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.return_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.available_money_ohlc">
<code class="descname">available_money_ohlc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.available_money_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.accumulated_commission_ohlc">
<code class="descname">accumulated_commission_ohlc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.accumulated_commission_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.accumulated_profit_ohlc">
<code class="descname">accumulated_profit_ohlc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.accumulated_profit_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.last_bar_so_far">
<code class="descname">last_bar_so_far</code><span class="sig-paren">(</span><em>periodicity</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.strategy_last_bar_so_far">
<code class="descname">strategy_last_bar_so_far</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.strategy_last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.now" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.report">
<code class="descname">report</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.report" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the strategy report.
:return: ctxalgolib.report.abstract_strategy_report.PlainStrategyReport. The report.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd><p>Return position details for all traded instruments.
:return: dict{string: dict{string: [dict{string: object}]}}</p>
<blockquote>
<div><p>The out most keys are instrument ides, and the values are the same as the result of self.position_details.
For example:
{</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;IF99&#8217;: {</dt>
<dd><dl class="first last docutils">
<dt>&#8216;long&#8217;: [</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>{</dt>
<dd>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</dd>
</dl>
<p>}, ...</p>
</div></blockquote>
<p class="last">],</p>
</dd>
<dt>&#8216;short&#8217;: [</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>{</dt>
<dd>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</dd>
</dl>
<p>}, ...</p>
</div></blockquote>
<p class="last">],</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.data_feed">
<code class="descname">data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.data_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.dominant_instrument">
<code class="descname">dominant_instrument</code><span class="sig-paren">(</span><em>instrument_prefix</em>, <em>trading_day</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.dominant_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level dominant instrument id on the given trading day.
:param instrument_prefix: string, instrument id prefix, such as IF, cu.
:param trading_day: date, or string in form of yyyy-mm-dd. trading day.
:param level: int, 0 means the dominant contract, 1 means the next dominant contract, and so on.
:return: string, the instrument id of the asked dominant contract.</p>
<blockquote>
<div>If no such dominant contract, return None.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.has_data_feed">
<code class="descname">has_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.has_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is data feed set?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.long_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return long positions for future_id.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: int, the long position, positive value or zero.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.market_periods" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the market periods for the given instrument on the given trading day.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:param trading_day: date, current trading day, if None ,use self.trading_day()
:return: [(start_ts, end_ts)], the list of market periods.</p>
<blockquote>
<div>start_ts and end_ts are both of type datetime.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.short_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return long positions for future_id.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: int, the short position, negative value or zero.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.tick_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tick size of the given instrument.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: float, tick size of the instrument on the current trading day.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.plain_backtester.PlainBacktester.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.plain_backtester.PlainBacktester.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.real"></span><dl class="class">
<dt id="ctxalgoctp.ctp.real.CtpMarket">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.real.</code><code class="descname">CtpMarket</code><span class="sig-paren">(</span><em>message_queue</em>, <em>local_path</em>, <em>server_address</em>, <em>broker_id</em>, <em>investor_id</em>, <em>password</em>, <em>logger</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpMarket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.base.AbstractCtpMarket" title="ctxalgoctp.ctp.base.AbstractCtpMarket"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.base.AbstractCtpMarket</span></code></a></p>
<p>Initialize market API with message queue.
:param message_queue: CtpMessageQueue, Message queue.
:param local_path: string, the local folder to store temp files.
:param server_address: string, the server address to connect to.
:param broker_id: string, Broker id.
:param investor_id: string, investor id.
:param password: string, investor password.
:param logger: Logger</p>
<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpMarket.connect">
<code class="descname">connect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpMarket.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect to the marker server.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpMarket.subscribe">
<code class="descname">subscribe</code><span class="sig-paren">(</span><em>future_ids</em>, <em>exchange_id=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpMarket.subscribe" title="Permalink to this definition">¶</a></dt>
<dd><p>Subscribe market data for the given futures.
:param future_ids: [string], list of future ids.
:param exchange_id: string, exchange id</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpMarket.unsubscribe">
<code class="descname">unsubscribe</code><span class="sig-paren">(</span><em>future_ids</em>, <em>exchange_id=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpMarket.unsubscribe" title="Permalink to this definition">¶</a></dt>
<dd><p>Un-subscribe market data for the given futures.
:param future_ids: [string], list of future ids.
:param exchange_id: string, exchange id</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpMarket.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpMarket.release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release resources used by current market API.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpMarket.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpMarket.now" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.real.CtpMarket.connection_status">
<code class="descname">connection_status</code><em class="property"> = None</em><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpMarket.connection_status" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.real.CtpMarket.front_id">
<code class="descname">front_id</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpMarket.front_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.real.CtpMarket.session_id">
<code class="descname">session_id</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpMarket.session_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.real.CtpTrading">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.real.</code><code class="descname">CtpTrading</code><span class="sig-paren">(</span><em>message_queue</em>, <em>local_path</em>, <em>server_address</em>, <em>broker_id</em>, <em>investor_id</em>, <em>password</em>, <em>resume_type</em>, <em>user_product_info</em>, <em>auth_code</em>, <em>logger</em>, <em>c2ctp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.base.AbstractCtpTrading" title="ctxalgoctp.ctp.base.AbstractCtpTrading"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.base.AbstractCtpTrading</span></code></a></p>
<p>Initialize market API with message queue.
:param message_queue: CtpMessageQueue, Message queue.
:param local_path: string, the local folder to store temp files.
:param server_address: string, the server address to connect to.
:param broker_id: string, Broker id.
:param investor_id: string, investor id.
:param password: string, investor password.
:param resume_type: resume type
:param user_product_info: the user&#8217;s product info
:param auth_code: auth code
:param logger: Logger</p>
<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.connect">
<code class="descname">connect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>connect to the trading server
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.disconnect">
<code class="descname">disconnect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>disconnect from the trading server
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release resources used by current trading API.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.send_order">
<code class="descname">send_order</code><span class="sig-paren">(</span><em>order_ref</em>, <em>future_id</em>, <em>direction</em>, <em>comb_offset_flag</em>, <em>comb_hedge_flag</em>, <em>volume_total_original</em>, <em>limit_price</em>, <em>order_price_type</em>, <em>time_condition</em>, <em>contingent_condition</em>, <em>stop_price</em>, <em>volume_condition</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.send_order" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new order
:param order_ref: int, if order ref less than 0, it will auto generate an order ref
:param future_id: string, future id
:param direction: TThostFtdcDirectionType, THOST_FTDC_D_Buy or THOST_FTDC_D_Sell
:param comb_offset_flag: TThostFtdcCombOffsetFlagType
:param comb_hedge_flag: TThostFtdcCombHedgeFlagType
:param volume_total_original: TThostFtdcVolumeType
:param limit_price: double, Limit price
:param order_price_type: TThostFtdcOrderPriceTypeType
:param time_condition: TThostFtdcTimeConditionType
:param contingent_condition: TThostFtdcContingentConditionType
:param stop_price: double
:param volume_condition: TThostFtdcVolumeConditionType
:return: int, order reference number.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.cancel_order">
<code class="descname">cancel_order</code><span class="sig-paren">(</span><em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.cancel_order" title="Permalink to this definition">¶</a></dt>
<dd><p>cancel an order
:param order: CThostFtdcOrderField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.get_investor_position">
<code class="descname">get_investor_position</code><span class="sig-paren">(</span><em>future_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.get_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>get investor position
:param future_id: string
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.get_investor_position_detail">
<code class="descname">get_investor_position_detail</code><span class="sig-paren">(</span><em>future_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.get_investor_position_detail" title="Permalink to this definition">¶</a></dt>
<dd><p>get investor position detail
:param future_id: string
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.get_order">
<code class="descname">get_order</code><span class="sig-paren">(</span><em>future_id=''</em>, <em>exchange_id=''</em>, <em>order_sys_id=''</em>, <em>insert_time_start=''</em>, <em>insert_time_end=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.get_order" title="Permalink to this definition">¶</a></dt>
<dd><p>查询报单
:param future_id: string future id
:param exchange_id: string exchange id
:param order_sys_id: string order sys id
:param insert_time_start: string insert start time
:param insert_time_end: string insert end time
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.get_trade">
<code class="descname">get_trade</code><span class="sig-paren">(</span><em>future_id=''</em>, <em>exchange_id=''</em>, <em>trade_id=''</em>, <em>trade_time_start=''</em>, <em>trade_time_end=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.get_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>查询报单
:param future_id: string future id
:param exchange_id: string exchange id
:param trade_id: string trade id
:param trade_time_start: string trade start time
:param trade_time_end: string trade end time
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.get_trading_account">
<code class="descname">get_trading_account</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.get_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>get trading account info
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.get_instrument">
<code class="descname">get_instrument</code><span class="sig-paren">(</span><em>future_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.get_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>get future info
:param futrre_id: string
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.get_commission_rate">
<code class="descname">get_commission_rate</code><span class="sig-paren">(</span><em>future_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.get_commission_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>get future&#8217;s commission rate
:param future_id: string
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.get_margin_rate">
<code class="descname">get_margin_rate</code><span class="sig-paren">(</span><em>future_id</em>, <em>hedge_flag</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.get_margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>get future margin rate
:param future_id: string
:param hedge_flag: TThostFtdcHedgeFlagType
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.get_order_commission_rate">
<code class="descname">get_order_commission_rate</code><span class="sig-paren">(</span><em>future_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.get_order_commission_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Get open and close order commission rate.
:param future_id: string, the future id.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.get_deep_market_data">
<code class="descname">get_deep_market_data</code><span class="sig-paren">(</span><em>future_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.get_deep_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Subscribe market data for the given futures.
:param future_id: string
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.now" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.close_limit_order">
<code class="descname">close_limit_order</code><span class="sig-paren">(</span><em>future_id</em>, <em>price</em>, <em>volume</em>, <em>kind='Normal'</em>, <em>order_ref=-1</em>, <em>transaction_id=None</em>, <em>reason=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.close_limit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a limit order.
:param future_id: string, A single future id.
:param price: double, the price for the limit order.
:param volume: int, the volume for the limit order. Positive number means long position,</p>
<blockquote>
<div>negative number means short position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kind</strong> &#8211; LimitOrderKind. Normal means a normal limit order. FAK means Fill-and-kill, FOK means Fill-or-Kill.</td>
</tr>
</tbody>
</table>
<p>:param order_ref, the order reference number. -1 means that the system will assign a value.
:param transaction_id: string, transaction id.
:param reason: string, reason for placing the order.
:return: int, order reference number.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.close_market_order">
<code class="descname">close_market_order</code><span class="sig-paren">(</span><em>future_id</em>, <em>volume</em>, <em>order_ref=-1</em>, <em>transaction_id=None</em>, <em>reason=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.close_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Send an order to close a trade at market price.
:param future_id, string, a SINGLE future id.
:param volume: int, the volume to order, positive number means long position,</p>
<blockquote>
<div>negative number means short position.</div></blockquote>
<p>:param order_ref, the order reference number. -1 means that the system will assign a value.
:param transaction_id: string, transaction id.
:param reason: string, reason for placing the order.
:return: int, order reference number.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.real.CtpTrading.connection_status">
<code class="descname">connection_status</code><em class="property"> = None</em><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.connection_status" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.real.CtpTrading.front_id">
<code class="descname">front_id</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.front_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.open_limit_order">
<code class="descname">open_limit_order</code><span class="sig-paren">(</span><em>future_id</em>, <em>price</em>, <em>volume</em>, <em>kind='Normal'</em>, <em>order_ref=-1</em>, <em>transaction_id=None</em>, <em>reason=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.open_limit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a limit order.
:param future_id: string, A single future id.
:param price: double, the price for the limit order.
:param volume: int, the volume for the limit order. Positive number means long position,</p>
<blockquote>
<div>negative number means short position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kind</strong> &#8211; LimitOrderKind. Normal means a normal limit order. FAK means Fill-and-kill, FOK means Fill-or-Kill.</td>
</tr>
</tbody>
</table>
<p>:param order_ref, the order reference number. -1 means that the system will assign a value.
:param transaction_id: string, transaction id.
:param reason: string, reason for placing the order.
:return: int, order reference number.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.real.CtpTrading.open_market_order">
<code class="descname">open_market_order</code><span class="sig-paren">(</span><em>future_id</em>, <em>volume</em>, <em>order_ref=-1</em>, <em>transaction_id=None</em>, <em>reason=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.open_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Send an order to open a trade at market price.
:param future_id, string, a SINGLE future id.
:param volume: int, the volume to order, positive number means long position,</p>
<blockquote>
<div>negative number means short position.</div></blockquote>
<p>:param order_ref, the order reference number. -1 means that the system will assign a value.
:param transaction_id: string, transaction id.
:param reason: string, reason for placing the order.
:return: int, order reference number.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.real.CtpTrading.session_id">
<code class="descname">session_id</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.real.CtpTrading.session_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.report"></span><dl class="class">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.report.</code><code class="descname">CtpAbstractStrategyReport</code><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">ctxalgolib.report.abstract_strategy_report.AbstractStrategyReport</span></code></p>
<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_summary">
<code class="descname">get_summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.get_summary_report.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_summary_report">
<code class="descname">get_summary_report</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_summary_report" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the summary report including various metrics such as sharp_ratio.
:return: dict{string: object}, Keys are metric names, values are metric values.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.abs">
<code class="descname">abs</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.abs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.array_max">
<code class="descname">array_max</code><span class="sig-paren">(</span><em>data</em>, <em>default_value=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.array_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.array_min">
<code class="descname">array_min</code><span class="sig-paren">(</span><em>data</em>, <em>default_value=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.array_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.calculate_cagr">
<code class="descname">calculate_cagr</code><span class="sig-paren">(</span><em>daily_balances</em>, <em>trading_day_count</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.calculate_cagr" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate CAGR.
:param daily_balances: OHLC, daily balances.
:param trading_day_count: int, the number of trading days.
:return: float, CAGR value.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.calculate_longest_drawdown">
<code class="descname">calculate_longest_drawdown</code><span class="sig-paren">(</span><em>balance</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.calculate_longest_drawdown" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.calculate_max_drawdown_percent">
<code class="descname">calculate_max_drawdown_percent</code><span class="sig-paren">(</span><em>balance</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.calculate_max_drawdown_percent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.calculate_sharpe_ratio">
<code class="descname">calculate_sharpe_ratio</code><span class="sig-paren">(</span><em>daily_returns</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.calculate_sharpe_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate sharpe ratio.
:param daily_returns: OHLC, daily returns.
:return: float, sharpe ratio.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.calculate_sortino_ratio">
<code class="descname">calculate_sortino_ratio</code><span class="sig-paren">(</span><em>daily_returns</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.calculate_sortino_ratio" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.divide">
<code class="descname">divide</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.divide" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_accumulated_commission">
<code class="descname">get_accumulated_commission</code><span class="sig-paren">(</span><em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em>, <em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_accumulated_commission" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the accumulated commission from self.trades.
:param period: Periodicity, the periodicity of the commission. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the commission.</p>
<blockquote>
<div>If None, start from the first trade.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>end_time</strong> &#8211; datetime, the end time (inclusive) to get the commission. If None, ends at the last trade.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">OHLC. The OHLC object for accumulated commission.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_accumulated_profit">
<code class="descname">get_accumulated_profit</code><span class="sig-paren">(</span><em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_accumulated_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the accumulated profit from self.trades.
:param period: Periodicity, the periodicity of the profit. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the profit. If None, start from the first trade.
:param end_time: datetime, the end time (inclusive) to get the profit. If None, ends at the last trade.
:return: OHLC. The OHLC object for accumulated profit.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_ascii_plot">
<code class="descname">get_ascii_plot</code><span class="sig-paren">(</span><em>data_kind='balance'</em>, <em>period=None</em>, <em>width=200</em>, <em>height=30</em>, <em>marker='-'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_ascii_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a string representing a plot for some kind of data in ASCII.
:param data_kind: string, specify the kind of data to plot.</p>
<blockquote>
<div>Valid values are: balance, return, drawdown_percent.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity. The periodicity of the data. Valid values are DAILY, MONTHLY.
If None, choose DAILY or MONTHLY according to the number of data points: if the number of data points
is more than 100, use MONTHLY, otherwise, use DAILY.</li>
<li><strong>width</strong> &#8211; int, the width of the chart.</li>
<li><strong>height</strong> &#8211; int, the height of the chart.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">string, a string representing the chart.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_available_money">
<code class="descname">get_available_money</code><span class="sig-paren">(</span><em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_available_money" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the available money from self.account_info.
:param period: Periodicity, the periodicity of the available money. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the available money.</p>
<blockquote>
<div>If None, start from the first data point.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>end_time</strong> &#8211; datetime, the end time (inclusive) to get the available money.
If None, ends at the last data point.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">OHLC. The OHLC object for available money.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_balance">
<code class="descname">get_balance</code><span class="sig-paren">(</span><em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_balance" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the balance from self.account_info.
:param period: Periodicity, the periodicity of the balance. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the balance.</p>
<blockquote>
<div>If None, start from the first available data point.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>end_time</strong> &#8211; datetime, the end time (inclusive) to get the balance. If None, ends at the last data point..</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">OHLC. The OHLC object for accumulated balance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_drawdown_percent_ohlc">
<code class="descname">get_drawdown_percent_ohlc</code><span class="sig-paren">(</span><em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_drawdown_percent_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get drawdown values.
:param period: Periodicity, the periodicity of the drawdown. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the drawdown.</p>
<blockquote>
<div>If None, start from the first trade.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>end_time</strong> &#8211; datetime, the end time (inclusive) to get the drawdown. If None, ends at the last trade.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">OHLC. The OHLC object for accumulated drawdown.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_drawdowns">
<code class="descname">get_drawdowns</code><span class="sig-paren">(</span><em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em>, <em>only_max=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_drawdowns" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of drawdown periods.
:param period: Periodicity, the periodicity of the drawdown areas. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the drawdown.</p>
<blockquote>
<div>If None, start from the first trade.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>end_time</strong> &#8211; datetime, the end time (inclusive) to get the drawdown. If None, ends at the last trade.</li>
<li><strong>only_max</strong> &#8211; boolean, if True, only return max drawdown periods.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">[Drawdown], the list of drawdowns.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_drawdowns_from_balance">
<code class="descname">get_drawdowns_from_balance</code><span class="sig-paren">(</span><em>balance</em>, <em>only_max=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_drawdowns_from_balance" title="Permalink to this definition">¶</a></dt>
<dd><p>Get drawdowns from the given balance series.
:param balance: OHLC, the balance series.
:param only_max: boolean, if True, only return max drawdown periods.
:return: [Drawdown], the list of drawdowns.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_initial_capital">
<code class="descname">get_initial_capital</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_initial_capital" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the initial capital.
:return: float, initial capital.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_margin">
<code class="descname">get_margin</code><span class="sig-paren">(</span><em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_margin" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the margin money from self.account_info.
:param period: Periodicity, the periodicity of the margin money. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the margin money.</p>
<blockquote>
<div>If None, start from the first data point.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>end_time</strong> &#8211; datetime, the end time (inclusive) to get the margin money.
If None, ends at the last data point.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">OHLC. The OHLC object for accumulated margin money.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_position_sizing">
<code class="descname">get_position_sizing</code><span class="sig-paren">(</span><em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_position_sizing" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Get position sizing.</dt>
<dd>balance - available_money</dd>
<dt>Position sizing = &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;</dt>
<dd>balance</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the available money. If None, use self.default_period.</li>
<li><strong>start_time</strong> &#8211; datetime, the start time (inclusive) to get the available money.
If None, start from the first data point.</li>
<li><strong>end_time</strong> &#8211; datetime, the end time (inclusive) to get the available money.
If None, ends at the last data point.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC. The OHLC object for position sizing.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_positions">
<code class="descname">get_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em>, <em>merge=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Get instrument positions.
:param instrument_id: string, instrument id. If None, return positions for all traded instruments</p>
<blockquote>
<div>in this report. If not None, only return positions for the given instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the commission. If None, use self.default_period.</li>
<li><strong>start_time</strong> &#8211; datetime, the start time (inclusive) to get the commission.
If None, start from the first trade.</li>
<li><strong>end_time</strong> &#8211; datetime, the end time (inclusive) to get the commission. If None, ends at the last trade.</li>
<li><strong>merge</strong> &#8211; boolean, if False, no merge will happen.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">dict{string: dict{string: OHLC}}, meaning dict{instrument_id: dict{position_direction: position_OHLC}}
Outer keys are instrument ids. Inner keys are position direction, either &#8216;long&#8217; or &#8216;short&#8217;.
Inner values are OHLC objects whose closes series represent the position information.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_return">
<code class="descname">get_return</code><span class="sig-paren">(</span><em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_return" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the return series.
:param period: Periodicity, the periodicity of the profit. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the profit. If None, start from the first trade.
:param end_time: datetime, the end time (inclusive) to get the profit. If None, ends at the last trade.
:return: OHLC. The OHLC object for return.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_transactions">
<code class="descname">get_transactions</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>direction=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.get_transactions" title="Permalink to this definition">¶</a></dt>
<dd><p>Get transactions for an instrument.
:param instrument_id: string, instrument id. If None, return positions for all traded instruments</p>
<blockquote>
<div>in this report. If not None, only return positions for the given instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>direction</strong> &#8211; string, can be &#8216;long&#8217;, &#8216;short&#8217; or None. Return only transactions in the given direction.
If None, return transactions in both long and short directions.</li>
<li><strong>start_time</strong> &#8211; datetime, the start time (inclusive) to get the commission.
If None, start from the first trade.</li>
<li><strong>end_time</strong> &#8211; datetime, the end time (inclusive) to get the commission. If None, ends at the last trade.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">dict{string: TransactionList},
the list of transactions. Keys are instrument ids, values are transactions for that instrument.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.jpeg">
<code class="descname">jpeg</code><span class="sig-paren">(</span><em>kinds=None</em>, <em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.jpeg" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a IPython notebook displayable JPEG image.
:param kinds: [string], list of curves to draw. Multiple curves are drawn in the same plotting area.
:param period: Periodicity, the periodicity of the balance. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the balance.</p>
<blockquote>
<div>If None, start from the first available data point.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>end_time</strong> &#8211; datetime, the end time (inclusive) to get the balance. If None, ends at the last data point..</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A jpeg image which can be displayed directly in IPython notebook.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpAbstractStrategyReport.sorted_summary_keys">
<code class="descname">sorted_summary_keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport.sorted_summary_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sorted metric names used for summary report printing.
:return:</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.report.</code><code class="descname">CtpStrategyReport</code><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.report.CtpAbstractStrategyReport" title="ctxalgoctp.ctp.report.CtpAbstractStrategyReport"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.report.CtpAbstractStrategyReport</span></code></a></p>
<p>Class that represents a report for a strategy.</p>
<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.set_log_file">
<code class="descname">set_log_file</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.set_log_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.log_file with path.
:param path: string, the path to the log file.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_initial_capital">
<code class="descname">get_initial_capital</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_initial_capital" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_accumulated_profit">
<code class="descname">get_accumulated_profit</code><span class="sig-paren">(</span><em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_accumulated_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the accumulated profit from self.trades.
:param period: Periodicity, the periodicity of the profit. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the profit. If None, start from the first trade.
:param end_time: datetime, the end time (inclusive) to get the profit. If None, ends at the last trade.
:return: OHLC. The OHLC object for accumulated profit.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_accumulated_commission">
<code class="descname">get_accumulated_commission</code><span class="sig-paren">(</span><em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em>, <em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_accumulated_commission" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the accumulated commission from self.trades.
:param period: Periodicity, the periodicity of the commission. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the commission.</p>
<blockquote>
<div>If None, start from the first trade.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>end_time</strong> &#8211; datetime, the end time (inclusive) to get the commission. If None, ends at the last trade.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">OHLC. The OHLC object for accumulated commission.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_balance">
<code class="descname">get_balance</code><span class="sig-paren">(</span><em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_balance" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the balance from self.account_info.
:param period: Periodicity, the periodicity of the balance. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the balance.</p>
<blockquote>
<div>If None, start from the first available data point.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>end_time</strong> &#8211; datetime, the end time (inclusive) to get the balance. If None, ends at the last data point..</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">OHLC. The OHLC object for accumulated balance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_available_money">
<code class="descname">get_available_money</code><span class="sig-paren">(</span><em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_available_money" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the available money from self.account_info.
:param period: Periodicity, the periodicity of the available money. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the available money.</p>
<blockquote>
<div>If None, start from the first data point.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>end_time</strong> &#8211; datetime, the end time (inclusive) to get the available money.
If None, ends at the last data point.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">OHLC. The OHLC object for available money.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_margin">
<code class="descname">get_margin</code><span class="sig-paren">(</span><em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_margin" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the margin money from self.account_info.
:param period: Periodicity, the periodicity of the margin money. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the margin money.</p>
<blockquote>
<div>If None, start from the first data point.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>end_time</strong> &#8211; datetime, the end time (inclusive) to get the margin money.
If None, ends at the last data point.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">OHLC. The OHLC object for accumulated margin money.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_positions">
<code class="descname">get_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em>, <em>merge=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_transactions">
<code class="descname">get_transactions</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>direction=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_transactions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_market_periods">
<code class="descname">get_market_periods</code><span class="sig-paren">(</span><em>instrument_prefix</em>, <em>day</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_ohlc">
<code class="descname">get_ohlc</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get trading ohlc for the given instrument.
:param instrument_id: string, instrument id.
:param period: Periodicity, the periodicity of the OHLC. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the ohlc.
If None, start from the first trade.
:param end_time: datetime, the end time (inclusive) to get the available money. If None, ends at the last trade.
:return: OHLC. The OHLC object for accumulated balance.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_trades">
<code class="descname">get_trades</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_trades" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the list of trades.
:return: [Trade], the list of trades.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_detailed_report">
<code class="descname">get_detailed_report</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_detailed_report" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated, use get_trades instead.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_return">
<code class="descname">get_return</code><span class="sig-paren">(</span><em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_return" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the return series.
:param period: Periodicity, the periodicity of the profit. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the profit. If None, start from the first trade.
:param end_time: datetime, the end time (inclusive) to get the profit. If None, ends at the last trade.
:return: OHLC. The OHLC object for return.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_ohlc_return">
<code class="descname">get_ohlc_return</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_ohlc_return" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the returns from an instrument.
:param instrument_id: string, the id of the instrument..
:param period: Periodicity, the periodicity of the profit. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the profit. If None, start from the first trade.
:param end_time: datetime, the end time (inclusive) to get the profit. If None, ends at the last trade.
:return: OHLC. The OHLC object for return.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_summary">
<code class="descname">get_summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the summary report.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.generate_charts">
<code class="descname">generate_charts</code><span class="sig-paren">(</span><em>data_source</em>, <em>folder</em>, <em>index_page_name='index.html'</em>, <em>individual_html_base_name='index'</em>, <em>language='zh'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.generate_charts" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate local html charts for current report.
:param data_source: AbstractDataSource, the data source used for the backtesting session.
:param folder: string, the folder to contain generated html pages.
:param index_page_name: string, the name of the entry page name.
:param individual_html_base_name: string, the base name for the generated html pages. The generated html files</p>
<blockquote>
<div>are named html_base_named.html where d is the page index starting from 1.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>language</strong> &#8211; string, the language in the generated html page, can be &#8216;zh&#8217; or &#8216;en&#8217;.</td>
</tr>
</tbody>
</table>
<p>:return string, the file location of the index page.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_charting_spec">
<code class="descname">get_charting_spec</code><span class="sig-paren">(</span><em>url</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_charting_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the specification for charting.
:param url: string, a url from self.get_urls().
:return: (instrument_id, indicators),</p>
<blockquote>
<div>instrument_id: string, the instrument id.
indicators: [string], the chart specification, each element represents the indicators for a single chart.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_summary_report">
<code class="descname">get_summary_report</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_summary_report" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the summary report.
:return: [(metric_name, all_transaction_value, long_transaction_value, short_transaction_value)]</p>
<blockquote>
<div>metric_name: string, name of the metric (in English).
all_transaction_value: float or None, the metric value for all transactions.
long_transaction_value: float or None, the metric value for long transactions.
short_transaction_value: float or None, the metric value for short transactions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_urls">
<code class="descname">get_urls</code><span class="sig-paren">(</span><em>lang='zh'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_urls" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set of urls for strategy debugging.
:param lang: string, language, &#8216;zh&#8217; means Chinese, &#8216;en&#8217; means English.
:return: OrderedDict from string to string. Keys are url titles, values are the url themselves.</p>
<blockquote>
<div>The urls are ordered by date ascendingly.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_transactions_in_bars">
<code class="descname">get_transactions_in_bars</code><span class="sig-paren">(</span><em>transactions</em>, <em>ohlc</em>, <em>bars</em>, <em>reversed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_transactions_in_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Select the transactions which starts within the specified bars. In other words, a transaction is selected from
transactions and put into the result if and only if its start time is within
a ohlc bar whose 0-based bar indexes are in bars.
:param transactions: [CtpTransaction], the list of transactions to choose from.
:param ohlc: OHLC, the ohlc object.
:param bars: [int], the 0-based bar indexes. Only transactions whose start time is</p>
<blockquote>
<div>within these bars are selected.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reversed</strong> &#8211; boolean, if True, perform the reversed selection. That is, select
a transaction if its start time is not in any of bars.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">[CtpTransaction], the selected transactions.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.abs">
<code class="descname">abs</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.abs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.array_max">
<code class="descname">array_max</code><span class="sig-paren">(</span><em>data</em>, <em>default_value=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.array_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.array_min">
<code class="descname">array_min</code><span class="sig-paren">(</span><em>data</em>, <em>default_value=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.array_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.calculate_cagr">
<code class="descname">calculate_cagr</code><span class="sig-paren">(</span><em>daily_balances</em>, <em>trading_day_count</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.calculate_cagr" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate CAGR.
:param daily_balances: OHLC, daily balances.
:param trading_day_count: int, the number of trading days.
:return: float, CAGR value.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.calculate_longest_drawdown">
<code class="descname">calculate_longest_drawdown</code><span class="sig-paren">(</span><em>balance</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.calculate_longest_drawdown" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.calculate_max_drawdown_percent">
<code class="descname">calculate_max_drawdown_percent</code><span class="sig-paren">(</span><em>balance</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.calculate_max_drawdown_percent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.calculate_sharpe_ratio">
<code class="descname">calculate_sharpe_ratio</code><span class="sig-paren">(</span><em>daily_returns</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.calculate_sharpe_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate sharpe ratio.
:param daily_returns: OHLC, daily returns.
:return: float, sharpe ratio.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.calculate_sortino_ratio">
<code class="descname">calculate_sortino_ratio</code><span class="sig-paren">(</span><em>daily_returns</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.calculate_sortino_ratio" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.divide">
<code class="descname">divide</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.divide" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_ascii_plot">
<code class="descname">get_ascii_plot</code><span class="sig-paren">(</span><em>data_kind='balance'</em>, <em>period=None</em>, <em>width=200</em>, <em>height=30</em>, <em>marker='-'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_ascii_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a string representing a plot for some kind of data in ASCII.
:param data_kind: string, specify the kind of data to plot.</p>
<blockquote>
<div>Valid values are: balance, return, drawdown_percent.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity. The periodicity of the data. Valid values are DAILY, MONTHLY.
If None, choose DAILY or MONTHLY according to the number of data points: if the number of data points
is more than 100, use MONTHLY, otherwise, use DAILY.</li>
<li><strong>width</strong> &#8211; int, the width of the chart.</li>
<li><strong>height</strong> &#8211; int, the height of the chart.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">string, a string representing the chart.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_drawdown_percent_ohlc">
<code class="descname">get_drawdown_percent_ohlc</code><span class="sig-paren">(</span><em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_drawdown_percent_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get drawdown values.
:param period: Periodicity, the periodicity of the drawdown. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the drawdown.</p>
<blockquote>
<div>If None, start from the first trade.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>end_time</strong> &#8211; datetime, the end time (inclusive) to get the drawdown. If None, ends at the last trade.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">OHLC. The OHLC object for accumulated drawdown.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_drawdowns">
<code class="descname">get_drawdowns</code><span class="sig-paren">(</span><em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em>, <em>only_max=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_drawdowns" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of drawdown periods.
:param period: Periodicity, the periodicity of the drawdown areas. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the drawdown.</p>
<blockquote>
<div>If None, start from the first trade.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>end_time</strong> &#8211; datetime, the end time (inclusive) to get the drawdown. If None, ends at the last trade.</li>
<li><strong>only_max</strong> &#8211; boolean, if True, only return max drawdown periods.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">[Drawdown], the list of drawdowns.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_drawdowns_from_balance">
<code class="descname">get_drawdowns_from_balance</code><span class="sig-paren">(</span><em>balance</em>, <em>only_max=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_drawdowns_from_balance" title="Permalink to this definition">¶</a></dt>
<dd><p>Get drawdowns from the given balance series.
:param balance: OHLC, the balance series.
:param only_max: boolean, if True, only return max drawdown periods.
:return: [Drawdown], the list of drawdowns.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.get_position_sizing">
<code class="descname">get_position_sizing</code><span class="sig-paren">(</span><em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.get_position_sizing" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Get position sizing.</dt>
<dd>balance - available_money</dd>
<dt>Position sizing = &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;</dt>
<dd>balance</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the available money. If None, use self.default_period.</li>
<li><strong>start_time</strong> &#8211; datetime, the start time (inclusive) to get the available money.
If None, start from the first data point.</li>
<li><strong>end_time</strong> &#8211; datetime, the end time (inclusive) to get the available money.
If None, ends at the last data point.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC. The OHLC object for position sizing.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.jpeg">
<code class="descname">jpeg</code><span class="sig-paren">(</span><em>kinds=None</em>, <em>period=None</em>, <em>start_time=None</em>, <em>end_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.jpeg" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a IPython notebook displayable JPEG image.
:param kinds: [string], list of curves to draw. Multiple curves are drawn in the same plotting area.
:param period: Periodicity, the periodicity of the balance. If None, use self.default_period.
:param start_time: datetime, the start time (inclusive) to get the balance.</p>
<blockquote>
<div>If None, start from the first available data point.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>end_time</strong> &#8211; datetime, the end time (inclusive) to get the balance. If None, ends at the last data point..</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A jpeg image which can be displayed directly in IPython notebook.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report.CtpStrategyReport.sorted_summary_keys">
<code class="descname">sorted_summary_keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report.CtpStrategyReport.sorted_summary_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sorted metric names used for summary report printing.
:return:</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.report_generator"></span><dl class="class">
<dt id="ctxalgoctp.ctp.report_generator.CtpReportGenerator">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.report_generator.</code><code class="descname">CtpReportGenerator</code><span class="sig-paren">(</span><em>include_url=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_generator.CtpReportGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Initialize current.
:param include_url:  bool, if True, generate urls for visualization.</p>
<dl class="method">
<dt id="ctxalgoctp.ctp.report_generator.CtpReportGenerator.generate_from_file">
<code class="descname">generate_from_file</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_generator.CtpReportGenerator.generate_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate report from file.
:param path: string, the path to the strategy output file.
:return: CtpStrategyReport.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.report_generator.CtpReportGenerator.from_files">
<em class="property">static </em><code class="descname">from_files</code><span class="sig-paren">(</span><em>paths</em>, <em>period=None</em>, <em>include_urls=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_generator.CtpReportGenerator.from_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a composite report from a list of log paths.
:param paths: [string], list if log paths.
:param period: Periodicity, the default period of the composite report to be generated.
:param include_urls: boolean, if True, include generated urls for visualization.
:return: CtpCompositeStrategyReport.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.report_generator.CtpReportGenerator.from_file">
<em class="property">static </em><code class="descname">from_file</code><span class="sig-paren">(</span><em>path</em>, <em>include_urls=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_generator.CtpReportGenerator.from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a report from the tiven log path.
:param path: string, log path.
:param include_urls: boolean, if True, include generated urls for visualization.
:return: CtpStrategyReport.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_generator.CtpReportGenerator.generate">
<code class="descname">generate</code><span class="sig-paren">(</span><em>records</em>, <em>instrument_id=None</em>, <em>size_statistics=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_generator.CtpReportGenerator.generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate report from a list of output file records.
:param records: [LogRecord], the list of log records.
:param instrument_id: string, the instrument id to include in the generated url.</p>
<blockquote>
<div>If None, a proper one will be decided.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size_statistics</strong> &#8211; dict{string: float}, keys are log tag names, values are ratio of
log size that those kinds of tags take.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">CtpStrategyReport.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_generator.CtpReportGenerator.process_walk_forward_training">
<code class="descname">process_walk_forward_training</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_generator.CtpReportGenerator.process_walk_forward_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_generator.CtpReportGenerator.process_strategy">
<code class="descname">process_strategy</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_generator.CtpReportGenerator.process_strategy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_generator.CtpReportGenerator.process_strategy_extra">
<code class="descname">process_strategy_extra</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_generator.CtpReportGenerator.process_strategy_extra" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_generator.CtpReportGenerator.process_market_period">
<code class="descname">process_market_period</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_generator.CtpReportGenerator.process_market_period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_generator.CtpReportGenerator.process_bar">
<code class="descname">process_bar</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_generator.CtpReportGenerator.process_bar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_generator.CtpReportGenerator.process_account">
<code class="descname">process_account</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_generator.CtpReportGenerator.process_account" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_generator.CtpReportGenerator.process_position">
<code class="descname">process_position</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_generator.CtpReportGenerator.process_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_generator.CtpReportGenerator.process_trade">
<code class="descname">process_trade</code><span class="sig-paren">(</span><em>trade</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_generator.CtpReportGenerator.process_trade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_generator.CtpReportGenerator.get_most_suited_ohlc">
<code class="descname">get_most_suited_ohlc</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_generator.CtpReportGenerator.get_most_suited_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_generator.CtpReportGenerator.handle_not_finished_transactions">
<code class="descname">handle_not_finished_transactions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_generator.CtpReportGenerator.handle_not_finished_transactions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_generator.CtpReportGenerator.process_position_sizing">
<code class="descname">process_position_sizing</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_generator.CtpReportGenerator.process_position_sizing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.report_generator.CtpReportGenerator.generate_report">
<em class="property">static </em><code class="descname">generate_report</code><span class="sig-paren">(</span><em>log_file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_generator.CtpReportGenerator.generate_report" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate composite report from given individual strategy log files.
:param log_file_path: string, the path to the strategy log file.
:return: CtpStrategyReport, the report.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.report_generator.CtpReportGenerator.generate_composite_report">
<em class="property">static </em><code class="descname">generate_composite_report</code><span class="sig-paren">(</span><em>log_file_paths</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_generator.CtpReportGenerator.generate_composite_report" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate composite report from given individual strategy log files.
:param log_file_paths: [string], list of strategy log file paths.
:return: CtpCompositeStrategyReport, the composite report.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.report_pdf_generator"></span><dl class="class">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.report_pdf_generator.</code><code class="descname">NumberedCanvas</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">reportlab.pdfgen.canvas.Canvas</span></code></p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.language">
<code class="descname">language</code><em class="property"> = 'english'</em><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.language" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.showPage">
<code class="descname">showPage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.showPage" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.save">
<code class="descname">save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.draw_page_number">
<code class="descname">draw_page_number</code><span class="sig-paren">(</span><em>page_count</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.draw_page_number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.STATE_ATTRIBUTES">
<code class="descname">STATE_ATTRIBUTES</code><em class="property"> = ['_x', '_y', '_fontname', '_fontsize', '_textMode', '_leading', '_currentMatrix', '_fillMode', '_charSpace', '_wordSpace', '_horizScale', '_textRenderMode', '_rise', '_textLineMatrix', '_textMatrix', '_lineCap', '_lineJoin', '_lineDash', '_lineWidth', '_mitreLimit', '_fillColorObj', '_strokeColorObj', '_extgstate']</em><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.STATE_ATTRIBUTES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.STATE_RANGE">
<code class="descname">STATE_RANGE</code><em class="property"> = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]</em><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.STATE_RANGE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.absolutePosition">
<code class="descname">absolutePosition</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.absolutePosition" title="Permalink to this definition">¶</a></dt>
<dd><p>return the absolute position of x,y in user space w.r.t. default user space</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.addFont">
<code class="descname">addFont</code><span class="sig-paren">(</span><em>fontObj</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.addFont" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new font for subsequent use.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.addLiteral">
<code class="descname">addLiteral</code><span class="sig-paren">(</span><em>s</em>, <em>escaped=1</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.addLiteral" title="Permalink to this definition">¶</a></dt>
<dd><p>introduce the literal text of PDF operations s into the current stream.
Only use this if you are an expert in the PDF file format.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.addOutlineEntry">
<code class="descname">addOutlineEntry</code><span class="sig-paren">(</span><em>title</em>, <em>key</em>, <em>level=0</em>, <em>closed=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.addOutlineEntry" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a new entry to the outline at given level.  If LEVEL not specified,
entry goes at the top level.  If level specified, it must be
no more than 1 greater than the outline level in the last call.</p>
<p>The key must be the (unique) name of a bookmark.
the title is the (non-unique) name to be displayed for the entry.</p>
<p>If closed is set then the entry should show no subsections by default
when displayed.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">c</span><span class="o">.</span><span class="n">addOutlineEntry</span><span class="p">(</span><span class="s">&quot;first section&quot;</span><span class="p">,</span> <span class="s">&quot;section1&quot;</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">addOutlineEntry</span><span class="p">(</span><span class="s">&quot;introduction&quot;</span><span class="p">,</span> <span class="s">&quot;s1s1&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">addOutlineEntry</span><span class="p">(</span><span class="s">&quot;body&quot;</span><span class="p">,</span> <span class="s">&quot;s1s2&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">addOutlineEntry</span><span class="p">(</span><span class="s">&quot;detail1&quot;</span><span class="p">,</span> <span class="s">&quot;s1s2s1&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">addOutlineEntry</span><span class="p">(</span><span class="s">&quot;detail2&quot;</span><span class="p">,</span> <span class="s">&quot;s1s2s2&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">addOutlineEntry</span><span class="p">(</span><span class="s">&quot;conclusion&quot;</span><span class="p">,</span> <span class="s">&quot;s1s3&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">addOutlineEntry</span><span class="p">(</span><span class="s">&quot;further reading&quot;</span><span class="p">,</span> <span class="s">&quot;s1s3s1&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">addOutlineEntry</span><span class="p">(</span><span class="s">&quot;second section&quot;</span><span class="p">,</span> <span class="s">&quot;section1&quot;</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">addOutlineEntry</span><span class="p">(</span><span class="s">&quot;introduction&quot;</span><span class="p">,</span> <span class="s">&quot;s2s1&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">addOutlineEntry</span><span class="p">(</span><span class="s">&quot;body&quot;</span><span class="p">,</span> <span class="s">&quot;s2s2&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">addOutlineEntry</span><span class="p">(</span><span class="s">&quot;detail1&quot;</span><span class="p">,</span> <span class="s">&quot;s2s2s1&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">addOutlineEntry</span><span class="p">(</span><span class="s">&quot;detail2&quot;</span><span class="p">,</span> <span class="s">&quot;s2s2s2&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">addOutlineEntry</span><span class="p">(</span><span class="s">&quot;conclusion&quot;</span><span class="p">,</span> <span class="s">&quot;s2s3&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">addOutlineEntry</span><span class="p">(</span><span class="s">&quot;further reading&quot;</span><span class="p">,</span> <span class="s">&quot;s2s3s1&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>generated outline looks like:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="o">-</span> <span class="n">first</span> <span class="n">section</span>
<span class="o">|-</span> <span class="n">introduction</span>
<span class="o">|-</span> <span class="n">body</span>
<span class="o">|</span>  <span class="o">|-</span> <span class="n">detail1</span>
<span class="o">|</span>  <span class="o">|-</span> <span class="n">detail2</span>
<span class="o">|-</span> <span class="n">conclusion</span>
<span class="o">|</span>  <span class="o">|-</span> <span class="n">further</span> <span class="n">reading</span>
<span class="o">-</span> <span class="n">second</span> <span class="n">section</span>
<span class="o">|-</span> <span class="n">introduction</span>
<span class="o">|+</span> <span class="n">body</span>
<span class="o">|-</span> <span class="n">conclusion</span>
<span class="o">|</span>  <span class="o">|-</span> <span class="n">further</span> <span class="n">reading</span>
</pre></div>
</div>
<p>Note that the second &#8220;body&#8221; is closed.</p>
<p>Note that you can jump from level 5 to level 3 but not
from 3 to 5: instead you need to provide all intervening
levels going down (4 in this case).  Note that titles can
collide but keys cannot.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.addPageLabel">
<code class="descname">addPageLabel</code><span class="sig-paren">(</span><em>pageNum</em>, <em>style=None</em>, <em>start=None</em>, <em>prefix=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.addPageLabel" title="Permalink to this definition">¶</a></dt>
<dd><p>add a PDFPageLabel for pageNum</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.addPostScriptCommand">
<code class="descname">addPostScriptCommand</code><span class="sig-paren">(</span><em>command</em>, <em>position=1</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.addPostScriptCommand" title="Permalink to this definition">¶</a></dt>
<dd><p>Embed literal Postscript in the document.</p>
<p>With position=0, it goes at very beginning of page stream;
with position=1, at current point; and
with position=2, at very end of page stream.  What that does
to the resulting Postscript depends on Adobe&#8217;s header :-)</p>
<p>Use with extreme caution, but sometimes needed for printer tray commands.
Acrobat 4.0 will export Postscript to a printer or file containing
the given commands.  Adobe Reader 6.0 no longer does as this feature is
deprecated.  5.0, I don&#8217;t know about (please let us know!). This was
funded by Bob Marshall of Vector.co.uk and tested on a Lexmark 750.
See test_pdfbase_postscript.py for 2 test cases - one will work on
any Postscript device, the other uses a &#8216;setpapertray&#8217; command which
will error in Distiller but work on printers supporting it.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.arc">
<code class="descname">arc</code><span class="sig-paren">(</span><em>x1</em>, <em>y1</em>, <em>x2</em>, <em>y2</em>, <em>startAng=0</em>, <em>extent=90</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.arc" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a partial ellipse inscribed within the rectangle x1,y1,x2,y2,
starting at startAng degrees and covering extent degrees.   Angles
start with 0 to the right (+x) and increase counter-clockwise.
These should have x1&lt;x2 and y1&lt;y2.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.beginForm">
<code class="descname">beginForm</code><span class="sig-paren">(</span><em>name</em>, <em>lowerx=0</em>, <em>lowery=0</em>, <em>upperx=None</em>, <em>uppery=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.beginForm" title="Permalink to this definition">¶</a></dt>
<dd><p>declare the current graphics stream to be a named form.
A graphics stream can either be a page or a form, not both.
Some operations (like bookmarking) are permitted for pages
but not forms.  The form will not automatically be shown in the
document but must be explicitly referenced using doForm in pages
that require the form.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.beginPath">
<code class="descname">beginPath</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.beginPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a fresh path object.  Paths are used to draw
complex figures.  The object returned follows the protocol
for a pathobject.PDFPathObject instance</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.beginText">
<code class="descname">beginText</code><span class="sig-paren">(</span><em>x=0</em>, <em>y=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.beginText" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a fresh text object.  Text objects are used
to add large amounts of text.  See textobject.PDFTextObject</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.bezier">
<code class="descname">bezier</code><span class="sig-paren">(</span><em>x1</em>, <em>y1</em>, <em>x2</em>, <em>y2</em>, <em>x3</em>, <em>y3</em>, <em>x4</em>, <em>y4</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.bezier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bezier curve with the four given control points</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.bookmarkHorizontal">
<code class="descname">bookmarkHorizontal</code><span class="sig-paren">(</span><em>key</em>, <em>relativeX</em>, <em>relativeY</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.bookmarkHorizontal" title="Permalink to this definition">¶</a></dt>
<dd><p>w.r.t. the current transformation, bookmark this horizontal.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.bookmarkHorizontalAbsolute">
<code class="descname">bookmarkHorizontalAbsolute</code><span class="sig-paren">(</span><em>key</em>, <em>top</em>, <em>left=0</em>, <em>fit='XYZ'</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.bookmarkHorizontalAbsolute" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind a bookmark (destination) to the current page at a horizontal position.
Note that the yhorizontal of the book mark is with respect to the default
user space (where the origin is at the lower left corner of the page)
and completely ignores any transform (translation, scale, skew, rotation,
etcetera) in effect for the current graphics state.  The programmer is
responsible for making sure the bookmark matches an appropriate item on
the page.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.bookmarkPage">
<code class="descname">bookmarkPage</code><span class="sig-paren">(</span><em>key</em>, <em>fit='Fit'</em>, <em>left=None</em>, <em>top=None</em>, <em>bottom=None</em>, <em>right=None</em>, <em>zoom=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.bookmarkPage" title="Permalink to this definition">¶</a></dt>
<dd><p>This creates a bookmark to the current page which can
be referred to with the given key elsewhere.</p>
<p>PDF offers very fine grained control over how Acrobat
reader is zoomed when people link to this. The default
is to keep the user&#8217;s current zoom settings. the last
arguments may or may not be needed depending on the
choice of &#8216;fitType&#8217;.</p>
<p>Fit types and the other arguments they use are:</p>
<ul class="simple">
<li>XYZ left top zoom - fine grained control.  null
or zero for any of the parameters means &#8216;leave
as is&#8217;, so &#8220;0,0,0&#8221; will keep the reader&#8217;s settings.
NB. Adobe Reader appears to prefer &#8220;null&#8221; to 0&#8217;s.</li>
<li>Fit - entire page fits in window</li>
<li>FitH top - top coord at top of window, width scaled
to fit.</li>
<li>FitV left - left coord at left of window, height
scaled to fit</li>
<li>FitR left bottom right top - scale window to fit
the specified rectangle</li>
</ul>
<p>(question: do we support /FitB, FitBH and /FitBV
which are hangovers from version 1.1 / Acrobat 3.0?)</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.circle">
<code class="descname">circle</code><span class="sig-paren">(</span><em>x_cen</em>, <em>y_cen</em>, <em>r</em>, <em>stroke=1</em>, <em>fill=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.circle" title="Permalink to this definition">¶</a></dt>
<dd><p>draw a cirle centered at (x_cen,y_cen) with radius r (special case of ellipse)</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.clipPath">
<code class="descname">clipPath</code><span class="sig-paren">(</span><em>aPath</em>, <em>stroke=1</em>, <em>fill=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.clipPath" title="Permalink to this definition">¶</a></dt>
<dd><p>clip as well as drawing</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.delCatalogEntry">
<code class="descname">delCatalogEntry</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.delCatalogEntry" title="Permalink to this definition">¶</a></dt>
<dd><p>you&#8217;ll get an error here if it&#8217;s not been set</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.delViewerPreference">
<code class="descname">delViewerPreference</code><span class="sig-paren">(</span><em>pref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.delViewerPreference" title="Permalink to this definition">¶</a></dt>
<dd><p>you&#8217;ll get an error here if none have been set</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.doForm">
<code class="descname">doForm</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.doForm" title="Permalink to this definition">¶</a></dt>
<dd><p>use a form XObj in current operation stream.</p>
<p>The form should either have been defined previously using
beginForm ... endForm, or may be defined later.  If it is not
defined at save time, an exception will be raised. The form
will be drawn within the context of the current graphics
state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.drawAlignedString">
<code class="descname">drawAlignedString</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>text</em>, <em>pivotChar='.'</em>, <em>mode=None</em>, <em>charSpace=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.drawAlignedString" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a string aligned on the first &#8216;.&#8217; (or other pivot character).</p>
<p>The centre position of the pivot character will be used as x.
So, you could draw a straight line down through all the decimals in a
column of numbers, and anything without a decimal should be
optically aligned with those that have.</p>
<p>There is one special rule to help with accounting formatting.  Here&#8217;s
how normal numbers should be aligned on the &#8216;dot&#8217;. Look at the
LAST two:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="mi">12</span><span class="p">,</span><span class="mi">345</span><span class="p">,</span><span class="mi">67</span>
   <span class="mf">987.15</span>
    <span class="mi">42</span>
<span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mf">234.56</span>
  <span class="p">(</span><span class="mf">456.78</span><span class="p">)</span>
  <span class="p">(</span><span class="mi">456</span><span class="p">)</span>
    <span class="mi">27</span> <span class="n">inches</span>
    <span class="mi">13</span><span class="n">cm</span>
</pre></div>
</div>
<p>Since the last three do not contain a dot, a crude dot-finding
rule would place them wrong. So we test for the special case
where no pivot is found, digits are present, but the last character
is not a digit.  We then work back from the end of the string
This case is a tad slower but hopefully rare.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.drawCentredString">
<code class="descname">drawCentredString</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>text</em>, <em>mode=None</em>, <em>charSpace=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.drawCentredString" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a string centred on the x coordinate.</p>
<p>We&#8217;re British, dammit, and proud of our spelling!</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.drawImage">
<code class="descname">drawImage</code><span class="sig-paren">(</span><em>image</em>, <em>x</em>, <em>y</em>, <em>width=None</em>, <em>height=None</em>, <em>mask=None</em>, <em>preserveAspectRatio=False</em>, <em>anchor='c'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.drawImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws the image (ImageReader object or filename) as specified.</p>
<p>&#8220;image&#8221; may be an image filename or an ImageReader object.</p>
<p>x and y define the lower left corner of the image you wish to
draw (or of its bounding box, if using preserveAspectRation below).</p>
<p>If width and height are not given, the width and height of the
image in pixels is used at a scale of 1 point to 1 pixel.</p>
<p>If width and height are given, the image will be stretched to fill 
the given rectangle bounded by (x, y, x+width, y-height).</p>
<p>If you supply negative widths and/or heights, it inverts them and adjusts
x and y accordingly.</p>
<p>The method returns the width and height of the underlying image, since
this is often useful for layout algorithms and saves you work if you have
not specified them yourself.</p>
<p>The mask parameter supports transparent backgrounds. It takes 6 numbers
and defines the range of RGB values which will be masked out or treated
as transparent.  For example with [0,2,40,42,136,139], it will mask out
any pixels with a Red value from 0-2, Green from 40-42 and
Blue from 136-139  (on a scale of 0-255).</p>
<p>New post version 2.0:  drawImage can center an image in a box you
provide, while preserving its aspect ratio.  For example, you might
have a fixed square box in your design, and a collection of photos
which might be landscape or portrait that you want to appear within 
the box.  If preserveAspectRatio is true, your image will appear within
the box specified.</p>
<p>If preserveAspectRatio is True, the anchor property can be used to
specify how images should fit into the given box.  It should 
be set to one of the following values, taken from the points of
the compass (plus &#8216;c&#8217; for &#8216;centre&#8217;):</p>
<blockquote>
<div>nw   n   ne
w    c    e
sw   s   se</div></blockquote>
<p>The default value is &#8216;c&#8217; for &#8216;centre&#8217;.  Thus, if you want your
bitmaps to always be centred and appear at the top of the given box,
set anchor=&#8217;n&#8217;.      There are good examples of this in the output
of test_pdfgen_general.py</p>
<p>Unlike drawInlineImage, this creates &#8216;external images&#8217; which
are only stored once in the PDF file but can be drawn many times.
If you give it the same filename twice, even at different locations
and sizes, it will reuse the first occurrence, resulting in a saving
in file size and generation time.  If you use ImageReader objects,
it tests whether the image content has changed before deciding
whether to reuse it.</p>
<p>In general you should use drawImage in preference to drawInlineImage
unless you have read the PDF Spec and understand the tradeoffs.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.drawInlineImage">
<code class="descname">drawInlineImage</code><span class="sig-paren">(</span><em>image</em>, <em>x</em>, <em>y</em>, <em>width=None</em>, <em>height=None</em>, <em>preserveAspectRatio=False</em>, <em>anchor='c'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.drawInlineImage" title="Permalink to this definition">¶</a></dt>
<dd><p>See drawImage, which should normally be used instead...</p>
<p>drawInlineImage behaves like drawImage, but stores the image content
within the graphics stream for the page.  This means that the mask
parameter for transparency is not available.  It also means that there 
is no saving in file size or time if the same image is reused.</p>
<p>In theory it allows images to be displayed slightly faster; however, 
we doubt if the difference is noticeable to any human user these days.
Only use this if you have studied the PDF specification and know the
implications.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.drawPath">
<code class="descname">drawPath</code><span class="sig-paren">(</span><em>aPath</em>, <em>stroke=1</em>, <em>fill=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.drawPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw the path object in the mode indicated</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.drawRightString">
<code class="descname">drawRightString</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>text</em>, <em>mode=None</em>, <em>charSpace=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.drawRightString" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a string right-aligned with the x coordinate</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.drawString">
<code class="descname">drawString</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>text</em>, <em>mode=None</em>, <em>charSpace=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.drawString" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a string in the current text styles.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.drawText">
<code class="descname">drawText</code><span class="sig-paren">(</span><em>aTextObject</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.drawText" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a text object</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.ellipse">
<code class="descname">ellipse</code><span class="sig-paren">(</span><em>x1</em>, <em>y1</em>, <em>x2</em>, <em>y2</em>, <em>stroke=1</em>, <em>fill=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.ellipse" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw an ellipse defined by an enclosing rectangle.</p>
<p>Note that (x1,y1) and (x2,y2) are the corner points of
the enclosing rectangle.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.endForm">
<code class="descname">endForm</code><span class="sig-paren">(</span><em>**extra_attributes</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.endForm" title="Permalink to this definition">¶</a></dt>
<dd><p>emit the current collection of graphics operations as a Form
as declared previously in beginForm.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.freeTextAnnotation">
<code class="descname">freeTextAnnotation</code><span class="sig-paren">(</span><em>contents</em>, <em>DA</em>, <em>Rect=None</em>, <em>addtopage=1</em>, <em>name=None</em>, <em>relative=0</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.freeTextAnnotation" title="Permalink to this definition">¶</a></dt>
<dd><p>DA is the default appearance string???</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.getAvailableFonts">
<code class="descname">getAvailableFonts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.getAvailableFonts" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the list of PostScript font names available.</p>
<p>Standard set now, but may grow in future with font embedding.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.getCatalogEntry">
<code class="descname">getCatalogEntry</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.getCatalogEntry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.getCurrentPageContent">
<code class="descname">getCurrentPageContent</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.getCurrentPageContent" title="Permalink to this definition">¶</a></dt>
<dd><p>Return uncompressed contents of current page buffer.</p>
<p>This is useful in creating test cases and assertions of what
got drawn, without necessarily saving pages to disk</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.getPageNumber">
<code class="descname">getPageNumber</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.getPageNumber" title="Permalink to this definition">¶</a></dt>
<dd><p>get the page number for the current page being generated.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.getViewerPreference">
<code class="descname">getViewerPreference</code><span class="sig-paren">(</span><em>pref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.getViewerPreference" title="Permalink to this definition">¶</a></dt>
<dd><p>you&#8217;ll get an error here if none have been set</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.getpdfdata">
<code class="descname">getpdfdata</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.getpdfdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the PDF data that would normally be written to a file.
If there is current data a ShowPage is executed automatically.
After this operation the canvas must not be used further.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.grid">
<code class="descname">grid</code><span class="sig-paren">(</span><em>xlist</em>, <em>ylist</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Lays out a grid in current line style.  Supply list of
x an y positions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.hasForm">
<code class="descname">hasForm</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.hasForm" title="Permalink to this definition">¶</a></dt>
<dd><p>Query whether form XObj really exists yet.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.highlightAnnotation">
<code class="descname">highlightAnnotation</code><span class="sig-paren">(</span><em>contents, Rect, QuadPoints=None, Color=[0.83, 0.89, 0.95], addtopage=1, name=None, relative=0, **kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.highlightAnnotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows adding of a highlighted annotation.</p>
<p>Rect: Mouseover area to show contents of annotation
QuadPoints: List of four x/y points [TOP-LEFT, TOP-RIGHT, BOTTOM-LEFT, BOTTOM-RIGHT]</p>
<blockquote>
<div>These points outline the areas to highlight.
You can have multiple groups of four to allow multiple highlighted areas.
Is in the format [x1, y1, x2, y2, x3, y3, x4, y4, x1, y1, x2, y2, x3, y3, x4, y4] etc
QuadPoints defaults to be area inside of passed in Rect</div></blockquote>
<p>Color: The color of the highlighting.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.init_graphics_state">
<code class="descname">init_graphics_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.init_graphics_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.inkAnnotation">
<code class="descname">inkAnnotation</code><span class="sig-paren">(</span><em>contents</em>, <em>InkList=None</em>, <em>Rect=None</em>, <em>addtopage=1</em>, <em>name=None</em>, <em>relative=0</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.inkAnnotation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.inkAnnotation0">
<code class="descname">inkAnnotation0</code><span class="sig-paren">(</span><em>contents</em>, <em>InkList=None</em>, <em>Rect=None</em>, <em>addtopage=1</em>, <em>name=None</em>, <em>relative=0</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.inkAnnotation0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.line">
<code class="descname">line</code><span class="sig-paren">(</span><em>x1</em>, <em>y1</em>, <em>x2</em>, <em>y2</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.line" title="Permalink to this definition">¶</a></dt>
<dd><p>draw a line segment from (x1,y1) to (x2,y2) (with color, thickness and
other attributes determined by the current graphics state).</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.linearGradient">
<code class="descname">linearGradient</code><span class="sig-paren">(</span><em>x0</em>, <em>y0</em>, <em>x1</em>, <em>y1</em>, <em>colors</em>, <em>positions=None</em>, <em>extend=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.linearGradient" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.lines">
<code class="descname">lines</code><span class="sig-paren">(</span><em>linelist</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Like line(), permits many lines to be drawn in one call.
for example for the figure:</p>
<div class="highlight-default"><div class="highlight"><pre>  <span class="o">|</span>
<span class="o">--</span> <span class="o">--</span>
  <span class="o">|</span>

<span class="n">crosshairs</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">20</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">40</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">),</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">20</span><span class="p">)]</span>
<span class="n">canvas</span><span class="o">.</span><span class="n">lines</span><span class="p">(</span><span class="n">crosshairs</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.linkAbsolute">
<code class="descname">linkAbsolute</code><span class="sig-paren">(</span><em>contents</em>, <em>destinationname</em>, <em>Rect=None</em>, <em>addtopage=1</em>, <em>name=None</em>, <em>thickness=0</em>, <em>color=None</em>, <em>dashArray=None</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.linkAbsolute" title="Permalink to this definition">¶</a></dt>
<dd><p>rectangular link annotation positioned wrt the default user space.
The identified rectangle on the page becomes a &#8220;hot link&#8221; which
when clicked will send the viewer to the page and position identified
by the destination.</p>
<p>Rect identifies (lowerx, lowery, upperx, uppery) for lower left
and upperright points of the rectangle.  Translations and other transforms
are IGNORED (the rectangular position is given with respect
to the default user space.
destinationname should be the name of a bookmark (which may be defined later
but must be defined before the document is generated).</p>
<p>You may want to use the keyword argument Border=&#8217;[0 0 0]&#8217; to
suppress the visible rectangle around the during viewing link.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.linkRect">
<code class="descname">linkRect</code><span class="sig-paren">(</span><em>contents</em>, <em>destinationname</em>, <em>Rect=None</em>, <em>addtopage=1</em>, <em>name=None</em>, <em>relative=1</em>, <em>thickness=0</em>, <em>color=None</em>, <em>dashArray=None</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.linkRect" title="Permalink to this definition">¶</a></dt>
<dd><p>rectangular link annotation w.r.t the current user transform.
if the transform is skewed/rotated the absolute rectangle will use the max/min x/y</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.linkURL">
<code class="descname">linkURL</code><span class="sig-paren">(</span><em>url</em>, <em>rect</em>, <em>relative=0</em>, <em>thickness=0</em>, <em>color=None</em>, <em>dashArray=None</em>, <em>kind='URI'</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.linkURL" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a rectangular URL &#8216;hotspot&#8217; in the given rectangle.</p>
<p>if relative=1, this is in the current coord system, otherwise
in absolute page space.
The remaining options affect the border appearance; the border is
drawn by Acrobat, not us.  Set thickness to zero to hide it.
Any border drawn this way is NOT part of the page stream and
will not show when printed to a Postscript printer or distilled;
it is safest to draw your own.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.listLoadedFonts0">
<code class="descname">listLoadedFonts0</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.listLoadedFonts0" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function to list all loaded fonts</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.pageHasData">
<code class="descname">pageHasData</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.pageHasData" title="Permalink to this definition">¶</a></dt>
<dd><p>Info function - app can call it after showPage to see if it needs a save</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.pop_state_stack">
<code class="descname">pop_state_stack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.pop_state_stack" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.push_state_stack">
<code class="descname">push_state_stack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.push_state_stack" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.radialGradient">
<code class="descname">radialGradient</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>radius</em>, <em>colors</em>, <em>positions=None</em>, <em>extend=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.radialGradient" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.rect">
<code class="descname">rect</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>width</em>, <em>height</em>, <em>stroke=1</em>, <em>fill=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.rect" title="Permalink to this definition">¶</a></dt>
<dd><p>draws a rectangle with lower left corner at (x,y) and width and height as given.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.resetTransforms">
<code class="descname">resetTransforms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.resetTransforms" title="Permalink to this definition">¶</a></dt>
<dd><p>I want to draw something (eg, string underlines) w.r.t. the default user space.
Reset the matrix! This should be used usually as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">canv</span><span class="o">.</span><span class="n">saveState</span><span class="p">()</span>
<span class="n">canv</span><span class="o">.</span><span class="n">resetTransforms</span><span class="p">()</span>
<span class="c">#...draw some stuff in default space coords...</span>
<span class="n">canv</span><span class="o">.</span><span class="n">restoreState</span><span class="p">()</span> <span class="c"># go back!</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.restoreState">
<code class="descname">restoreState</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.restoreState" title="Permalink to this definition">¶</a></dt>
<dd><p>restore the graphics state to the matching saved state (see saveState).</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>theta</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate the canvas by the angle theta (in degrees).</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.roundRect">
<code class="descname">roundRect</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>width</em>, <em>height</em>, <em>radius</em>, <em>stroke=1</em>, <em>fill=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.roundRect" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a rectangle with rounded corners.  The corners are
approximately quadrants of a circle, with the given radius.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.saveState">
<code class="descname">saveState</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.saveState" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the current graphics state to be restored later by restoreState.</p>
<dl class="docutils">
<dt>For example:</dt>
<dd>canvas.setFont(&#8220;Helvetica&#8221;, 20)
canvas.saveState()
...
canvas.setFont(&#8220;Courier&#8221;, 9)
...
canvas.restoreState()
# if the save/restore pairs match then font is Helvetica 20 again.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale the horizontal dimension by x and the vertical by y
(with respect to the current graphics state).
For example canvas.scale(2.0, 0.5) will make everything short and fat.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setAuthor">
<code class="descname">setAuthor</code><span class="sig-paren">(</span><em>author</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setAuthor" title="Permalink to this definition">¶</a></dt>
<dd><p>identify the author for invisible embedding inside the PDF document.
the author annotation will appear in the the text of the file but will
not automatically be seen when the document is viewed, but is visible
in document properties etc etc.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setCatalogEntry">
<code class="descname">setCatalogEntry</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setCatalogEntry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setCreator">
<code class="descname">setCreator</code><span class="sig-paren">(</span><em>creator</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setCreator" title="Permalink to this definition">¶</a></dt>
<dd><p>write a creator into the PDF file that won&#8217;t automatically display
in the document itself. This should be used to name the original app
which is passing data into ReportLab, if you wish to name it.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setDash">
<code class="descname">setDash</code><span class="sig-paren">(</span><em>array=[]</em>, <em>phase=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setDash" title="Permalink to this definition">¶</a></dt>
<dd><p>Two notations.  pass two numbers, or an array and phase</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setDateFormatter">
<code class="descname">setDateFormatter</code><span class="sig-paren">(</span><em>dateFormatter</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setDateFormatter" title="Permalink to this definition">¶</a></dt>
<dd><p>accepts a func(yyyy,mm,dd,hh,m,s) used to create embedded formatted date</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setEncrypt">
<code class="descname">setEncrypt</code><span class="sig-paren">(</span><em>encrypt</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setEncrypt" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the encryption used for the pdf generated by this canvas.
If encrypt is a string object, it is used as the user password for the pdf.
If encrypt is an instance of reportlab.lib.pdfencrypt.StandardEncryption, this object is
used to encrypt the pdf. This allows more finegrained control over the encryption settings.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setFillAlpha">
<code class="descname">setFillAlpha</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setFillAlpha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setFillColor">
<code class="descname">setFillColor</code><span class="sig-paren">(</span><em>aColor</em>, <em>alpha=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setFillColor" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a color object, allowing colors to be referred to by name</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setFillColorCMYK">
<code class="descname">setFillColorCMYK</code><span class="sig-paren">(</span><em>c</em>, <em>m</em>, <em>y</em>, <em>k</em>, <em>alpha=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setFillColorCMYK" title="Permalink to this definition">¶</a></dt>
<dd><p>set the fill color useing negative color values
(cyan, magenta, yellow and darkness value).
Takes 4 arguments between 0.0 and 1.0</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setFillColorRGB">
<code class="descname">setFillColorRGB</code><span class="sig-paren">(</span><em>r</em>, <em>g</em>, <em>b</em>, <em>alpha=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setFillColorRGB" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the fill color using positive color description
(Red,Green,Blue).  Takes 3 arguments between 0.0 and 1.0</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setFillGray">
<code class="descname">setFillGray</code><span class="sig-paren">(</span><em>gray</em>, <em>alpha=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setFillGray" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the gray level; 0.0=black, 1.0=white</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setFillOverprint">
<code class="descname">setFillOverprint</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setFillOverprint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setFont">
<code class="descname">setFont</code><span class="sig-paren">(</span><em>psfontname</em>, <em>size</em>, <em>leading=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setFont" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the font.  If leading not specified, defaults to 1.2 x
font size. Raises a readable exception if an illegal font
is supplied.  Font names are case-sensitive! Keeps track
of font name and size for metrics.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setFontSize">
<code class="descname">setFontSize</code><span class="sig-paren">(</span><em>size=None</em>, <em>leading=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setFontSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets font size or leading without knowing the font face</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setKeywords">
<code class="descname">setKeywords</code><span class="sig-paren">(</span><em>keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setKeywords" title="Permalink to this definition">¶</a></dt>
<dd><p>write a list of keywords into the PDF file which shows in document properties.
Either submit a single string or a list/tuple</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setLineCap">
<code class="descname">setLineCap</code><span class="sig-paren">(</span><em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setLineCap" title="Permalink to this definition">¶</a></dt>
<dd><p>0=butt,1=round,2=square</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setLineJoin">
<code class="descname">setLineJoin</code><span class="sig-paren">(</span><em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setLineJoin" title="Permalink to this definition">¶</a></dt>
<dd><p>0=mitre, 1=round, 2=bevel</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setLineWidth">
<code class="descname">setLineWidth</code><span class="sig-paren">(</span><em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setLineWidth" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setMiterLimit">
<code class="descname">setMiterLimit</code><span class="sig-paren">(</span><em>limit</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setMiterLimit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setOutlineNames0">
<code class="descname">setOutlineNames0</code><span class="sig-paren">(</span><em>*nametree</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setOutlineNames0" title="Permalink to this definition">¶</a></dt>
<dd><p>nametree should can be a recursive tree like so:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">c</span><span class="o">.</span><span class="n">setOutlineNames</span><span class="p">(</span>
  <span class="s">&quot;chapter1dest&quot;</span><span class="p">,</span>
  <span class="p">(</span><span class="s">&quot;chapter2dest&quot;</span><span class="p">,</span>
   <span class="p">[</span><span class="s">&quot;chapter2section1dest&quot;</span><span class="p">,</span>
    <span class="s">&quot;chapter2section2dest&quot;</span><span class="p">,</span>
    <span class="s">&quot;chapter2conclusiondest&quot;</span><span class="p">]</span>
  <span class="p">),</span> <span class="c"># end of chapter2 description</span>
  <span class="s">&quot;chapter3dest&quot;</span><span class="p">,</span>
  <span class="p">(</span><span class="s">&quot;chapter4dest&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;c4s1&quot;</span><span class="p">,</span> <span class="s">&quot;c4s2&quot;</span><span class="p">])</span>
  <span class="p">)</span>
</pre></div>
</div>
<p>each of the string names inside must be bound to a bookmark
before the document is generated.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setOverprintMask">
<code class="descname">setOverprintMask</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setOverprintMask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setPageCallBack">
<code class="descname">setPageCallBack</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setPageCallBack" title="Permalink to this definition">¶</a></dt>
<dd><p>func(pageNum) will be called on each page end.</p>
<dl class="docutils">
<dt>This is mainly a hook for progress monitoring.</dt>
<dd>Call setPageCallback(None) to clear a callback.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setPageCompression">
<code class="descname">setPageCompression</code><span class="sig-paren">(</span><em>pageCompression=1</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setPageCompression" title="Permalink to this definition">¶</a></dt>
<dd><p>Possible values None, 1 or 0
If None the value from rl_config will be used.
If on, the page data will be compressed, leading to much
smaller files, but takes a little longer to create the files.
This applies to all subsequent pages, or until setPageCompression()
is next called.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setPageDuration">
<code class="descname">setPageDuration</code><span class="sig-paren">(</span><em>duration=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setPageDuration" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows hands-off animation of presentations :-)</p>
<p>If this is set to a number, in full screen mode, Acrobat Reader
will advance to the next page after this many seconds. The
duration of the transition itself (fade/flicker etc.) is controlled
by the &#8216;duration&#8217; argument to setPageTransition; this controls
the time spent looking at the page.  This is effective for all
subsequent pages.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setPageRotation">
<code class="descname">setPageRotation</code><span class="sig-paren">(</span><em>rot</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setPageRotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Instruct display device that this page is to be rotated</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setPageSize">
<code class="descname">setPageSize</code><span class="sig-paren">(</span><em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setPageSize" title="Permalink to this definition">¶</a></dt>
<dd><p>accepts a 2-tuple in points for paper size for this
and subsequent pages</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setPageTransition">
<code class="descname">setPageTransition</code><span class="sig-paren">(</span><em>effectname=None</em>, <em>duration=1</em>, <em>direction=0</em>, <em>dimension='H'</em>, <em>motion='I'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setPageTransition" title="Permalink to this definition">¶</a></dt>
<dd><p>PDF allows page transition effects for use when giving
presentations.  There are six possible effects.  You can
just guive the effect name, or supply more advanced options
to refine the way it works.  There are three types of extra
argument permitted, and here are the allowed values:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">direction_arg</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">180</span><span class="p">,</span><span class="mi">270</span><span class="p">]</span>
<span class="n">dimension_arg</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="s">&#39;V&#39;</span><span class="p">]</span>
<span class="n">motion_arg</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;I&#39;</span><span class="p">,</span><span class="s">&#39;O&#39;</span><span class="p">]</span> <span class="p">(</span><span class="n">start</span> <span class="n">at</span> <span class="n">inside</span> <span class="ow">or</span> <span class="n">outside</span><span class="p">)</span>
</pre></div>
</div>
<p>This table says which ones take which arguments:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">PageTransitionEffects</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;Split&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">direction_arg</span><span class="p">,</span> <span class="n">motion_arg</span><span class="p">],</span>
    <span class="s">&#39;Blinds&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">dimension_arg</span><span class="p">],</span>
    <span class="s">&#39;Box&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">motion_arg</span><span class="p">],</span>
    <span class="s">&#39;Wipe&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="n">direction_arg</span><span class="p">],</span>
    <span class="s">&#39;Dissolve&#39;</span> <span class="p">:</span> <span class="p">[],</span>
    <span class="s">&#39;Glitter&#39;</span><span class="p">:[</span><span class="n">direction_arg</span><span class="p">]</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Have fun!</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setStrokeAlpha">
<code class="descname">setStrokeAlpha</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setStrokeAlpha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setStrokeColor">
<code class="descname">setStrokeColor</code><span class="sig-paren">(</span><em>aColor</em>, <em>alpha=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setStrokeColor" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a color object, allowing colors to be referred to by name</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setStrokeColorCMYK">
<code class="descname">setStrokeColorCMYK</code><span class="sig-paren">(</span><em>c</em>, <em>m</em>, <em>y</em>, <em>k</em>, <em>alpha=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setStrokeColorCMYK" title="Permalink to this definition">¶</a></dt>
<dd><p>set the stroke color useing negative color values
(cyan, magenta, yellow and darkness value).
Takes 4 arguments between 0.0 and 1.0</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setStrokeColorRGB">
<code class="descname">setStrokeColorRGB</code><span class="sig-paren">(</span><em>r</em>, <em>g</em>, <em>b</em>, <em>alpha=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setStrokeColorRGB" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the stroke color using positive color description
(Red,Green,Blue).  Takes 3 arguments between 0.0 and 1.0</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setStrokeGray">
<code class="descname">setStrokeGray</code><span class="sig-paren">(</span><em>gray</em>, <em>alpha=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setStrokeGray" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the gray level; 0.0=black, 1.0=white</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setStrokeOverprint">
<code class="descname">setStrokeOverprint</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setStrokeOverprint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setSubject">
<code class="descname">setSubject</code><span class="sig-paren">(</span><em>subject</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setSubject" title="Permalink to this definition">¶</a></dt>
<dd><p>write a subject into the PDF file that won&#8217;t automatically display
in the document itself.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setTitle">
<code class="descname">setTitle</code><span class="sig-paren">(</span><em>title</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setTitle" title="Permalink to this definition">¶</a></dt>
<dd><p>write a title into the PDF file that won&#8217;t automatically display
in the document itself.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setViewerPreference">
<code class="descname">setViewerPreference</code><span class="sig-paren">(</span><em>pref</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.setViewerPreference" title="Permalink to this definition">¶</a></dt>
<dd><p>set one of the allowed enbtries in the documents viewer preferences</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.shade">
<code class="descname">shade</code><span class="sig-paren">(</span><em>shading</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.shade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.showFullScreen0">
<code class="descname">showFullScreen0</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.showFullScreen0" title="Permalink to this definition">¶</a></dt>
<dd><p>Specify that Acrobat Reader should start in full screen mode.
showFullScreen() and showOutline() conflict; the one called last
wins.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.showOutline">
<code class="descname">showOutline</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.showOutline" title="Permalink to this definition">¶</a></dt>
<dd><p>Specify that Acrobat Reader should start with the outline tree visible.
showFullScreen() and showOutline() conflict; the one called last
wins.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.skew">
<code class="descname">skew</code><span class="sig-paren">(</span><em>alpha</em>, <em>beta</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.skew" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.stringWidth">
<code class="descname">stringWidth</code><span class="sig-paren">(</span><em>text</em>, <em>fontName=None</em>, <em>fontSize=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.stringWidth" title="Permalink to this definition">¶</a></dt>
<dd><p>gets width of a string in the given font and size</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.textAnnotation">
<code class="descname">textAnnotation</code><span class="sig-paren">(</span><em>contents</em>, <em>Rect=None</em>, <em>addtopage=1</em>, <em>name=None</em>, <em>relative=0</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.textAnnotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Experimental, but works.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.textAnnotation0">
<code class="descname">textAnnotation0</code><span class="sig-paren">(</span><em>contents</em>, <em>Rect=None</em>, <em>addtopage=1</em>, <em>name=None</em>, <em>relative=0</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.textAnnotation0" title="Permalink to this definition">¶</a></dt>
<dd><p>Experimental, but works.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>, <em>e</em>, <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>adjoin a mathematical transform to the current graphics state matrix.
Not recommended for beginners.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>dx</em>, <em>dy</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>move the origin from the current (0,0) point to the (dx,dy) point
(with respect to the current graphics state).</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.wedge">
<code class="descname">wedge</code><span class="sig-paren">(</span><em>x1</em>, <em>y1</em>, <em>x2</em>, <em>y2</em>, <em>startAng</em>, <em>extent</em>, <em>stroke=1</em>, <em>fill=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.NumberedCanvas.wedge" title="Permalink to this definition">¶</a></dt>
<dd><p>Like arc, but connects to the centre of the ellipse.
Most useful for pie charts and PacMan!</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.report_pdf_generator.AbstractPdfGenerator">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.report_pdf_generator.</code><code class="descname">AbstractPdfGenerator</code><span class="sig-paren">(</span><em>report</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.AbstractPdfGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>report</strong> &#8211; CtpCompositeStrategyReport or CtpStrategyReport</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.AbstractPdfGenerator.generate">
<code class="descname">generate</code><span class="sig-paren">(</span><em>pdf_path</em>, <em>language='english'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.AbstractPdfGenerator.generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the report in PDF in the given language.
:param pdf_path: string, the path of the output PDF file.
:param language: string, the language in which the PDF file is written.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.AbstractPdfGenerator.use_suggested_periods">
<code class="descname">use_suggested_periods</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.AbstractPdfGenerator.use_suggested_periods" title="Permalink to this definition">¶</a></dt>
<dd><p>Suggest the appropriate periods for different charts and set the corresponding properties.
The guideline is that a chart should contain more or less self.max_point_in_chart number of points.
The possible choices for periods are Periodicity.DAILY, Periodicity.WEEKLY, Periodicity.MONTHLY.
Perform the calculation and set self.*_period.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.report_pdf_generator.ReportPdfGenerator">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.report_pdf_generator.</code><code class="descname">ReportPdfGenerator</code><span class="sig-paren">(</span><em>report</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.ReportPdfGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.report_pdf_generator.AbstractPdfGenerator" title="ctxalgoctp.ctp.report_pdf_generator.AbstractPdfGenerator"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.report_pdf_generator.AbstractPdfGenerator</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>report</strong> &#8211; CtpStrategyReport.</td>
</tr>
</tbody>
</table>
<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.report_pdf_generator.ReportPdfGenerator.generate_from_file">
<em class="property">static </em><code class="descname">generate_from_file</code><span class="sig-paren">(</span><em>log_path</em>, <em>pdf_path</em>, <em>language='english'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.ReportPdfGenerator.generate_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate Pdf report from given log file.
:param log_path: string, the path to the strategy log file.
:param pdf_path: string, the path for the output pdf file.
:param language: string, the language in which the PDF file is written. Valid values are &#8216;english&#8217; or &#8216;chinese&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.ReportPdfGenerator.generate">
<code class="descname">generate</code><span class="sig-paren">(</span><em>pdf_path</em>, <em>language='english'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.ReportPdfGenerator.generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the report in PDF in the given language.
:param pdf_path: string, the path of the output PDF file.
:param language: string, the language in which the PDF file is written. Valid values are &#8216;english&#8217; or &#8216;chinese&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.ReportPdfGenerator.use_suggested_periods">
<code class="descname">use_suggested_periods</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.ReportPdfGenerator.use_suggested_periods" title="Permalink to this definition">¶</a></dt>
<dd><p>Suggest the appropriate periods for different charts and set the corresponding properties.
The guideline is that a chart should contain more or less self.max_point_in_chart number of points.
The possible choices for periods are Periodicity.DAILY, Periodicity.WEEKLY, Periodicity.MONTHLY.
Perform the calculation and set self.*_period.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.report_pdf_generator.CompositeReportPdfGenerator">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.report_pdf_generator.</code><code class="descname">CompositeReportPdfGenerator</code><span class="sig-paren">(</span><em>report</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.CompositeReportPdfGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.report_pdf_generator.AbstractPdfGenerator" title="ctxalgoctp.ctp.report_pdf_generator.AbstractPdfGenerator"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.report_pdf_generator.AbstractPdfGenerator</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>report</strong> &#8211; CtpCompositeStrategyReport</td>
</tr>
</tbody>
</table>
<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.report_pdf_generator.CompositeReportPdfGenerator.generate_from_file">
<em class="property">static </em><code class="descname">generate_from_file</code><span class="sig-paren">(</span><em>log_paths</em>, <em>pdf_path</em>, <em>language='english'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.CompositeReportPdfGenerator.generate_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate Pdf report from given log file.
:param log_paths: [string], the paths to the strategy log files.
:param pdf_path: string, the path for the output pdf file.
:param language: string, the language in which the PDF file is written. Valid values are &#8216;english&#8217; or &#8216;chinese&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.CompositeReportPdfGenerator.generate">
<code class="descname">generate</code><span class="sig-paren">(</span><em>pdf_path</em>, <em>language='english'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.CompositeReportPdfGenerator.generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the report in PDF in the given language.
:param pdf_path: string, the path of the output PDF file.
:param language: string, the language in which the PDF file is written.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.report_pdf_generator.CompositeReportPdfGenerator.use_suggested_periods">
<code class="descname">use_suggested_periods</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.report_pdf_generator.CompositeReportPdfGenerator.use_suggested_periods" title="Permalink to this definition">¶</a></dt>
<dd><p>Suggest the appropriate periods for different charts and set the corresponding properties.
The guideline is that a chart should contain more or less self.max_point_in_chart number of points.
The possible choices for periods are Periodicity.DAILY, Periodicity.WEEKLY, Periodicity.MONTHLY.
Perform the calculation and set self.*_period.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.roll"></span><dl class="class">
<dt id="ctxalgoctp.ctp.roll.AbstractRollPocily">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.roll.</code><code class="descname">AbstractRollPocily</code><a class="headerlink" href="#ctxalgoctp.ctp.roll.AbstractRollPocily" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="ctxalgoctp.ctp.roll.AbstractRollPocily.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.roll.AbstractRollPocily.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.roll.AbstractRollPocily.is_roll_on_first_position_change">
<code class="descname">is_roll_on_first_position_change</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.roll.AbstractRollPocily.is_roll_on_first_position_change" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.roll.RollOnFirstPositionChangePolicy">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.roll.</code><code class="descname">RollOnFirstPositionChangePolicy</code><a class="headerlink" href="#ctxalgoctp.ctp.roll.RollOnFirstPositionChangePolicy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.roll.AbstractRollPocily" title="ctxalgoctp.ctp.roll.AbstractRollPocily"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.roll.AbstractRollPocily</span></code></a></p>
<dl class="method">
<dt id="ctxalgoctp.ctp.roll.RollOnFirstPositionChangePolicy.is_roll_on_first_position_change">
<code class="descname">is_roll_on_first_position_change</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.roll.RollOnFirstPositionChangePolicy.is_roll_on_first_position_change" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.roll.RollOnFirstPositionChangePolicy.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.roll.RollOnFirstPositionChangePolicy.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.roll.RollPolicyFactory">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.roll.</code><code class="descname">RollPolicyFactory</code><a class="headerlink" href="#ctxalgoctp.ctp.roll.RollPolicyFactory" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.roll.RollPolicyFactory.roll_on_first_position_change">
<em class="property">static </em><code class="descname">roll_on_first_position_change</code><span class="sig-paren">(</span><em>params={}</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.roll.RollPolicyFactory.roll_on_first_position_change" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.slippage_models"></span><dl class="class">
<dt id="ctxalgoctp.ctp.slippage_models.AbstractSlippageModel">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.slippage_models.</code><code class="descname">AbstractSlippageModel</code><span class="sig-paren">(</span><em>is_tick</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.slippage_models.AbstractSlippageModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Initialize current.
:param is_tick: bool, indicates whether the backtesting is done on tick level data.</p>
<dl class="method">
<dt id="ctxalgoctp.ctp.slippage_models.AbstractSlippageModel.get_max_executable_trade_volume">
<code class="descname">get_max_executable_trade_volume</code><span class="sig-paren">(</span><em>timestamp</em>, <em>market_price</em>, <em>market_volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.slippage_models.AbstractSlippageModel.get_max_executable_trade_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum volumes that can be traded by the backtester, given the actually traded
volumes in the historical data. The result is a fraction of the observed traded volumes
controlled by self.max_executable_trade_volume_ratio.
:param timestamp: datetime, the current timestamp.
:param market_price: float, the traded price from historical data.
:param market_volume: int, the traded volume from historical data.
:param instrument_id: string, the instrument id.
:return int, the max volume that can be traded by the backtester.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.slippage_models.AbstractSlippageModel.get_slippage">
<code class="descname">get_slippage</code><span class="sig-paren">(</span><em>timestamp</em>, <em>tick_size</em>, <em>volume_to_trade</em>, <em>market_price</em>, <em>market_volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.slippage_models.AbstractSlippageModel.get_slippage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the slippage for some volume to be trade.
:param timestamp: datetime, the current timestamp.
:param tick_size: float, tick size.
:param market_price: float, the traded price from historical data.
:param market_volume: int, the traded volume from historical data.
:param instrument_id: string, the instrument id.
:return float, the absolute slippage (the result is non-negative) that the backtester should</p>
<blockquote>
<div>add or subtract to the traded price. The backtester needs to use the trade direction (long or short)
to decide to add or subtract the slippage.</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.slippage_models.VolumeBasedSlippageModel">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.slippage_models.</code><code class="descname">VolumeBasedSlippageModel</code><span class="sig-paren">(</span><em>max_executable_trade_volume_ratio=0.1</em>, <em>slippage_multiple=1</em>, <em>is_tick=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.slippage_models.VolumeBasedSlippageModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.slippage_models.AbstractSlippageModel" title="ctxalgoctp.ctp.slippage_models.AbstractSlippageModel"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.slippage_models.AbstractSlippageModel</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>max_executable_trade_volume_ratio</strong> &#8211; float, the ratio that controls the number of lots that
can be executed by the backtester. Let the current traded lots from historical data at current
timestamp is x, then the maximum lots that can be executed by the backtester is:
max_executable_trade_volume_ratio * x.</li>
<li><strong>slippage_multiple</strong> &#8211; int, the number of tick sizes added to the order filled price to simulate slippage.</li>
<li><strong>is_tick</strong> &#8211; bool, indicates whether the backtesting is done on tick level data.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ctxalgoctp.ctp.slippage_models.VolumeBasedSlippageModel.get_max_executable_trade_volume">
<code class="descname">get_max_executable_trade_volume</code><span class="sig-paren">(</span><em>timestamp</em>, <em>market_price</em>, <em>market_volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.slippage_models.VolumeBasedSlippageModel.get_max_executable_trade_volume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.slippage_models.VolumeBasedSlippageModel.get_slippage">
<code class="descname">get_slippage</code><span class="sig-paren">(</span><em>timestamp</em>, <em>tick_size</em>, <em>volume_to_trade</em>, <em>market_price</em>, <em>market_volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.slippage_models.VolumeBasedSlippageModel.get_slippage" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.slippage_models.EmptySlippageModel">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.slippage_models.</code><code class="descname">EmptySlippageModel</code><span class="sig-paren">(</span><em>is_tick</em>, <em>max_executable_trade_volume_ratio=0.25</em>, <em>slippage_multiple=1</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.slippage_models.EmptySlippageModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.slippage_models.AbstractSlippageModel" title="ctxalgoctp.ctp.slippage_models.AbstractSlippageModel"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.slippage_models.AbstractSlippageModel</span></code></a></p>
<p>Class that always gives empty slippage.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>max_executable_trade_volume_ratio</strong> &#8211; float, the ratio that controls the number of lots that
can be executed by the backtester. Let the current traded lots from historical data at current
timestamp is x, then the maximum lots that can be executed by the backtester is:
max_executable_trade_volume_ratio * x.</li>
<li><strong>slippage_multiple</strong> &#8211; int, the number of tick sizes added to the order filled price to simulate slippage.</li>
<li><strong>is_tick</strong> &#8211; bool, indicates whether the backtesting is done on tick level data.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ctxalgoctp.ctp.slippage_models.EmptySlippageModel.get_max_executable_trade_volume">
<code class="descname">get_max_executable_trade_volume</code><span class="sig-paren">(</span><em>timestamp</em>, <em>market_price</em>, <em>market_volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.slippage_models.EmptySlippageModel.get_max_executable_trade_volume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.slippage_models.EmptySlippageModel.get_slippage">
<code class="descname">get_slippage</code><span class="sig-paren">(</span><em>timestamp</em>, <em>tick_size</em>, <em>volume_to_trade</em>, <em>market_price</em>, <em>market_volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.slippage_models.EmptySlippageModel.get_slippage" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.slippage_models.BidAskSlippageModel">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.slippage_models.</code><code class="descname">BidAskSlippageModel</code><span class="sig-paren">(</span><em>contract_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.slippage_models.BidAskSlippageModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.slippage_models.AbstractSlippageModel" title="ctxalgoctp.ctp.slippage_models.AbstractSlippageModel"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.slippage_models.AbstractSlippageModel</span></code></a></p>
<p>Slippage for models that trade small amounts of a mid-prices series of most liquid contract
We assumes that we have to pay spread / 2</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>contract_name</strong> &#8211; Name of contract</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ctxalgoctp.ctp.slippage_models.BidAskSlippageModel.get_max_executable_trade_volume">
<code class="descname">get_max_executable_trade_volume</code><span class="sig-paren">(</span><em>timestamp</em>, <em>market_price</em>, <em>market_volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.slippage_models.BidAskSlippageModel.get_max_executable_trade_volume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.slippage_models.BidAskSlippageModel.get_slippage">
<code class="descname">get_slippage</code><span class="sig-paren">(</span><em>timestamp</em>, <em>tick_size</em>, <em>volume_to_trade</em>, <em>market_price</em>, <em>market_volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.slippage_models.BidAskSlippageModel.get_slippage" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.state_utils"></span><dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">LimitOrderState</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">ctxalgolib.trading_utils.state.TemplateState</span></code></p>
<p>Initialize current.
:param strategy: AbstractStateBasedStrategy. The state machine.
:param name: string, the name of current state.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.out_edges">
<em class="property">static </em><code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.out_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.should_cancel_order">
<code class="descname">should_cancel_order</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.should_cancel_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.on_entry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.data_feed">
<code class="descname">data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.data_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.dominant_instrument">
<code class="descname">dominant_instrument</code><span class="sig-paren">(</span><em>instrument_prefix</em>, <em>trading_day</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.dominant_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level dominant instrument id on the given trading day.
:param instrument_prefix: string, instrument id prefix, such as IF, cu.
:param trading_day: date, or string in form of yyyy-mm-dd. trading day.
:param level: int, 0 means the dominant contract, 1 means the next dominant contract, and so on.
:return: string, the instrument id of the asked dominant contract.</p>
<blockquote>
<div>If no such dominant contract, return None.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.has_data_feed">
<code class="descname">has_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.has_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is data feed set?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.last_bar_so_far">
<code class="descname">last_bar_so_far</code><span class="sig-paren">(</span><em>periodicity</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.strategy_last_bar_so_far">
<code class="descname">strategy_last_bar_so_far</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.strategy_last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.strategy_ohlc">
<code class="descname">strategy_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.strategy_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.strategy_period">
<code class="descname">strategy_period</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.strategy_period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.strategy_period_kind">
<code class="descname">strategy_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.strategy_period_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.LimitOrderState.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.LimitOrderState.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">OpenLimitOrderState</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.state_utils.LimitOrderState" title="ctxalgoctp.ctp.state_utils.LimitOrderState"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.state_utils.LimitOrderState</span></code></a></p>
<p>Initialize current.
:param strategy: AbstractStateBasedStrategy. The state machine.
:param name: string, the name of current state.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.data_feed">
<code class="descname">data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.data_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.dominant_instrument">
<code class="descname">dominant_instrument</code><span class="sig-paren">(</span><em>instrument_prefix</em>, <em>trading_day</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.dominant_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level dominant instrument id on the given trading day.
:param instrument_prefix: string, instrument id prefix, such as IF, cu.
:param trading_day: date, or string in form of yyyy-mm-dd. trading day.
:param level: int, 0 means the dominant contract, 1 means the next dominant contract, and so on.
:return: string, the instrument id of the asked dominant contract.</p>
<blockquote>
<div>If no such dominant contract, return None.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_data_feed">
<code class="descname">has_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is data feed set?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.last_bar_so_far">
<code class="descname">last_bar_so_far</code><span class="sig-paren">(</span><em>periodicity</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.on_entry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.out_edges">
<code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.out_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.should_cancel_order">
<code class="descname">should_cancel_order</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.should_cancel_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.strategy_last_bar_so_far">
<code class="descname">strategy_last_bar_so_far</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.strategy_last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.strategy_ohlc">
<code class="descname">strategy_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.strategy_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.strategy_period">
<code class="descname">strategy_period</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.strategy_period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.strategy_period_kind">
<code class="descname">strategy_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.strategy_period_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenLimitOrderState.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenLimitOrderState.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">CloseLimitOrderState</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.state_utils.LimitOrderState" title="ctxalgoctp.ctp.state_utils.LimitOrderState"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.state_utils.LimitOrderState</span></code></a></p>
<p>Initialize current.
:param strategy: AbstractStateBasedStrategy. The state machine.
:param name: string, the name of current state.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.data_feed">
<code class="descname">data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.data_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.dominant_instrument">
<code class="descname">dominant_instrument</code><span class="sig-paren">(</span><em>instrument_prefix</em>, <em>trading_day</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.dominant_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level dominant instrument id on the given trading day.
:param instrument_prefix: string, instrument id prefix, such as IF, cu.
:param trading_day: date, or string in form of yyyy-mm-dd. trading day.
:param level: int, 0 means the dominant contract, 1 means the next dominant contract, and so on.
:return: string, the instrument id of the asked dominant contract.</p>
<blockquote>
<div>If no such dominant contract, return None.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_data_feed">
<code class="descname">has_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is data feed set?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.last_bar_so_far">
<code class="descname">last_bar_so_far</code><span class="sig-paren">(</span><em>periodicity</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.on_entry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.out_edges">
<code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.out_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.should_cancel_order">
<code class="descname">should_cancel_order</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.should_cancel_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.strategy_last_bar_so_far">
<code class="descname">strategy_last_bar_so_far</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.strategy_last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.strategy_ohlc">
<code class="descname">strategy_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.strategy_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.strategy_period">
<code class="descname">strategy_period</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.strategy_period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.strategy_period_kind">
<code class="descname">strategy_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.strategy_period_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseLimitOrderState.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseLimitOrderState.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">AbstractCancelOrderState</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">ctxalgolib.trading_utils.state.TemplateState</span></code></p>
<p>Initialize current.
:param strategy: AbstractStateBasedStrategy. The state machine.
:param name: string, the name of current state.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.on_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Do something when entry a state
:param state: string, the name of the entered state</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.data_feed">
<code class="descname">data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.data_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.dominant_instrument">
<code class="descname">dominant_instrument</code><span class="sig-paren">(</span><em>instrument_prefix</em>, <em>trading_day</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.dominant_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level dominant instrument id on the given trading day.
:param instrument_prefix: string, instrument id prefix, such as IF, cu.
:param trading_day: date, or string in form of yyyy-mm-dd. trading day.
:param level: int, 0 means the dominant contract, 1 means the next dominant contract, and so on.
:return: string, the instrument id of the asked dominant contract.</p>
<blockquote>
<div>If no such dominant contract, return None.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_data_feed">
<code class="descname">has_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is data feed set?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.last_bar_so_far">
<code class="descname">last_bar_so_far</code><span class="sig-paren">(</span><em>periodicity</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.out_edges">
<code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.out_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of predefined and fixed out edges leaving current state.
:return: [string], the list of out edge names that can leave current state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.strategy_last_bar_so_far">
<code class="descname">strategy_last_bar_so_far</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.strategy_last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.strategy_ohlc">
<code class="descname">strategy_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.strategy_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.strategy_period">
<code class="descname">strategy_period</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.strategy_period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.strategy_period_kind">
<code class="descname">strategy_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.strategy_period_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">CancelOrderState</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState" title="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.state_utils.AbstractCancelOrderState</span></code></a></p>
<p>Initialize current.
:param strategy: AbstractStateBasedStrategy. The state machine.
:param name: string, the name of current state.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.out_edges">
<em class="property">static </em><code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.out_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.data_feed">
<code class="descname">data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.data_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.dominant_instrument">
<code class="descname">dominant_instrument</code><span class="sig-paren">(</span><em>instrument_prefix</em>, <em>trading_day</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.dominant_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level dominant instrument id on the given trading day.
:param instrument_prefix: string, instrument id prefix, such as IF, cu.
:param trading_day: date, or string in form of yyyy-mm-dd. trading day.
:param level: int, 0 means the dominant contract, 1 means the next dominant contract, and so on.
:return: string, the instrument id of the asked dominant contract.</p>
<blockquote>
<div>If no such dominant contract, return None.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.has_data_feed">
<code class="descname">has_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.has_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is data feed set?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.last_bar_so_far">
<code class="descname">last_bar_so_far</code><span class="sig-paren">(</span><em>periodicity</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.on_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Do something when entry a state
:param state: string, the name of the entered state</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.strategy_last_bar_so_far">
<code class="descname">strategy_last_bar_so_far</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.strategy_last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.strategy_ohlc">
<code class="descname">strategy_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.strategy_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.strategy_period">
<code class="descname">strategy_period</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.strategy_period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.strategy_period_kind">
<code class="descname">strategy_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.strategy_period_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">CancelOrderState2</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.state_utils.AbstractCancelOrderState" title="ctxalgoctp.ctp.state_utils.AbstractCancelOrderState"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.state_utils.AbstractCancelOrderState</span></code></a></p>
<p>Initialize current.
:param strategy: AbstractStateBasedStrategy. The state machine.
:param name: string, the name of current state.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.out_edges">
<em class="property">static </em><code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.out_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.data_feed">
<code class="descname">data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.data_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.dominant_instrument">
<code class="descname">dominant_instrument</code><span class="sig-paren">(</span><em>instrument_prefix</em>, <em>trading_day</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.dominant_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level dominant instrument id on the given trading day.
:param instrument_prefix: string, instrument id prefix, such as IF, cu.
:param trading_day: date, or string in form of yyyy-mm-dd. trading day.
:param level: int, 0 means the dominant contract, 1 means the next dominant contract, and so on.
:return: string, the instrument id of the asked dominant contract.</p>
<blockquote>
<div>If no such dominant contract, return None.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.has_data_feed">
<code class="descname">has_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.has_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is data feed set?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.last_bar_so_far">
<code class="descname">last_bar_so_far</code><span class="sig-paren">(</span><em>periodicity</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.on_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Do something when entry a state
:param state: string, the name of the entered state</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.strategy_last_bar_so_far">
<code class="descname">strategy_last_bar_so_far</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.strategy_last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.strategy_ohlc">
<code class="descname">strategy_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.strategy_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.strategy_period">
<code class="descname">strategy_period</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.strategy_period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.strategy_period_kind">
<code class="descname">strategy_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.strategy_period_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CancelOrderState2.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CancelOrderState2.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">AbstractMarketOrderState</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">ctxalgolib.trading_utils.state.TemplateState</span></code></p>
<p>Initialize current.
:param strategy: AbstractStateBasedStrategy. The state machine.
:param name: string, the name of current state.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.out_edges">
<em class="property">static </em><code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.out_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_order_kind">
<code class="descname">get_order_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_order_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_instrument_ids">
<code class="descname">get_instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the list of instrument ids from self.data whose market orders need to be placed.
:return: [string], the list of instrument ids.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the volume for the market order from self.data for the given instrument id.
:param instrument_id: string, the instrument id.
:return: int, the volume, positive number means long volume, negative value means short volume.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_reason">
<code class="descname">get_reason</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_reason" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the reason for placing the market order for the given instrument id from self.data
:param instrument_id: string, the instrument id.
:return: string, the reason for placing the market order.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_orders">
<code class="descname">get_orders</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.get_orders" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.on_entry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.data_feed">
<code class="descname">data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.data_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.dominant_instrument">
<code class="descname">dominant_instrument</code><span class="sig-paren">(</span><em>instrument_prefix</em>, <em>trading_day</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.dominant_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level dominant instrument id on the given trading day.
:param instrument_prefix: string, instrument id prefix, such as IF, cu.
:param trading_day: date, or string in form of yyyy-mm-dd. trading day.
:param level: int, 0 means the dominant contract, 1 means the next dominant contract, and so on.
:return: string, the instrument id of the asked dominant contract.</p>
<blockquote>
<div>If no such dominant contract, return None.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_data_feed">
<code class="descname">has_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is data feed set?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.last_bar_so_far">
<code class="descname">last_bar_so_far</code><span class="sig-paren">(</span><em>periodicity</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.strategy_last_bar_so_far">
<code class="descname">strategy_last_bar_so_far</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.strategy_last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.strategy_ohlc">
<code class="descname">strategy_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.strategy_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.strategy_period">
<code class="descname">strategy_period</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.strategy_period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.strategy_period_kind">
<code class="descname">strategy_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.strategy_period_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">OpenMarketOrderState</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState" title="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.state_utils.AbstractMarketOrderState</span></code></a></p>
<p>Initialize current.
:param strategy: AbstractStateBasedStrategy. The state machine.
:param name: string, the name of current state.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_orders">
<code class="descname">get_orders</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_orders" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.data_feed">
<code class="descname">data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.data_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.dominant_instrument">
<code class="descname">dominant_instrument</code><span class="sig-paren">(</span><em>instrument_prefix</em>, <em>trading_day</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.dominant_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level dominant instrument id on the given trading day.
:param instrument_prefix: string, instrument id prefix, such as IF, cu.
:param trading_day: date, or string in form of yyyy-mm-dd. trading day.
:param level: int, 0 means the dominant contract, 1 means the next dominant contract, and so on.
:return: string, the instrument id of the asked dominant contract.</p>
<blockquote>
<div>If no such dominant contract, return None.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_instrument_ids">
<code class="descname">get_instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the list of instrument ids from self.data whose market orders need to be placed.
:return: [string], the list of instrument ids.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_order_kind">
<code class="descname">get_order_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_order_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_reason">
<code class="descname">get_reason</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_reason" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the reason for placing the market order for the given instrument id from self.data
:param instrument_id: string, the instrument id.
:return: string, the reason for placing the market order.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the volume for the market order from self.data for the given instrument id.
:param instrument_id: string, the instrument id.
:return: int, the volume, positive number means long volume, negative value means short volume.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_data_feed">
<code class="descname">has_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is data feed set?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.last_bar_so_far">
<code class="descname">last_bar_so_far</code><span class="sig-paren">(</span><em>periodicity</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.on_entry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.out_edges">
<code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.out_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.strategy_last_bar_so_far">
<code class="descname">strategy_last_bar_so_far</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.strategy_last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.strategy_ohlc">
<code class="descname">strategy_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.strategy_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.strategy_period">
<code class="descname">strategy_period</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.strategy_period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.strategy_period_kind">
<code class="descname">strategy_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.strategy_period_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.OpenMarketOrderState.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.OpenMarketOrderState.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">CloseMarketOrderState</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState" title="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.state_utils.AbstractMarketOrderState</span></code></a></p>
<p>Initialize current.
:param strategy: AbstractStateBasedStrategy. The state machine.
:param name: string, the name of current state.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_orders">
<code class="descname">get_orders</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_orders" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.data_feed">
<code class="descname">data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.data_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.dominant_instrument">
<code class="descname">dominant_instrument</code><span class="sig-paren">(</span><em>instrument_prefix</em>, <em>trading_day</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.dominant_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level dominant instrument id on the given trading day.
:param instrument_prefix: string, instrument id prefix, such as IF, cu.
:param trading_day: date, or string in form of yyyy-mm-dd. trading day.
:param level: int, 0 means the dominant contract, 1 means the next dominant contract, and so on.
:return: string, the instrument id of the asked dominant contract.</p>
<blockquote>
<div>If no such dominant contract, return None.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_instrument_ids">
<code class="descname">get_instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the list of instrument ids from self.data whose market orders need to be placed.
:return: [string], the list of instrument ids.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_order_kind">
<code class="descname">get_order_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_order_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_reason">
<code class="descname">get_reason</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_reason" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the reason for placing the market order for the given instrument id from self.data
:param instrument_id: string, the instrument id.
:return: string, the reason for placing the market order.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the volume for the market order from self.data for the given instrument id.
:param instrument_id: string, the instrument id.
:return: int, the volume, positive number means long volume, negative value means short volume.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_data_feed">
<code class="descname">has_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is data feed set?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.last_bar_so_far">
<code class="descname">last_bar_so_far</code><span class="sig-paren">(</span><em>periodicity</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.on_entry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.out_edges">
<code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.out_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.strategy_last_bar_so_far">
<code class="descname">strategy_last_bar_so_far</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.strategy_last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.strategy_ohlc">
<code class="descname">strategy_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.strategy_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.strategy_period">
<code class="descname">strategy_period</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.strategy_period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.strategy_period_kind">
<code class="descname">strategy_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.strategy_period_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.CloseMarketOrderState.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.CloseMarketOrderState.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.state_utils.</code><code class="descname">PlaceMarketOrdersState</code><span class="sig-paren">(</span><em>strategy</em>, <em>name</em>, <em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.state_utils.AbstractMarketOrderState" title="ctxalgoctp.ctp.state_utils.AbstractMarketOrderState"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.state_utils.AbstractMarketOrderState</span></code></a></p>
<p>Class that can place a set of market orders and wait for all the orders to be fully executed.
Those orders can be either open or close orders, and they can open or close different instruments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>strategy</strong> &#8211; AbstractStateBasedStrategy. The state machine.</li>
<li><strong>name</strong> &#8211; string, the name of current state.</li>
<li><strong>transitions</strong> &#8211; dict{string:string}, the transitions from current state.
Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_orders">
<code class="descname">get_orders</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_orders" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.data_feed">
<code class="descname">data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.data_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.dominant_instrument">
<code class="descname">dominant_instrument</code><span class="sig-paren">(</span><em>instrument_prefix</em>, <em>trading_day</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.dominant_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level dominant instrument id on the given trading day.
:param instrument_prefix: string, instrument id prefix, such as IF, cu.
:param trading_day: date, or string in form of yyyy-mm-dd. trading day.
:param level: int, 0 means the dominant contract, 1 means the next dominant contract, and so on.
:return: string, the instrument id of the asked dominant contract.</p>
<blockquote>
<div>If no such dominant contract, return None.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.evaluate_invariants">
<code class="descname">evaluate_invariants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.evaluate_invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate invariants.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.evaluate_old_expressions">
<code class="descname">evaluate_old_expressions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.evaluate_old_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate old expressions appearing in self.postconditions.
Store the evaluations in self.old_expression_evaluations.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.evaluate_postconditions">
<code class="descname">evaluate_postconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.evaluate_postconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate postconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.evaluate_preconditions">
<code class="descname">evaluate_preconditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.evaluate_preconditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate preconditions.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_instrument_ids">
<code class="descname">get_instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the list of instrument ids from self.data whose market orders need to be placed.
:return: [string], the list of instrument ids.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_order_kind">
<code class="descname">get_order_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_order_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_reason">
<code class="descname">get_reason</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_reason" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the reason for placing the market order for the given instrument id from self.data
:param instrument_id: string, the instrument id.
:return: string, the reason for placing the market order.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the volume for the market order from self.data for the given instrument id.
:param instrument_id: string, the instrument id.
:return: int, the volume, positive number means long volume, negative value means short volume.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_data_feed">
<code class="descname">has_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is data feed set?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_next_state">
<code class="descname">is_next_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is next_state the given name?
:param name: string, the name of a state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_transition_valid">
<code class="descname">is_transition_valid</code><span class="sig-paren">(</span><em>transitions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.is_transition_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is transitions valid according to out_edges?
transitions is valid if it contains all the next states required by out_edges and
the labels in transitions are also defined in out_edges.
:param transitions: dict{string:string}, the transitions from current state.</p>
<blockquote>
<div>Keys are target state names, values are the label of those transitions.
Note that the labels must be certain strings defined in current class.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.last_bar_so_far">
<code class="descname">last_bar_so_far</code><span class="sig-paren">(</span><em>periodicity</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.long_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of current state.
:return: string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.next_state">
<code class="descname">next_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.next_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the next state (in transition).
The next state name will be updated when the _transit method is returned.
So in postcondition evaluations, next state name is already updated to the
name of the transited state (if any transition occurs).
This is useful in writing postconditions.
:return string, the name of the next state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current timestamp. Always use this method to get current timestamp in the strategy class
and all the state classes. Do not use datetime.now() because it won&#8217;t work for backtesting.
:return: datetime, the current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.on_entry">
<code class="descname">on_entry</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.on_entry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.on_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.out_edges">
<code class="descname">out_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.out_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.prepare_for_transition">
<code class="descname">prepare_for_transition</code><span class="sig-paren">(</span><em>next_state</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.prepare_for_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the transition to next_state. This method is invoked inside the _transit method
of a pre-defined state class. It is invoked when the state has finished all calculations and
is ready to transit to the next state.
:param next_state: string, name of the state to transit to.
:param inputs: dict{string: object}, the inputs that are pass into current state&#8217;s _transit method.
:return: dict{string: object}, the data that should be passed to</p>
<blockquote>
<div>the next_state (data is passed into the next_state through set_data).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.process_contracts">
<code class="descname">process_contracts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.process_contracts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process contracts for evaluations.
Process preconditions in the following way:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Generate evaluatable preconditions.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Process postconditions in the following way:</dt>
<dd><ol class="first last arabic simple">
<li>Find all old expressions in postconditions.</li>
<li>Generate variables to hold values of old expressions.</li>
<li>Generate new post-conditions using variables generated in point 2.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.set_possible_next_states">
<code class="descname">set_possible_next_states</code><span class="sig-paren">(</span><em>next_states</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.set_possible_next_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.next_states with next_states.
:param next_states: dict from string to string. Keys are names of the next states; values are</p>
<blockquote>
<div>state transition conditions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.short_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in self.state_machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.state_by_name">
<code class="descname">state_by_name</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.state_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the state in all_states with the given name.
:param state_name: string, name of the state to return.
:return: AbstractState.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.strategy_last_bar_so_far">
<code class="descname">strategy_last_bar_so_far</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.strategy_last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.strategy_ohlc">
<code class="descname">strategy_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.strategy_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.strategy_period">
<code class="descname">strategy_period</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.strategy_period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.strategy_period_kind">
<code class="descname">strategy_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.strategy_period_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.transit">
<code class="descname">transit</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.transit" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit to another state or stay at current state by handling input. If no transition should happen,
return the current state, that is, self.
:param inputs: dict from string to objects. inputs carry information from outside of the state machine,</p>
<blockquote>
<div>which is used to trigger state changes.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">State, the new state (if transition occurs) or self if stays.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.state_utils.PlaceMarketOrdersState.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.strategy"></span><dl class="class">
<dt id="ctxalgoctp.ctp.strategy.AbstractOrderCancellation">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.strategy.</code><code class="descname">AbstractOrderCancellation</code><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractOrderCancellation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractOrderCancellation.setup">
<code class="descname">setup</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractOrderCancellation.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup current order cancellation. Should be invoked by the strategy.
:param data: dict{string: object}, the data used to setup current cancellation.</p>
<blockquote>
<div>Different cancellation policy requires different data, check the comment
of the descendant class.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractOrderCancellation.cancel_when_needed">
<code class="descname">cancel_when_needed</code><span class="sig-paren">(</span><em>strategy</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractOrderCancellation.cancel_when_needed" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel the remaining part of the order specified in current class when necessary.
:param strategy: AbstractStrategy. The strategy from which orders are placed and canceled.
:param data: dict{string: object}, some arbitrary data, used by current class to decide</p>
<blockquote>
<div>if cancel should happen. Different cancellation policy will use different kinds of data,
check the comment of the same method in descendant classes.</div></blockquote>
<p>:return bool, True if a cancellation is happened. False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractOrderCancellation.is_time_based">
<code class="descname">is_time_based</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractOrderCancellation.is_time_based" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractOrderCancellation.is_bar_based">
<code class="descname">is_bar_based</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractOrderCancellation.is_bar_based" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.strategy.TimeBasedOrderCancellation">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.strategy.</code><code class="descname">TimeBasedOrderCancellation</code><span class="sig-paren">(</span><em>milliseconds</em>, <em>reason=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.TimeBasedOrderCancellation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.strategy.AbstractOrderCancellation" title="ctxalgoctp.ctp.strategy.AbstractOrderCancellation"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.strategy.AbstractOrderCancellation</span></code></a></p>
<p>Class that represents order cancellation that is based on time. This means that
if an order has not been fully executed in a given period of time, the pending
part of the order will be canceled.</p>
<dl class="docutils">
<dt>Note: about the timing of cancellation, see the comment for</dt>
<dd>the milliseconds parameter in the __init__ method.</dd>
</dl>
<p>Initialize current.
:param milliseconds: int, the time in milliseconds to wait for the order to execute.</p>
<blockquote>
<div>After this milliseconds period of time, the pending part of the order will be canceled.
This means if after now + timedelta(milliseconds=milliseconds), if the order given by
order_ref has not been fully executed, the remaining part will be canceled.
About the timing for cancellation: the strategy will make sure the cancellation will not happen
before now + timedelta(milliseconds=milliseconds), but it does not garuantee that the
cancellation will happen exactly at now + timedelta(milliseconds=milliseconds). The actual
cancellation timing maybe some time slightly after that.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reason</strong> &#8211; string, the reason to cancel the order.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.TimeBasedOrderCancellation.setup">
<code class="descname">setup</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.TimeBasedOrderCancellation.setup" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> &#8211; dict{string: object}, the data used to setup current cancellation. Required entries are:
&#8216;order_ref&#8217;: string, the full order reference.
&#8216;order_start_time&#8217;: datetime, the timestamp when the order is placed.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.TimeBasedOrderCancellation.cancel_when_needed">
<code class="descname">cancel_when_needed</code><span class="sig-paren">(</span><em>strategy</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.TimeBasedOrderCancellation.cancel_when_needed" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> &#8211; dict{string: object}, the data that is used by current cancellation policy
to decide whether an order cancellation should happen.
data should contain the following information:
&#8216;timestamp&#8217;: datetime, the current timestamp.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.TimeBasedOrderCancellation.is_time_based">
<code class="descname">is_time_based</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.TimeBasedOrderCancellation.is_time_based" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.TimeBasedOrderCancellation.is_bar_based">
<code class="descname">is_bar_based</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.TimeBasedOrderCancellation.is_bar_based" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.strategy.BarBasedOrderCancellation">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.strategy.</code><code class="descname">BarBasedOrderCancellation</code><span class="sig-paren">(</span><em>ohlc_kind='time-based'</em>, <em>period=None</em>, <em>bar_count=1</em>, <em>reason=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.BarBasedOrderCancellation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.strategy.AbstractOrderCancellation" title="ctxalgoctp.ctp.strategy.AbstractOrderCancellation"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.strategy.AbstractOrderCancellation</span></code></a></p>
<p>Bar-based order cancellation. The idea is that after placing an order, if when the next one or more ohlc bar
with certain periodicity arrive and the order has not been fully executed, the remaining of the order
is cancelled.</p>
<p>Initialize current.
:param ohlc_kind: string, the ohlc bar kind, valid values are &#8216;time-based&#8217;, &#8216;volatility-based&#8217; from</p>
<blockquote>
<div>OhlcGeneratorConstants.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>period</strong> &#8211; Periodicity or int/float, if ohlc_kind is time-based, the period of the ohlc bars
of the traded instrument that current will be waiting for. If None, the strategy_period of
the strategy will be used. If ohlc_kind is volatility-based, the volatility thresholds.
Cannot be None in this case.</li>
<li><strong>bar_count</strong> &#8211; int, the number of bars to wait for. If bar_count=1, when the next bar of
given period on the traded instrument arrives, the order will be cancelled (if it is not fully
traded yet). If bar_count=x, when the next x bar arrives, the order will be cancelled.</li>
<li><strong>reason</strong> &#8211; string, the reason for cancelling the order.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.BarBasedOrderCancellation.setup">
<code class="descname">setup</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.BarBasedOrderCancellation.setup" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> &#8211; dict{string: object}, the data that is used by current cancellation policy
to decide whether an order cancellation should happen.
data should contain the following information:
&#8216;instrument_id&#8217;: string, the instrument that is traded.
&#8216;order_ref&#8217;: string, the reference of the order.
&#8216;strategy&#8217;: AbstractStrategy, the strategy itself.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.BarBasedOrderCancellation.cancel_when_needed">
<code class="descname">cancel_when_needed</code><span class="sig-paren">(</span><em>strategy</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.BarBasedOrderCancellation.cancel_when_needed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.BarBasedOrderCancellation.is_bar_based">
<code class="descname">is_bar_based</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.BarBasedOrderCancellation.is_bar_based" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.BarBasedOrderCancellation.is_time_based">
<code class="descname">is_time_based</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.BarBasedOrderCancellation.is_time_based" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.strategy.StrategyUtils">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.strategy.</code><code class="descname">StrategyUtils</code><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyUtils" title="Permalink to this definition">¶</a></dt>
<dd><dl class="staticmethod">
<dt id="ctxalgoctp.ctp.strategy.StrategyUtils.get_logger">
<em class="property">static </em><code class="descname">get_logger</code><span class="sig-paren">(</span><em>folder</em>, <em>has_console=True</em>, <em>has_file=True</em>, <em>log_file_name='output.txt'</em>, <em>has_binary_file=False</em>, <em>binary_file_name='output.bin'</em>, <em>queue_address=None</em>, <em>queue_context=None</em>, <em>cache_size=100</em>, <em>compact_mode=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyUtils.get_logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a logger with two handlers, one for console and one for file.
:param folder: string, the folder to store the file log.
:param has_console: boolean, True if the console logger is enabled.
:param has_file: boolean, True if the file logger is enabled.
:param log_file_name: string, the name of the log file. Only have effect when has_file is True.
:param has_binary_file: bool, True if a binary file logger is enabled.
:param binary_file_name: string, the path to the binary file.
:param queue_address: string, the network address to connect to a queued broker.
:param cache_size: int, the cache size indicating how many log messages to store in memory</p>
<blockquote>
<div>before writing them to file.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>compact_mode</strong> &#8211; bool, if True, file based loggers are configured to generate compact logs,
which will reduce the size of the log file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Logger.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.strategy.StrategyUtils.remove_log_file">
<em class="property">static </em><code class="descname">remove_log_file</code><span class="sig-paren">(</span><em>folder</em>, <em>log_file_name='output.txt'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyUtils.remove_log_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the log file if it exists.
:param folder: string, the folder where the log file should appear.
:param log_file_name: string, the log file name.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.strategy.StrategyUtils.close_logger">
<em class="property">static </em><code class="descname">close_logger</code><span class="sig-paren">(</span><em>logger</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyUtils.close_logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the logger.
:param logger: logger.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.strategy.StrategyUtils.flush_logger">
<em class="property">static </em><code class="descname">flush_logger</code><span class="sig-paren">(</span><em>logger</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyUtils.flush_logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush all handlers in the logger.
:param logger: Logger.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.strategy.StrategyUtils.prepare_ohlc">
<em class="property">static </em><code class="descname">prepare_ohlc</code><span class="sig-paren">(</span><em>jinmofang_data_file</em>, <em>periodicity</em>, <em>base_folder</em>, <em>future_id_prefix='IF'</em>, <em>max_bars=2400</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyUtils.prepare_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform Jinmofang data file into ohlc format and put it in proper location in base_folder.
Note: Only sup
:param jinmofang_data_file: string, Jinmofang data file path.
:param periodicity: Periodicity, the periodicity of the data.
:param base_folder: folder to store transformed data.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.strategy.StrategyUtils.get_subfolders">
<em class="property">static </em><code class="descname">get_subfolders</code><span class="sig-paren">(</span><em>base_folder</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyUtils.get_subfolders" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sub-folders used by current strategy.
:param base_folder: The base folder.
:return: dict from sub-folder types to sub folder paths.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.strategy.StrategyUtils.create_folders">
<em class="property">static </em><code class="descname">create_folders</code><span class="sig-paren">(</span><em>base_folder</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyUtils.create_folders" title="Permalink to this definition">¶</a></dt>
<dd><p>Create folders and subfolders.
Parameters:</p>
<blockquote>
<div>base_folder: string, the base folder path.</div></blockquote>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.strategy.StrategyUtils.deepcopy_config">
<em class="property">static </em><code class="descname">deepcopy_config</code><span class="sig-paren">(</span><em>config</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyUtils.deepcopy_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Deep clone the content of config, and return the cloned object. Treat objects that
should not be cloned (loggers and parameter getters) in a special way, by not cloning them.
Have special treatment for loggers since file loggers cannot be properly cloned.
:param config: dict{string: object}, strategy configuration.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.strategy.StrategyUtils.get_fields">
<em class="property">static </em><code class="descname">get_fields</code><span class="sig-paren">(</span><em>o</em>, <em>normalize_field_name=False</em>, <em>cache=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyUtils.get_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dict containing all the fields from o.
:param o: a structure object.
:param normalize_field_name: bool, if True, normalize field names.
:param cache: dict{string: string}, keys are names to be normalized,</p>
<blockquote>
<div>values are the normalized names. If this cache is available, cache the normalized names
because normalization is expensive.</div></blockquote>
<p>:return dict{string:object} dict representation of o.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.strategy.StrategyUtils.normalize_field_name">
<em class="property">static </em><code class="descname">normalize_field_name</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyUtils.normalize_field_name" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> &#8211; string, the name to normalize.</td>
</tr>
</tbody>
</table>
<p>:return string, normalized name.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.strategy.StrategyUtils.load_json">
<em class="property">static </em><code class="descname">load_json</code><span class="sig-paren">(</span><em>base_folder</em>, <em>file_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyUtils.load_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Load JSON content from file.
:param base_folder: string, the base folder for the strategy.
:param file_name: string, the file name.
:return: dict{string: object}, the content of the context file.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.strategy.StrategyUtils.load_context">
<em class="property">static </em><code class="descname">load_context</code><span class="sig-paren">(</span><em>base_folder</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyUtils.load_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Load strategy context JSON content from file.
:param base_folder: string, the base folder for the strategy.
:return: dict{string: object}, the content of the context file.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.strategy.StrategyUtils.dump_json">
<em class="property">static </em><code class="descname">dump_json</code><span class="sig-paren">(</span><em>base_folder</em>, <em>file_name</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyUtils.dump_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump data into file_name under base_folder.
:param base_folder: string, the path to a folder.
:param file_name: string, the file name inside base_folder.
:param data: dict{string: object}, json data.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.strategy.StrategyUtils.dump_context">
<em class="property">static </em><code class="descname">dump_context</code><span class="sig-paren">(</span><em>base_folder</em>, <em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyUtils.dump_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump data into file_name under base_folder.
:param base_folder: string, the path to a folder.
:param context: dict{string: object}, json data.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.strategy.</code><code class="descname">CallbackBase</code><span class="sig-paren">(</span><em>ctp_factory</em>, <em>base_folder</em>, <em>logger</em>, <em>adaptation_timedelta</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.base.CtpCallBacks" title="ctxalgoctp.ctp.base.CtpCallBacks"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.base.CtpCallBacks</span></code></a></p>
<p>Class that serves as base for all trading related callbacks.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ctp_factory</strong> &#8211; AbstractCtpFactory, this is the factory used to retrieving CTP market and trading
instances. Use its descendant CtpFactoryReal for real trading, and CtpFactoryBacktesting for backtesting.</li>
<li><strong>base_folder</strong> &#8211; <p>string, the folder to store all logs.
There should be three sub-folders in base_folder:</p>
<blockquote>
<div><ol class="arabic">
<li>ctp: used for the real CTP trading interface.</li>
<li>log: used to log all communication between current strategy and the CTP trading interface.</li>
<li>ohlc: used to log all generated ohlc bars in different periodicities.</li>
</ol>
</div></blockquote>
</li>
<li><strong>logger</strong> &#8211; Logger, the logger to generate logs.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.TRADING_NOT_CONNECTED">
<code class="descname">TRADING_NOT_CONNECTED</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.TRADING_NOT_CONNECTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.TRADING_CONNECTED">
<code class="descname">TRADING_CONNECTED</code><em class="property"> = 1</em><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.TRADING_CONNECTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.set_ctp_factory">
<code class="descname">set_ctp_factory</code><span class="sig-paren">(</span><em>ctp_factory</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.set_ctp_factory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.trading_account_id">
<code class="descname">trading_account_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.trading_account_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Current trading account id.
:return: string, the trading account id.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.set_market_and_trading">
<code class="descname">set_market_and_trading</code><span class="sig-paren">(</span><em>market</em>, <em>trading</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.set_market_and_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.set_market">
<code class="descname">set_market</code><span class="sig-paren">(</span><em>market</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.set_market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.set_trading">
<code class="descname">set_trading</code><span class="sig-paren">(</span><em>trading</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.set_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.market">
<code class="descname">market</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.trading">
<code class="descname">trading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.get_datetime_from_string">
<code class="descname">get_datetime_from_string</code><span class="sig-paren">(</span><em>day</em>, <em>time_</em>, <em>milli</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.get_datetime_from_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a datetime object from day, <a href="#id5"><span class="problematic" id="id6">time_</span></a> and milli.
Parameters:</p>
<blockquote>
<div>day: string, a string representation of a date, in format yyyymmdd.
<a href="#id7"><span class="problematic" id="id8">time_</span></a>: string, a string representation of a time, in format HH:MM:SS.
milli: string, a strign representation of milliseconds, in format of an integer.</div></blockquote>
<p>Return: datetime, a parsed datetime object.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.is_trading_connected">
<code class="descname">is_trading_connected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.is_trading_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.log_with_tag">
<code class="descname">log_with_tag</code><span class="sig-paren">(</span><em>tag</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.log_with_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Log data with tag.
:param tag: string, the log message tag indicating the kind of the message, for example, BAR, ORDER, ACCOUNT.
:param data: dict{string: object}, the data to be logged. Keys are data item names, values are data items.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.log_exception">
<code class="descname">log_exception</code><span class="sig-paren">(</span><em>e</em>, <em>tb</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.log_exception" title="Permalink to this definition">¶</a></dt>
<dd><p>Log exception.
:param Exception, the exception object.
:param tb string, the traceback.
:param other_data: dict{string: object}, other kinds of data.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.log_state_transition">
<code class="descname">log_state_transition</code><span class="sig-paren">(</span><em>start_state</em>, <em>end_state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.log_state_transition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.log_trade">
<code class="descname">log_trade</code><span class="sig-paren">(</span><em>trade</em>, <em>extra_info</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.log_trade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.log_investor_position">
<code class="descname">log_investor_position</code><span class="sig-paren">(</span><em>investor_position</em>, <em>timestamp</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.log_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Log investor position.
:param investor_position: The investor position object.
:param is_last: boolean, is the result the last batch.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.log_connect_to_market">
<code class="descname">log_connect_to_market</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.log_connect_to_market" title="Permalink to this definition">¶</a></dt>
<dd><p>Log the action to connect to the market data server.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.log_connect_to_trading">
<code class="descname">log_connect_to_trading</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.log_connect_to_trading" title="Permalink to this definition">¶</a></dt>
<dd><p>Log the action to connect to the trading server.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.log_trading_account">
<code class="descname">log_trading_account</code><span class="sig-paren">(</span><em>account</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.log_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Log trading account.
:param account, the trading account object.
:param is_last: boolean, is the result the last batch.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.log_stop_loss">
<code class="descname">log_stop_loss</code><span class="sig-paren">(</span><em>timestamp</em>, <em>direction</em>, <em>value</em>, <em>transaction_id</em>, <em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.log_stop_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Log stop loss.
Parameters:</p>
<blockquote>
<div><p>timestamp: datetime, the time when the stop loss is calculated.
direction: int, 1 means long stop loss, -1 means short stop loss.
value: float, the stop loss value.
transaction_id: string, transaction id.
name: string, a possible additional name for the stop loss line. This is helpful to</p>
<blockquote>
<div>support multiple stop lines (for example, a close-bar stop loss and an in-bar stop loss)
for the same transaction.</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.log_order_action">
<code class="descname">log_order_action</code><span class="sig-paren">(</span><em>order_ref</em>, <em>order_action</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.log_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.log_err_order_action">
<code class="descname">log_err_order_action</code><span class="sig-paren">(</span><em>order_ref</em>, <em>order_action</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.log_err_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.log_order_insert">
<code class="descname">log_order_insert</code><span class="sig-paren">(</span><em>order_ref</em>, <em>input_order</em>, <em>rsp_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.log_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.log_err_order_insert">
<code class="descname">log_err_order_insert</code><span class="sig-paren">(</span><em>order_ref</em>, <em>input_order</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.log_err_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_trading_connected">
<code class="descname">on_trading_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_trading_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_trading_disconnected">
<code class="descname">on_trading_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_trading_disconnected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_error">
<code class="descname">on_trading_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_market_rsp_error">
<code class="descname">on_market_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_market_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_market_connected">
<code class="descname">on_market_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_market_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_market_disconnected">
<code class="descname">on_market_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_market_disconnected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.now" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.dump_json">
<code class="descname">dump_json</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.dump_json" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_idle_event">
<code class="descname">on_idle_event</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_idle_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when there is no event from the outside.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_market_rtn_depth_market_data">
<code class="descname">on_market_rtn_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_market_rtn_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on market server when receive market data
:param p_api:  c_void_p
:param depth_market_data: CThostFtdcDepthMarketDataField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_mission_control">
<code class="descname">on_mission_control</code><span class="sig-paren">(</span><em>message</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_mission_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when a message from control center is arrived.
:param message: string, the message from the the control center.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_trading_err_rtn_order_action">
<code class="descname">on_trading_err_rtn_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>order_action</em>, <em>res_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_trading_err_rtn_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>如果交易所认为撤单错误。由交易托管系统主动通知客户端，该方法会被调用。
:param p_api: c_void_p
:param order_action: CThostFtdcOrderActionField
:param res_info: CThostFtdcRspInfoField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_trading_err_rtn_order_insert">
<code class="descname">on_trading_err_rtn_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>res_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_trading_err_rtn_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>如果交易所认为报单错误。由交易托管系统主动通知客户端，该方法会被调用。
:param p_api: c_void_p
:param input_order: CThostFtdcInputOrderField
:param res_info: CThostFtdcRspInfoField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_order_action">
<code class="descname">on_trading_rsp_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order_action</em>, <em>res_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>交易托管系统收到撤单指令，如果没有通过参数校验，拒绝接受撤单指令。用户就会收到此消息，其中包含了错误编码和错误消息
:param p_api: c_void_p
:param order_action: CThostFtdcInputOrderActionField
:param res_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_order_insert">
<code class="descname">on_trading_rsp_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>res_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>交易托管系统收到报单指令，如果没有通过参数校验，拒绝接受报单指令。用户就会收到此消息，其中包含了错误编码和错误消息
:param p_api: c_void_p
:param input_order: CThostFtdcInputOrderField
:param res_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_depth_market_data">
<code class="descname">on_trading_rsp_qry_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询行情响应。当客户端发出请求查询行情指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param depth_market_data: CThostFtdcDepthMarketDataField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_instrument">
<code class="descname">on_trading_rsp_qry_instrument</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询合约响应。当客户端发出请求查询合约指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param instrument: CThostFtdcInstrumentField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_instrument_commission_rate">
<code class="descname">on_trading_rsp_qry_instrument_commission_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_commission_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_instrument_commission_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询手续费响应。
:param p_api: c_void_p
:param instrument_commission_rate: CThostFtdcInstrumentCommissionRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_instrument_margin_rate">
<code class="descname">on_trading_rsp_qry_instrument_margin_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_margin_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_instrument_margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询保证金响应。
:param p_api: c_void_p
:param instrument_margin_rate: CThostFtdcInstrumentMarginRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_instrument_order_comm_rate">
<code class="descname">on_trading_rsp_qry_instrument_order_comm_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_order_comm_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_instrument_order_comm_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询下单撤单手续费响应。
:param p_api: c_void_p
:param instrument_order_comm_rate: CThostFtdcInstrumentOrderCommRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_investor_position">
<code class="descname">on_trading_rsp_qry_investor_position</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>投资者持仓查询应答。当客户端发出投资者持仓查询指令后，后交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param investor_position: CThostFtdcInvestorPositionField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_investor_position_detail">
<code class="descname">on_trading_rsp_qry_investor_position_detail</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position_detail</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_investor_position_detail" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询投资者持仓明细响应。当客户端发出请求请求查询投资者持仓明细指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api:c_void_p
:param investor_position_detail: CThostFtdcInvestorPositionDetailField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_order">
<code class="descname">on_trading_rsp_qry_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_order" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询报单响应
:param p_api: c_void_p
:param order: CThostFtdcOrderField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_trade">
<code class="descname">on_trading_rsp_qry_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询成交响应
:param p_api: c_void_p
:param trade: CThostFtdcTradeField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_trading_account">
<code class="descname">on_trading_rsp_qry_trading_account</code><span class="sig-paren">(</span><em>p_api</em>, <em>trading_account</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rsp_qry_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询资金账户响应。当客户端发出请求查询资金账户指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param trading_account: CThostFtdcTradingAccountField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rtn_order">
<code class="descname">on_trading_rtn_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rtn_order" title="Permalink to this definition">¶</a></dt>
<dd><p>报单回报。当客户端进行报单录入、报单操作及其它原因（如部分成交）导致报单状态发生变化时，交易托管系统会主动通知客户端，该方法会被调用。
:param p_api: c_void_p
:param order: CThostFtdcOrderField</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rtn_trade">
<code class="descname">on_trading_rtn_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.CallbackBase.on_trading_rtn_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>成交回报。当发生成交时交易托管系统会通知客户端，该方法会被调用。
:param p_api: c_void_p
:param trade:CThostFtdcTradeField
:return:</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.strategy.</code><code class="descname">AbstractStrategy</code><span class="sig-paren">(</span><em>instrument_ids</em>, <em>parameters</em>, <em>base_folder</em>, <em>strategy_period=None</em>, <em>strategy_period_kind='time-based'</em>, <em>periods=None</em>, <em>description=None</em>, <em>logger=None</em>, <em>strategy_callbacks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.strategy.CallbackBase" title="ctxalgoctp.ctp.strategy.CallbackBase"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.strategy.CallbackBase</span></code></a>, <code class="xref py py-class docutils literal"><span class="pre">ctxalgolib.trading_utils.strategy_queries.AbstractStrategyQueries</span></code>, <code class="xref py py-class docutils literal"><span class="pre">ctxalgolib.trading_utils.strategy_queries.AbstractStrategyCallbacks</span></code></p>
<p>Class that serves as a base for all trading strategy callbacks. The strategy is assumed to be single
future trading strategy. Strategy writes should inherit from this class and redefine different callbacks
to conduct event-based trading strategy.</p>
<p>Initialize current.
:param instrument_ids: [string], the ids of the futures to trade.
:param strategy_period: Periodicity or int/float, the period that the strategy is running.</p>
<blockquote>
<div>If it is not None, then this is the default strategy when accessing queries such as self.ohlc().
strategy_period can be of type Periodicity in case of time-based ohlc, or int/float in case of
volatility-based ohlc.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>strategy_period_kind</strong> &#8211; string, the default strategy period kind, can be &#8216;time-based&#8217; or
&#8216;volatility-based&#8217; from OhlcGeneratorConstants.</li>
<li><strong>parameters</strong> &#8211; <p>dict from string to objects. This dict defines the list of parameters for the strategy,
keys are parameter names, and values are the corresponding parameter.
Some of the predefined parameter names are:</p>
<blockquote>
<div><dl class="docutils">
<dt>close_position_time_delta: int, the number of minutes before market close, used to close all</dt>
<dd>open positions for an intraday trading strategy. For a non-intraday trading strategy,
no need to specify this parameter. No need to provide this in a multi-day strategy.</dd>
<dt>open_position_time_delta: int, the number of minutes before market close, only before this</dt>
<dd>time, you can place an open order. No need to provide this in a multi-day strategy.</dd>
</dl>
</div></blockquote>
</li>
<li><strong>base_folder</strong> &#8211; string, the folder to store log files.</li>
<li><strong>periods</strong> &#8211; [Periodicity], the list of periodicities for which ohlcs are needed.</li>
<li><strong>description</strong> &#8211; <p>dict from string to string. Keys are description labels, values are the the
content of those description labels. There should be three labels:</p>
<blockquote>
<div>&#8216;name&#8217;: name of the strategy. The strategy names should be unique per CTX deployment.
&#8216;product&#8217;: name of the product.
&#8216;description&#8217;: the description of the strategy.
&#8216;url_indicators&#8217;: the indicator used to construct urls for strategy debugging.</div></blockquote>
</li>
<li><strong>logger</strong> &#8211; LoggerHandler (from ctxalgolib.loggers.logger_handlers). Logger to record strategy
execution information. This can be a CompositeLoggerHandler, which contains multiple
loggers. For example, a console logger, a file logger and a zeromq logger.</li>
<li><strong>strategy_callbacks</strong> &#8211; AbstractStrategyCallbacks, if not None, provides external strategy callbacks
which will be invoked when strategy level callbacks happen. It is useful to attach new behavior
to the existing strategy code without change the code itself.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.should_use_remote_account_and_position">
<code class="descname">should_use_remote_account_and_position</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.should_use_remote_account_and_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.set_should_use_remote_account_and_position">
<code class="descname">set_should_use_remote_account_and_position</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.set_should_use_remote_account_and_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_before_run">
<code class="descname">on_before_run</code><span class="sig-paren">(</span><em>strategy</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_before_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.has_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Has current strategy started running&gt;
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.strategy_period_kind">
<code class="descname">strategy_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.strategy_period_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.mission_control">
<code class="descname">mission_control</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.mission_control" title="Permalink to this definition">¶</a></dt>
<dd><p>The mission control. The mission control is set through self.ctp_factory.set_mission_control.
:return: MissionControl. If no mission control is set, return None.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.set_use_mid_ask_bid">
<code class="descname">set_use_mid_ask_bid</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.set_use_mid_ask_bid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.set_strategy_callbacks">
<code class="descname">set_strategy_callbacks</code><span class="sig-paren">(</span><em>callbacks</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.set_strategy_callbacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.strategy_callbacks according to callbacks.
:param callbacks: AbstractStrategyCallbacks, the external strategy callbacks.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.now" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.strategy_period">
<code class="descname">strategy_period</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.strategy_period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.initialize_before_run">
<code class="descname">initialize_before_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.initialize_before_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.add_timer">
<code class="descname">add_timer</code><span class="sig-paren">(</span><em>timer=None</em>, <em>trigger_time=None</em>, <em>timedelta=None</em>, <em>on_time_action=None</em>, <em>start=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.add_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Add timer into current strategy.
:param timer: SimulatedTimer, the timer to add. If None, use trigger_time to create a timer.
:param trigger_time: datetime or time, or string in form of yyyy-mm-dd or yyyy-mm-dd HH:MM:SS, or</p>
<blockquote>
<div>a list of the above types. The time(s) used to create a timer .
If specified, create an alarm timer.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>timedelta</strong> &#8211; timedelta, if specified, create a repeated count down timer.</li>
<li><strong>on_time_action</strong> &#8211; function pointer whose signature is same as self.on_timer.
If not None and there is no on_time_action set in timer, then set this as the callback for timer.
If None and there is no on_time_action in timer, then set self.on_timer into the timer.</li>
<li><strong>start</strong> &#8211; boolean, if True start the timer right away.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return string, the name of the added timer.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.remove_timer">
<code class="descname">remove_timer</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.remove_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the timer with name.
:param name: string, the timer name.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.add_bar_arrival_action">
<code class="descname">add_bar_arrival_action</code><span class="sig-paren">(</span><em>action</em>, <em>period=None</em>, <em>instrument_ids=None</em>, <em>ohlc_kind='time-based'</em>, <em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.add_bar_arrival_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup an action, which will be called when all required ohlc bars have arrived.
For example, if period=Periodicity.HOURLY, and instrument_ids are the list of all the traded instruments,
then action will be called the next time when all hourly bars for the traded instruments have arrived.
:param action: function pointer with the following four parameters:</p>
<blockquote>
<div><p>ohlc_kind: string, the ohlc kind, can be &#8216;time-based&#8217;, &#8216;volatility-based&#8217;.
period: Periodicity in case of time-based ohlc, or int/float as volatility threshold</p>
<blockquote>
<div>in case of volatility-based ohlc.</div></blockquote>
<p>name: string, the bar arrival action name, same as the name parameter specified here.
ohlcs: dict{string: OHLC}, the list of ohlcs, keys are instrument ids, values are the ohlc objects.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>period</strong> &#8211; Periodicity in case of time-based ohlc, or int/float as volatility threshold
in case of volatility-based ohlc. This is the period for the required ohlc bars.
If None, use self.strategy_period().
This will be passed into the action when it is invoked.</li>
<li><strong>instrument_ids</strong> &#8211; [string], the list of instruments whose last ohlc bar of required period must
arrived before action can be invoked. If None, defaults to self.instrument_ids(), which are
the full list of traded instruments.</li>
<li><strong>ohlc_kind</strong> &#8211; string, the ohlc kind, can be &#8216;time-based&#8217;, &#8216;volatility-based&#8217;.
This will be passed into the action when it is invoked.</li>
<li><strong>name</strong> &#8211; string, the bar arrival action name, used to identify different bar arrival requests.
This will be passed into the action when it is invoked.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.remove_bar_arrival_action">
<code class="descname">remove_bar_arrival_action</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.remove_bar_arrival_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the specified bar arrival action.
:param name: string, the bar arrival action name.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.calculate_latest_market_end_time">
<code class="descname">calculate_latest_market_end_time</code><span class="sig-paren">(</span><em>market_periods</em>, <em>now</em>, <em>delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.calculate_latest_market_end_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Given traded instruments and current timestamp, calculate when the market will be closed.
This is used by the strategy infrastructure to decide when to exit strategies: strategies
should terminate after the latest market periods of the traded instrument ends, plus</p>
<blockquote>
<div>a given extra time. This automatic termination only has effect
when self.should_terminate_after_market_close is True.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param:</th><td class="field-body"><p class="first">market_periods, dict{string: [(time, time)]}, keys are instrument ids, values are market periods.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>now</strong> &#8211; datetime, current timestamp.</li>
<li><strong>delta</strong> &#8211; timedelta, some extra amount of time that is added into the traded market periods to allow
the strategy to continue running for some time after the market closes, for example, to do
some bookkeeping work. If None, no extra time is added.</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">datetime, the time when strategies should terminate.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.set_step_action">
<code class="descname">set_step_action</code><span class="sig-paren">(</span><em>action</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.set_step_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.does_indicator_calculator_contain_ohlc_kind">
<code class="descname">does_indicator_calculator_contain_ohlc_kind</code><span class="sig-paren">(</span><em>indicator_calculators</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.does_indicator_calculator_contain_ohlc_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Does indicator_calculators contains ohlc kind information?
:param indicator_calculators:
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.indicator">
<code class="descname">indicator</code><span class="sig-paren">(</span><em>name</em>, <em>kind=None</em>, <em>period=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.indicator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the last calculated value(s) for the given indicator alias.
:param kind: string, kind of the ohlc on which indicators are calculated.</p>
<blockquote>
<div>Valid values are &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.
If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> &#8211; string, name of the indicator.</li>
<li><strong>period</strong> &#8211; Periodicity or int/float, the period of the indicator. If None, use self.strategy_period().
If kind is &#8216;volatility-based&#8217;, type of period is int/float, indicating volatility threshold.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id on which the indicator is calculated.
If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object, indicator result.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_connected">
<code class="descname">on_trading_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_disconnected">
<code class="descname">on_trading_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_disconnected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_market_connected">
<code class="descname">on_market_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_market_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_market_disconnected">
<code class="descname">on_market_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_market_disconnected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_bar">
<code class="descname">on_bar</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>bars</em>, <em>tick</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_bar" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when there is some ohlc bars generated.
:param instrument_id, string, the instrument id of the generated bar(s).
:param bars: dict{string: dict{Periodicity or int/float: Bar}.</p>
<blockquote>
<div>Meaning: dict{ohlc_kind: dict{period or volatility threshold: Bar}
Outer keys are ohlc kind such as &#8216;time-based&#8217;, &#8216;volatility-based&#8217; from OhlcGeneratorConstants.
Outer values are dict from Periodicity to Bar in the case of time-based ohlcs or
dict from int/float to Bar in the case of volatility-based ohlcs.
It may contains more than one bars: a single bar under each periodicity.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tick</strong> &#8211; dict{string: object}, the tick which triggers current ohlc bar(s) generation.
The object has the following keys (non-exhaustive):
timestamp, last_price, volume, ask_price1, ask_volume1, bid_price1, bid_volume1,
pre_open_interest, open_interest. Note that when backtesting, only when the data source is tick level,
tick includes order book information such as ask_price1, bid_price1. Otherwise, those order book
related fields will have default values.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_tick">
<code class="descname">on_tick</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>tick</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when there is some new market data.
Note: When current new data can cause one or more
ohlc bars to be generated, those bars are first generated, meaning that the callback on_bar
will be first invoked with the generated new bars, and then this callback will be invoked.
:param instrument_id: string, instrument id.
:param tick: dict{string: object}, tick data. The object has the following keys (non-exhaustive):</p>
<blockquote>
<div>timestamp, last_price, volume, ask_price1, ask_volume1, bid_price1, bid_volume1,
pre_open_interest, open_interest.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_order">
<code class="descname">on_order</code><span class="sig-paren">(</span><em>order_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when order status changes.
:param order_info: dict, order information. The dict includes the following keys (non-exhaustive):</p>
<blockquote>
<div>instrument_id, order_ref, action (type OrderAction), price, volume, timestamp, transaction_id,
traded_volume, left_volume, reason, order_kind (type OrderKind), status.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trade">
<code class="descname">on_trade</code><span class="sig-paren">(</span><em>trade_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when a trade occurs in the exchange. After an order is placed ,
when (part of) the order is traded, there is a callback to this action.
An order may be executed through several trades, so there may be several invocation
of this action for a single order.
:param trade_info: dict, providing information of the trade.</p>
<blockquote>
<div>Keys (non-exhaustively) include:
instrument_id, slippage, commission, profits, transaction_id, traded_volume, left_volume,
order_ref, current_traded_volume, current_traded_price, action, reason, kind, status.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_order_action">
<code class="descname">on_order_action</code><span class="sig-paren">(</span><em>order_action_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when cancel order is considered to be invalid by front.
:param order_action_info: dict{string: object}, information about the order action.</p>
<blockquote>
<div>Keys (non-exhaustively) include:
broker_id, investor_id, order_ref, action_flag, volume_change, instrument_id, error_id, error_message</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_error_order_action">
<code class="descname">on_error_order_action</code><span class="sig-paren">(</span><em>order_action_error</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_error_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when cancel order is considered to be invalid by the exchange.
:param order_action_error: dict{string: object}. Information about the order action error.</p>
<blockquote>
<div>Keys (non-exhausively) include: instrument_id, order_ref, error_id, error_message, status_message.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_order_insert">
<code class="descname">on_order_insert</code><span class="sig-paren">(</span><em>order_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when insert order is considered to be invalid by front.
:param order_info: dict, order information.</p>
<blockquote>
<div>Keys (non-exhaustively) include:
instrument_id, order_ref, traded_volume, left_volume, status, error_id, error_message.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_err_order_insert">
<code class="descname">on_err_order_insert</code><span class="sig-paren">(</span><em>order_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_err_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoke when insert order is considered to be invalid by the exchange.
:param order_info: dict, order information.</p>
<blockquote>
<div>Keys (non-exhaustively) include:
instrument_id, order_ref, traded_volume, left_volume, status, error_id, error_message</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_account">
<code class="descname">on_trading_account</code><span class="sig-paren">(</span><em>trading_account</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when trading account information arrives, requested by get_trading_account.
:param trading_account: dict{string:object}</p>
<blockquote>
<div>Keys (non-exhaustively) include: balance, available, curr_margin, commission, close_profit.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_investor_position">
<code class="descname">on_investor_position</code><span class="sig-paren">(</span><em>investor_position</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when investor position for a particular future arrived,
requested by get_investor_position.
:param investor_position: dict{string: object}</p>
<blockquote>
<div><dl class="docutils">
<dt>Keys (non-exhaustively) include:</dt>
<dd>instrument_id, volume, direction.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_start">
<code class="descname">on_start</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated. Use on_before_run_actions instead.
The action to be invoked when a new trading_day starts.
Parameters:</p>
<blockquote>
<div>context: dict, can store arbitrary data.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated. Use on_after_run_actions instead.
The action to be invoked when a new trading_day ends.
Parameters:</p>
<blockquote>
<div>context: dict, can store arbitrary data.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_timer">
<code class="descname">on_timer</code><span class="sig-paren">(</span><em>trigger_time</em>, <em>supposed_trigger_time</em>, <em>timer_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when some timer is triggered.
:param trigger_time: datetime, the time when the timer is actually triggered.</p>
<blockquote>
<div>trigger_time and supposed_trigger_time may be different because the timer may be a simulated timer.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>supposed_trigger_time</strong> &#8211; datetime, the time when the timer is supposed to be triggered.</li>
<li><strong>timer_name</strong> &#8211; string, the name of the triggered timer.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.strategy_ohlc">
<code class="descname">strategy_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.strategy_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.last_bar_so_far">
<code class="descname">last_bar_so_far</code><span class="sig-paren">(</span><em>periodicity</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.strategy_last_bar_so_far">
<code class="descname">strategy_last_bar_so_far</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.strategy_last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.safe_instrument_id">
<code class="descname">safe_instrument_id</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.safe_instrument_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the final instrument id.
:param instrument_id: string.
:return: string, the final instrument id.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of current strategy.
:return: string, name of the current strategy.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.product">
<code class="descname">product</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return name of the product to which this strategy belongs.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.data_feed">
<code class="descname">data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.data_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.should_exit">
<code class="descname">should_exit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.should_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Should current strategy exit?
:return: boolean, True if current strategy should exit.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.set_should_exit">
<code class="descname">set_should_exit</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.set_should_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self._should_exit to the given boolean.
:param b: boolean, the value to set self._should_exit.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.open_limit_order">
<code class="descname">open_limit_order</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.open_limit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a limit order at price. Note that for limit orders, there is no support for enforce_one_direction,
because limit orders cannot guarantee that all positions in one direction are fully closed.
The strategy is responsible for maintaining positions in a single direction, if desirable.
:param price: float, the price.
:param volume: int, the volume to open. Positive volume means open long; Negative volume means open short.
:param kind: OrderKind. Distinguish between Normal, FAK, FOK limit orders.
:param reason: string, a reason for the open operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>enforce_one_direction</strong> &#8211; boolean. If True, close existing positions (if any) which are in the
direction opposite to the direction indicated by volume.
For example, if volume &gt; 0 (meaning to open a long position), and if currently, the account holds some
short directions, enforce_one_direction is True will force the strategy to make an order to close
all short positions as well, resulting in two orders: one to close existing short positions, and the
other to open long directions. Note that the strategy will not wait for the first order to fully execute,
it will place two orders at the same time. This is a simplification, and can be improved in the future.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.
If None, no cancellation policy is specified. The cancellation policy does not affect the
order that has to be placed when enforce_one_direction is True.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.close_limit_order">
<code class="descname">close_limit_order</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.close_limit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a limit order at price. Note that for limit orders, there is no support for enforce_one_direction,
because limit orders cannot guarantee that all positions in one direction are fully closed.
The strategy is responsible for maintaining positions in a single direction, if desirable.
:param price: float, the price.
:param volume: int, the volume to open. Positive volume means open long; Negative volume means open short.
:param kind: OrderKind. Distinguish between Normal, FAK, FOK limit orders.
:param reason: string, a reason for the open operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd>may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.open_market_order">
<code class="descname">open_market_order</code><span class="sig-paren">(</span><em>volume</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.open_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Open market order for future_id. If there is only one future in current strategy, you don&#8217;t need to
provide future_id, self.future_id will be used implicitly.
:param volume: int, the volume to open. Positive volume means open long; Negative volume means open short.
:param reason: string, a reason for the open operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>enforce_one_direction</strong> &#8211; boolean. If True, close existing positions (if any) which are in the
direction opposite to the direction indicated by volume.
For example, if volume &gt; 0 (meaning to open a long position), and if currently, the account holds some
short directions, enforce_one_direction is True will force the strategy to make an order to close
all short positions as well, resulting in two orders: one to close existing short positions, and the
other to open long directions. Note that the strategy will not wait for the first order to fully execute,
it will place two orders at the same time. This is a simplification, and can be improved in the future.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.
If None, no cancellation policy is specified. The cancellation policy does not affect the
order that has to be placed when enforce_one_direction is True.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.close_market_order">
<code class="descname">close_market_order</code><span class="sig-paren">(</span><em>volume</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.close_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Close market order for future_id. If there is only one future in current strategy, you don&#8217;t need to
provide future_id, self.future_id will be used implicitly.
:param volume: int, the volume to close. Positive volume means open close; Negative volume means close short.
:param reason: string, a reason for the close operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd>may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.open_position">
<code class="descname">open_position</code><span class="sig-paren">(</span><em>volume</em>, <em>price=None</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.open_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a position for the instrument given by instrument_id.
:param volume: int, the position to open,</p>
<blockquote>
<div>positive number means long position, negative number means short position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>price</strong> &#8211; float, if None, send a market order. If not None, send a limit order at that price.</li>
<li><strong>kind</strong> &#8211; OrderKind, the order kind.</li>
<li><strong>reason</strong> &#8211; string, reason for this open position operation.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
<li><strong>transaction_id</strong> &#8211; string, transaction id.</li>
<li><strong>enforce_one_direction</strong> &#8211; boolean. If True, close existing positions (if any) which are in the
direction opposite to the direction indicated by volume.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.close_position">
<code class="descname">close_position</code><span class="sig-paren">(</span><em>volume</em>, <em>price=None</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.close_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a position for the instrumeent given by instrument_id.
:param price: float, if None, send a market order. If not None, send a limit order at that price.
:param kind: OrderKind, the order kind.
:param reason: string, reason for this open position operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:param transaction_id: string, transaction id.
:param cancellation: AbstractOrderCancellation, the cancellation policy for current order.
:return:</p>
<blockquote>
<div><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.change_position_to">
<code class="descname">change_position_to</code><span class="sig-paren">(</span><em>new_position</em>, <em>price=None</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.change_position_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the position of the given instrument to new_position. If price is given, all underlying orders
are limit orders at that price, otherwise, market orders.
:param new_position: int, the new position for the instrument.
:param price: float, if None, newly placed orders are market orders, otherwise, limit orders.
:param reason: string, the reason for this operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.
:param cancellation: AbstractOrderCancellation, the cancellation policy for current order.</p>
<blockquote>
<div>If None, no cancellation policy is specified.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd>may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.change_positions_to">
<code class="descname">change_positions_to</code><span class="sig-paren">(</span><em>new_positions</em>, <em>prices=None</em>, <em>reason=''</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.change_positions_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Change positions of multiple instruments to their new values.
:param new_positions: dict{string: int}, keys are instrument ids,</p>
<blockquote>
<div>values are the new positions for those instruments.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>prices</strong> &#8211; dict{string: float}, keys are instrument ids,
values are prices at which limit orders are placed. If prices is None, all orders are market orders.
If prices is a dict and for some instrument (through dict keys), the key is missing or the value
is None, then the orders for that instrument are market orders, otherwise, limit orders.</li>
<li><strong>reason</strong> &#8211; string, the reason for current order(s).</li>
<li><strong>transaction_id</strong> &#8211; string, transition id, set to None.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the order cancellation policy used to
cancel all the placed orders.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.cancel_order">
<code class="descname">cancel_order</code><span class="sig-paren">(</span><em>order_ref</em>, <em>reason=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.cancel_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel order.
:param order_ref: string, the order reference.
:param reason: string, the reason for cancelling the order.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.place_market_order">
<code class="descname">place_market_order</code><span class="sig-paren">(</span><em>action</em>, <em>volume</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.place_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>make market order for instrument id.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param action: OrderAction, the action kind of current order.
:param volume: int, the volume to close. Positive volume means open close; Negative volume means close short.
:param reason: string, a reason for the close operation.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.
:param enforce_one_direction: boolean. If True, close existing positions (if any) which are in the</p>
<blockquote>
<div>direction opposite to the direction indicated by volume.
For example, if volume &gt; 0 (meaning to open a long position), and if currently, the account holds some
short directions, enforce_one_direction is True will force the strategy to make an order to close
all short positions as well, resulting in two orders: one to close existing short positions, and the
other to open long directions. Note that the strategy will not wait for the first order to fully execute,
it will place two orders at the same time. This is a simplification, and can be improved in the future.</div></blockquote>
<dl class="docutils">
<dt>:return:f</dt>
<dd><dl class="first last docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.get_trading_account">
<code class="descname">get_trading_account</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.get_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a request for trading account information.
The returned information will be accessible through the corresponding callback function.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.get_order">
<code class="descname">get_order</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.get_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Return order information.
:param order_ref: string, the order reference number returned when placing an order via</p>
<blockquote>
<div>open_market_order, open_limit_order, close_market_order or close_limit_order.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}. The order object. None if no order if found by order_ref.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.get_order_status">
<code class="descname">get_order_status</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.get_order_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the status of an order.
:param order_ref: string, the order reference number returned when placing an order via</p>
<blockquote>
<div>open_market_order, open_limit_order, close_market_order or close_limit_order.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">OrderStatus. The status of the order. None if no order is found by order_ref.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.send_message">
<code class="descname">send_message</code><span class="sig-paren">(</span><em>message</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.send_message" title="Permalink to this definition">¶</a></dt>
<dd><p>Send message using self.message_sender.
:param message: string, the message to send.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.get_investor_position">
<code class="descname">get_investor_position</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.get_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a request for investor position for the given future.
:param instrument_id: string, instrument id. If an empty string, then get</p>
<blockquote>
<div>positions for all the held instruments.</div></blockquote>
<p>The returned information will be accessible through the corresponding callback function.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_ohlc">
<code class="descname">log_ohlc</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>bars</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Log ohlc.
:param instrument_id: string, the instrument id.
:param bars: dict{string: dict{Periodicity or int/float: Bar}} The bars.</p>
<blockquote>
<div>Outer keys are ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.
Inner keys are Periodicity or volatility thresholds, inner values are the generated bars.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_order">
<code class="descname">log_order</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>action</em>, <em>volume</em>, <em>order_ref</em>, <em>reason</em>, <em>transaction_id</em>, <em>order_kind='Market'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Log order.
:param instrument_id: string, the instrument id.
:param action: OrderAction, the action of this order.
:param volume: int, volume to trade.</p>
<blockquote>
<div>Positive volume means long position, negative volume means short position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>order_ref</strong> &#8211; int, order reference.</li>
<li><strong>reason</strong> &#8211; string the reason for order.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param transaction_id, int, the transaction id.
:param order_kind: OrderKind. The kind of the order.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_cancel_order">
<code class="descname">log_cancel_order</code><span class="sig-paren">(</span><em>order_ref_id</em>, <em>order_ref</em>, <em>reason</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_cancel_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Log cancel order.
:param order_ref: string, order reference.
:param reason: string, the reason for order.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_rtn_order">
<code class="descname">log_rtn_order</code><span class="sig-paren">(</span><em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_rtn_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_signal">
<code class="descname">log_signal</code><span class="sig-paren">(</span><em>signal</em>, <em>tag=None</em>, <em>reason=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Log signal.
:param signal: EntrySignal, the signal to log.
:param tag: string, the tag to use, if None, the method will decide a tag name.
:param reason: string, some additional reason. Can be None if there is no reason.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_strategy">
<code class="descname">log_strategy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_strategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Log information about current strategy.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_strategy_info">
<code class="descname">log_strategy_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_strategy_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.store_ohlcs">
<code class="descname">store_ohlcs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.store_ohlcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Store OHLCS for all instruments, all registered periods into files.
Only needed in real-trading mode.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.setup_order_cancellations">
<code class="descname">setup_order_cancellations</code><span class="sig-paren">(</span><em>order_ref</em>, <em>order_place_time</em>, <em>instrument_id</em>, <em>cancellation</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.setup_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup order cancellation.
:param order_ref: string, full order reference.
:param order_place_time: datetime, the time when the order is placed.
:param instrument_id: string, the instrument to trade.
:param cancellation: AbstractOrderCancellation, order cancellation policy.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.remove_order_cancellations">
<code class="descname">remove_order_cancellations</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.remove_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove order cancellations.
:param order_ref: string, full order reference.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_order_action">
<code class="descname">on_trading_rsp_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order_action</em>, <em>res_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_err_rtn_order_action">
<code class="descname">on_trading_err_rtn_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>order_action</em>, <em>res_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_err_rtn_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_order_insert">
<code class="descname">on_trading_rsp_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>res_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_err_rtn_order_insert">
<code class="descname">on_trading_err_rtn_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>res_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_err_rtn_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_market_rtn_depth_market_data">
<code class="descname">on_market_rtn_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em>, <em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_market_rtn_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Note: on_* methods which inherits from CtpCallbacks cannot have their parameters renamed.
Parameters:</p>
<blockquote>
<div>p_api: a Python object wrapper for a C pointer, do not need to care.
depth_market_data: CThostFtdcDepthMarketDataField, the data received from CTP market server.
timestamp: datetime, this parameter will be set only in backtesting to avoid parsing time from string.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_investor_position">
<code class="descname">on_trading_rsp_qry_investor_position</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>b_is_last</strong> &#8211; boolean, True if current information is the last from a possibly list of
information about the requested investor position. One piece of information is returned
for one position direction. If there is positions for both long and short trades for the asked future,
then this callback will be invoked twice, once for each position direction.
This callback will be invoked at most twice for an investor position request.</td>
</tr>
</tbody>
</table>
<p>Note: on_* methods which inherits from CtpCallbacks cannot have their parameters renamed.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_trading_account">
<code class="descname">on_trading_rsp_qry_trading_account</code><span class="sig-paren">(</span><em>p_api</em>, <em>trading_account</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>b_is_last</strong> &#8211; boolean, True if current information is the last from a possibly list of
information about trading account. Normally, there should be only one piece of information
about a trading account. In case the account has multiple currencies (RMB, USD, GDP), there will be
multiple pieces of information, one piece for each currency.</td>
</tr>
</tbody>
</table>
<p>Note: on_* methods which inherits from CtpCallbacks cannot have their parameters renamed.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_error">
<code class="descname">on_trading_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_market_rsp_error">
<code class="descname">on_market_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_market_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_idle_event">
<code class="descname">on_idle_event</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_idle_event" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.check_timers">
<code class="descname">check_timers</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.check_timers" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if there are some timers that can be triggered by the given timestamp now.
If so, call self.on_timer.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.check_time_based_order_cancellations">
<code class="descname">check_time_based_order_cancellations</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.check_time_based_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if there are some order cancellation that should be triggered by the given timestamp now.
If so, cancel those orders.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.check_bar_based_order_cancellations">
<code class="descname">check_bar_based_order_cancellations</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>bars</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.check_bar_based_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.check_order_cancellations">
<code class="descname">check_order_cancellations</code><span class="sig-paren">(</span><em>cancellations</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.check_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if we should cancel some orders because of previously setup order cancellations.
:param cancellations: [AbstractOrderCancellation], the list of order cancellations.
:param data: dict{string: object}, the data needed by order cancellations to decide</p>
<blockquote>
<div>whether pending orders should be cancelled. Different kinds of order cancellations
need different data.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rtn_order">
<code class="descname">on_trading_rtn_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rtn_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rtn_trade">
<code class="descname">on_trading_rtn_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rtn_trade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_bar_from_zmq">
<code class="descname">on_bar_from_zmq</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_bar_from_zmq" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when there is a bar arrives from zeromq bar feed.
:param data: dict{string: object}, the bar information.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.delete_context_file">
<code class="descname">delete_context_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.delete_context_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the context.txt file.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.TRADING_CONNECTED">
<code class="descname">TRADING_CONNECTED</code><em class="property"> = 1</em><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.TRADING_CONNECTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.TRADING_NOT_CONNECTED">
<code class="descname">TRADING_NOT_CONNECTED</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.TRADING_NOT_CONNECTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd><p>Return position details for all traded instruments.
:return: dict{string: dict{string: [dict{string: object}]}}</p>
<blockquote>
<div><p>The out most keys are instrument ides, and the values are the same as the result of self.position_details.
For example:
{</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;IF99&#8217;: {</dt>
<dd><dl class="first last docutils">
<dt>&#8216;long&#8217;: [</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>{</dt>
<dd>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</dd>
</dl>
<p>}, ...</p>
</div></blockquote>
<p class="last">],</p>
</dd>
<dt>&#8216;short&#8217;: [</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>{</dt>
<dd>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</dd>
</dl>
<p>}, ...</p>
</div></blockquote>
<p class="last">],</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.dominant_instrument">
<code class="descname">dominant_instrument</code><span class="sig-paren">(</span><em>instrument_prefix</em>, <em>trading_day</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.dominant_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level dominant instrument id on the given trading day.
:param instrument_prefix: string, instrument id prefix, such as IF, cu.
:param trading_day: date, or string in form of yyyy-mm-dd. trading day.
:param level: int, 0 means the dominant contract, 1 means the next dominant contract, and so on.
:return: string, the instrument id of the asked dominant contract.</p>
<blockquote>
<div>If no such dominant contract, return None.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.dump_json">
<code class="descname">dump_json</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.dump_json" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.get_datetime_from_string">
<code class="descname">get_datetime_from_string</code><span class="sig-paren">(</span><em>day</em>, <em>time_</em>, <em>milli</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.get_datetime_from_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a datetime object from day, <a href="#id9"><span class="problematic" id="id10">time_</span></a> and milli.
Parameters:</p>
<blockquote>
<div>day: string, a string representation of a date, in format yyyymmdd.
<a href="#id11"><span class="problematic" id="id12">time_</span></a>: string, a string representation of a time, in format HH:MM:SS.
milli: string, a strign representation of milliseconds, in format of an integer.</div></blockquote>
<p>Return: datetime, a parsed datetime object.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.has_data_feed">
<code class="descname">has_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.has_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is data feed set?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.is_trading_connected">
<code class="descname">is_trading_connected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.is_trading_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_connect_to_market">
<code class="descname">log_connect_to_market</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_connect_to_market" title="Permalink to this definition">¶</a></dt>
<dd><p>Log the action to connect to the market data server.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_connect_to_trading">
<code class="descname">log_connect_to_trading</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_connect_to_trading" title="Permalink to this definition">¶</a></dt>
<dd><p>Log the action to connect to the trading server.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_err_order_action">
<code class="descname">log_err_order_action</code><span class="sig-paren">(</span><em>order_ref</em>, <em>order_action</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_err_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_err_order_insert">
<code class="descname">log_err_order_insert</code><span class="sig-paren">(</span><em>order_ref</em>, <em>input_order</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_err_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_exception">
<code class="descname">log_exception</code><span class="sig-paren">(</span><em>e</em>, <em>tb</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_exception" title="Permalink to this definition">¶</a></dt>
<dd><p>Log exception.
:param Exception, the exception object.
:param tb string, the traceback.
:param other_data: dict{string: object}, other kinds of data.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_investor_position">
<code class="descname">log_investor_position</code><span class="sig-paren">(</span><em>investor_position</em>, <em>timestamp</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Log investor position.
:param investor_position: The investor position object.
:param is_last: boolean, is the result the last batch.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_order_action">
<code class="descname">log_order_action</code><span class="sig-paren">(</span><em>order_ref</em>, <em>order_action</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_order_insert">
<code class="descname">log_order_insert</code><span class="sig-paren">(</span><em>order_ref</em>, <em>input_order</em>, <em>rsp_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_state_transition">
<code class="descname">log_state_transition</code><span class="sig-paren">(</span><em>start_state</em>, <em>end_state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_state_transition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_stop_loss">
<code class="descname">log_stop_loss</code><span class="sig-paren">(</span><em>timestamp</em>, <em>direction</em>, <em>value</em>, <em>transaction_id</em>, <em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_stop_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Log stop loss.
Parameters:</p>
<blockquote>
<div><p>timestamp: datetime, the time when the stop loss is calculated.
direction: int, 1 means long stop loss, -1 means short stop loss.
value: float, the stop loss value.
transaction_id: string, transaction id.
name: string, a possible additional name for the stop loss line. This is helpful to</p>
<blockquote>
<div>support multiple stop lines (for example, a close-bar stop loss and an in-bar stop loss)
for the same transaction.</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_trade">
<code class="descname">log_trade</code><span class="sig-paren">(</span><em>trade</em>, <em>extra_info</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_trade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_trading_account">
<code class="descname">log_trading_account</code><span class="sig-paren">(</span><em>account</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Log trading account.
:param account, the trading account object.
:param is_last: boolean, is the result the last batch.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.log_with_tag">
<code class="descname">log_with_tag</code><span class="sig-paren">(</span><em>tag</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.log_with_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Log data with tag.
:param tag: string, the log message tag indicating the kind of the message, for example, BAR, ORDER, ACCOUNT.
:param data: dict{string: object}, the data to be logged. Keys are data item names, values are data items.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.long_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return long positions for future_id.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: int, the long position, positive value or zero.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.market">
<code class="descname">market</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_bar_method">
<code class="descname">on_bar_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_bar_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the function pointer for on_bar.
:return: function pointer.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_mission_control">
<code class="descname">on_mission_control</code><span class="sig-paren">(</span><em>message</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_mission_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when a message from control center is arrived.
:param message: string, the message from the the control center.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_depth_market_data">
<code class="descname">on_trading_rsp_qry_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询行情响应。当客户端发出请求查询行情指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param depth_market_data: CThostFtdcDepthMarketDataField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_instrument">
<code class="descname">on_trading_rsp_qry_instrument</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询合约响应。当客户端发出请求查询合约指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param instrument: CThostFtdcInstrumentField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_instrument_commission_rate">
<code class="descname">on_trading_rsp_qry_instrument_commission_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_commission_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_instrument_commission_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询手续费响应。
:param p_api: c_void_p
:param instrument_commission_rate: CThostFtdcInstrumentCommissionRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_instrument_margin_rate">
<code class="descname">on_trading_rsp_qry_instrument_margin_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_margin_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_instrument_margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询保证金响应。
:param p_api: c_void_p
:param instrument_margin_rate: CThostFtdcInstrumentMarginRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_instrument_order_comm_rate">
<code class="descname">on_trading_rsp_qry_instrument_order_comm_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_order_comm_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_instrument_order_comm_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询下单撤单手续费响应。
:param p_api: c_void_p
:param instrument_order_comm_rate: CThostFtdcInstrumentOrderCommRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_investor_position_detail">
<code class="descname">on_trading_rsp_qry_investor_position_detail</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position_detail</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_investor_position_detail" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询投资者持仓明细响应。当客户端发出请求请求查询投资者持仓明细指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api:c_void_p
:param investor_position_detail: CThostFtdcInvestorPositionDetailField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_order">
<code class="descname">on_trading_rsp_qry_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_order" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询报单响应
:param p_api: c_void_p
:param order: CThostFtdcOrderField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_trade">
<code class="descname">on_trading_rsp_qry_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.on_trading_rsp_qry_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询成交响应
:param p_api: c_void_p
:param trade: CThostFtdcTradeField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.set_all_callbacks">
<code class="descname">set_all_callbacks</code><span class="sig-paren">(</span><em>all_callbacks</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.set_all_callbacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.all_callbacks to all_callbacks.
:param all_callbacks: OrderedDict{string: AbstractStrategyCallbacks},</p>
<blockquote>
<div>The set of individual strategy callbacks. Keys are strategy callback names,
values are callbacks. Note that it is an ordered dict. So when callbacks are invoked,
they follow the order that is given here. The callback names are useful to find
corresponding strategy callbacks from outside.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.set_ctp_factory">
<code class="descname">set_ctp_factory</code><span class="sig-paren">(</span><em>ctp_factory</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.set_ctp_factory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.set_market">
<code class="descname">set_market</code><span class="sig-paren">(</span><em>market</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.set_market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.set_market_and_trading">
<code class="descname">set_market_and_trading</code><span class="sig-paren">(</span><em>market</em>, <em>trading</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.set_market_and_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.set_trading">
<code class="descname">set_trading</code><span class="sig-paren">(</span><em>trading</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.set_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.short_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return long positions for future_id.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: int, the short position, negative value or zero.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in stat machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.trading">
<code class="descname">trading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.trading_account_id">
<code class="descname">trading_account_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.trading_account_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Current trading account id.
:return: string, the trading account id.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategy.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategy.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.strategy.</code><code class="descname">AbstractStateBasedStrategy</code><span class="sig-paren">(</span><em>instrument_ids</em>, <em>parameters</em>, <em>base_folder</em>, <em>strategy_period=None</em>, <em>strategy_period_kind='time-based'</em>, <em>periods=None</em>, <em>description=None</em>, <em>logger=None</em>, <em>strategy_callbacks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.strategy.AbstractStrategy" title="ctxalgoctp.ctp.strategy.AbstractStrategy"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.strategy.AbstractStrategy</span></code></a>, <code class="xref py py-class docutils literal"><span class="pre">ctxalgolib.trading_utils.state.StateMachine</span></code></p>
<p>Class that represent a state-based strategy.</p>
<p>Initialize current strategy.
:param instrument_ids: string or [string]. The list of future id(s) to trade.
:param strategy_period: Periodicity, the period under which the strategy is running.
:param parameters: dict from string to object. The parameters for the current strategy. Keys are parameter</p>
<blockquote>
<div>names, and values are the parameter values.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>base_folder</strong> &#8211; string, the folder to store generated logs.</li>
<li><strong>periods</strong> &#8211; [Periodicity], the set of OHLC periodicities that the strategy should generate.
A strategy may require different periodicities. For example, a strategy may look at both 15 minute and
1 hour ohlc bars at the same time. periods lists all the periodicities that are required
by the strategy, and the strategy will receive those ohlc bars during backtesting or real trading.
All traded instruments will have ohlcs in all periods automatically generated.</li>
<li><strong>description</strong> &#8211; <p>dict from string to string. If None, a default description is provided. If not None,
the dict should contain the following three keys:</p>
<blockquote>
<div>name: the name of the strategy.
description: the description of the strategy.
url_indicators: the indicators to include to generate debugging urls. This platform provides a web-based<blockquote>
<div>debugging facility, one can debug the strategy (for example, check the generated signals and reveal
the trade executions), via generated urls. url_indicators includes the information used to generate
such urls. For example, if the strategy relies on a moving average, url_indicators should include
the display of this moving average.</div></blockquote>
</div></blockquote>
</li>
<li><strong>logger</strong> &#8211; Logger, the logger used to generate log. If None, a default one will be used. The default
logger will log backtesting data into a file.</li>
<li><strong>strategy_callbacks</strong> &#8211; AbstractStrategyCallbacks, if not None, provides external strategy callbacks
which will be invoked when strategy level callbacks happen. It is useful to attach new behavior
to the existing strategy code without change the code itself.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_state_transited">
<code class="descname">on_state_transited</code><span class="sig-paren">(</span><em>source_state</em>, <em>target_state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_state_transited" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.TRADING_CONNECTED">
<code class="descname">TRADING_CONNECTED</code><em class="property"> = 1</em><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.TRADING_CONNECTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.TRADING_NOT_CONNECTED">
<code class="descname">TRADING_NOT_CONNECTED</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.TRADING_NOT_CONNECTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.add_bar_arrival_action">
<code class="descname">add_bar_arrival_action</code><span class="sig-paren">(</span><em>action</em>, <em>period=None</em>, <em>instrument_ids=None</em>, <em>ohlc_kind='time-based'</em>, <em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.add_bar_arrival_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup an action, which will be called when all required ohlc bars have arrived.
For example, if period=Periodicity.HOURLY, and instrument_ids are the list of all the traded instruments,
then action will be called the next time when all hourly bars for the traded instruments have arrived.
:param action: function pointer with the following four parameters:</p>
<blockquote>
<div><p>ohlc_kind: string, the ohlc kind, can be &#8216;time-based&#8217;, &#8216;volatility-based&#8217;.
period: Periodicity in case of time-based ohlc, or int/float as volatility threshold</p>
<blockquote>
<div>in case of volatility-based ohlc.</div></blockquote>
<p>name: string, the bar arrival action name, same as the name parameter specified here.
ohlcs: dict{string: OHLC}, the list of ohlcs, keys are instrument ids, values are the ohlc objects.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>period</strong> &#8211; Periodicity in case of time-based ohlc, or int/float as volatility threshold
in case of volatility-based ohlc. This is the period for the required ohlc bars.
If None, use self.strategy_period().
This will be passed into the action when it is invoked.</li>
<li><strong>instrument_ids</strong> &#8211; [string], the list of instruments whose last ohlc bar of required period must
arrived before action can be invoked. If None, defaults to self.instrument_ids(), which are
the full list of traded instruments.</li>
<li><strong>ohlc_kind</strong> &#8211; string, the ohlc kind, can be &#8216;time-based&#8217;, &#8216;volatility-based&#8217;.
This will be passed into the action when it is invoked.</li>
<li><strong>name</strong> &#8211; string, the bar arrival action name, used to identify different bar arrival requests.
This will be passed into the action when it is invoked.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.add_timer">
<code class="descname">add_timer</code><span class="sig-paren">(</span><em>timer=None</em>, <em>trigger_time=None</em>, <em>timedelta=None</em>, <em>on_time_action=None</em>, <em>start=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.add_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Add timer into current strategy.
:param timer: SimulatedTimer, the timer to add. If None, use trigger_time to create a timer.
:param trigger_time: datetime or time, or string in form of yyyy-mm-dd or yyyy-mm-dd HH:MM:SS, or</p>
<blockquote>
<div>a list of the above types. The time(s) used to create a timer .
If specified, create an alarm timer.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>timedelta</strong> &#8211; timedelta, if specified, create a repeated count down timer.</li>
<li><strong>on_time_action</strong> &#8211; function pointer whose signature is same as self.on_timer.
If not None and there is no on_time_action set in timer, then set this as the callback for timer.
If None and there is no on_time_action in timer, then set self.on_timer into the timer.</li>
<li><strong>start</strong> &#8211; boolean, if True start the timer right away.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return string, the name of the added timer.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd><p>Return position details for all traded instruments.
:return: dict{string: dict{string: [dict{string: object}]}}</p>
<blockquote>
<div><p>The out most keys are instrument ides, and the values are the same as the result of self.position_details.
For example:
{</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;IF99&#8217;: {</dt>
<dd><dl class="first last docutils">
<dt>&#8216;long&#8217;: [</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>{</dt>
<dd>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</dd>
</dl>
<p>}, ...</p>
</div></blockquote>
<p class="last">],</p>
</dd>
<dt>&#8216;short&#8217;: [</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>{</dt>
<dd>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</dd>
</dl>
<p>}, ...</p>
</div></blockquote>
<p class="last">],</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.at">
<code class="descname">at</code><span class="sig-paren">(</span><em>state_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.at" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machien at the state given by name?
:param state_name: string, the name of the state.
:return bool, True if state machine is at that state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.calculate_latest_market_end_time">
<code class="descname">calculate_latest_market_end_time</code><span class="sig-paren">(</span><em>market_periods</em>, <em>now</em>, <em>delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.calculate_latest_market_end_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Given traded instruments and current timestamp, calculate when the market will be closed.
This is used by the strategy infrastructure to decide when to exit strategies: strategies
should terminate after the latest market periods of the traded instrument ends, plus</p>
<blockquote>
<div>a given extra time. This automatic termination only has effect
when self.should_terminate_after_market_close is True.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param:</th><td class="field-body"><p class="first">market_periods, dict{string: [(time, time)]}, keys are instrument ids, values are market periods.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>now</strong> &#8211; datetime, current timestamp.</li>
<li><strong>delta</strong> &#8211; timedelta, some extra amount of time that is added into the traded market periods to allow
the strategy to continue running for some time after the market closes, for example, to do
some bookkeeping work. If None, no extra time is added.</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">datetime, the time when strategies should terminate.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.cancel_order">
<code class="descname">cancel_order</code><span class="sig-paren">(</span><em>order_ref</em>, <em>reason=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.cancel_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel order.
:param order_ref: string, the order reference.
:param reason: string, the reason for cancelling the order.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.change_position_to">
<code class="descname">change_position_to</code><span class="sig-paren">(</span><em>new_position</em>, <em>price=None</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.change_position_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the position of the given instrument to new_position. If price is given, all underlying orders
are limit orders at that price, otherwise, market orders.
:param new_position: int, the new position for the instrument.
:param price: float, if None, newly placed orders are market orders, otherwise, limit orders.
:param reason: string, the reason for this operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.
:param cancellation: AbstractOrderCancellation, the cancellation policy for current order.</p>
<blockquote>
<div>If None, no cancellation policy is specified.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd>may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.change_positions_to">
<code class="descname">change_positions_to</code><span class="sig-paren">(</span><em>new_positions</em>, <em>prices=None</em>, <em>reason=''</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.change_positions_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Change positions of multiple instruments to their new values.
:param new_positions: dict{string: int}, keys are instrument ids,</p>
<blockquote>
<div>values are the new positions for those instruments.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>prices</strong> &#8211; dict{string: float}, keys are instrument ids,
values are prices at which limit orders are placed. If prices is None, all orders are market orders.
If prices is a dict and for some instrument (through dict keys), the key is missing or the value
is None, then the orders for that instrument are market orders, otherwise, limit orders.</li>
<li><strong>reason</strong> &#8211; string, the reason for current order(s).</li>
<li><strong>transaction_id</strong> &#8211; string, transition id, set to None.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the order cancellation policy used to
cancel all the placed orders.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.check_bar_based_order_cancellations">
<code class="descname">check_bar_based_order_cancellations</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>bars</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.check_bar_based_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.check_order_cancellations">
<code class="descname">check_order_cancellations</code><span class="sig-paren">(</span><em>cancellations</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.check_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if we should cancel some orders because of previously setup order cancellations.
:param cancellations: [AbstractOrderCancellation], the list of order cancellations.
:param data: dict{string: object}, the data needed by order cancellations to decide</p>
<blockquote>
<div>whether pending orders should be cancelled. Different kinds of order cancellations
need different data.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.check_time_based_order_cancellations">
<code class="descname">check_time_based_order_cancellations</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.check_time_based_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if there are some order cancellation that should be triggered by the given timestamp now.
If so, cancel those orders.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.check_timers">
<code class="descname">check_timers</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.check_timers" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if there are some timers that can be triggered by the given timestamp now.
If so, call self.on_timer.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.close_limit_order">
<code class="descname">close_limit_order</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.close_limit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a limit order at price. Note that for limit orders, there is no support for enforce_one_direction,
because limit orders cannot guarantee that all positions in one direction are fully closed.
The strategy is responsible for maintaining positions in a single direction, if desirable.
:param price: float, the price.
:param volume: int, the volume to open. Positive volume means open long; Negative volume means open short.
:param kind: OrderKind. Distinguish between Normal, FAK, FOK limit orders.
:param reason: string, a reason for the open operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd>may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.close_market_order">
<code class="descname">close_market_order</code><span class="sig-paren">(</span><em>volume</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.close_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Close market order for future_id. If there is only one future in current strategy, you don&#8217;t need to
provide future_id, self.future_id will be used implicitly.
:param volume: int, the volume to close. Positive volume means open close; Negative volume means close short.
:param reason: string, a reason for the close operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd>may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.close_position">
<code class="descname">close_position</code><span class="sig-paren">(</span><em>volume</em>, <em>price=None</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.close_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a position for the instrumeent given by instrument_id.
:param price: float, if None, send a market order. If not None, send a limit order at that price.
:param kind: OrderKind, the order kind.
:param reason: string, reason for this open position operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:param transaction_id: string, transaction id.
:param cancellation: AbstractOrderCancellation, the cancellation policy for current order.
:return:</p>
<blockquote>
<div><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.create_states">
<code class="descname">create_states</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.create_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of states used in current strategy and indicates which is the start state.
:return: (start_state, all_states), start_state is of type AbstractState, it is the start state.</p>
<blockquote>
<div>all_states is of type [AbstractState], it is the full list of states used in current strategy.
start_state must be an element of all_states as well.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.data_feed">
<code class="descname">data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.data_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.delete_context_file">
<code class="descname">delete_context_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.delete_context_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the context.txt file.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.does_indicator_calculator_contain_ohlc_kind">
<code class="descname">does_indicator_calculator_contain_ohlc_kind</code><span class="sig-paren">(</span><em>indicator_calculators</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.does_indicator_calculator_contain_ohlc_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Does indicator_calculators contains ohlc kind information?
:param indicator_calculators:
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.dominant_instrument">
<code class="descname">dominant_instrument</code><span class="sig-paren">(</span><em>instrument_prefix</em>, <em>trading_day</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.dominant_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level dominant instrument id on the given trading day.
:param instrument_prefix: string, instrument id prefix, such as IF, cu.
:param trading_day: date, or string in form of yyyy-mm-dd. trading day.
:param level: int, 0 means the dominant contract, 1 means the next dominant contract, and so on.
:return: string, the instrument id of the asked dominant contract.</p>
<blockquote>
<div>If no such dominant contract, return None.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.dump_json">
<code class="descname">dump_json</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.dump_json" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.enable_contract">
<code class="descname">enable_contract</code><span class="sig-paren">(</span><em>precondition=True</em>, <em>postcondition=True</em>, <em>invariant=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.enable_contract" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or disable contract evaluation.
:param precondition: boolean, whether to enable or disable precondition evaluation.</p>
<blockquote>
<div>None means do not change current precondition evaluation setting.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>postcondition</strong> &#8211; boolean, whether to enable or disable postcondition evaluation.
None means do not change current postcondition evaluation setting.</li>
<li><strong>invariant</strong> &#8211; boolean, whether to enable or disable invariant evaluation.
None means do not change current invariant evaluation setting.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.get_datetime_from_string">
<code class="descname">get_datetime_from_string</code><span class="sig-paren">(</span><em>day</em>, <em>time_</em>, <em>milli</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.get_datetime_from_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a datetime object from day, <a href="#id13"><span class="problematic" id="id14">time_</span></a> and milli.
Parameters:</p>
<blockquote>
<div>day: string, a string representation of a date, in format yyyymmdd.
<a href="#id15"><span class="problematic" id="id16">time_</span></a>: string, a string representation of a time, in format HH:MM:SS.
milli: string, a strign representation of milliseconds, in format of an integer.</div></blockquote>
<p>Return: datetime, a parsed datetime object.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.get_investor_position">
<code class="descname">get_investor_position</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.get_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a request for investor position for the given future.
:param instrument_id: string, instrument id. If an empty string, then get</p>
<blockquote>
<div>positions for all the held instruments.</div></blockquote>
<p>The returned information will be accessible through the corresponding callback function.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.get_order">
<code class="descname">get_order</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.get_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Return order information.
:param order_ref: string, the order reference number returned when placing an order via</p>
<blockquote>
<div>open_market_order, open_limit_order, close_market_order or close_limit_order.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}. The order object. None if no order if found by order_ref.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.get_order_status">
<code class="descname">get_order_status</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.get_order_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the status of an order.
:param order_ref: string, the order reference number returned when placing an order via</p>
<blockquote>
<div>open_market_order, open_limit_order, close_market_order or close_limit_order.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">OrderStatus. The status of the order. None if no order is found by order_ref.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.get_trading_account">
<code class="descname">get_trading_account</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.get_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a request for trading account information.
The returned information will be accessible through the corresponding callback function.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.has_data_feed">
<code class="descname">has_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.has_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is data feed set?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.has_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Has current strategy started running&gt;
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.indicator">
<code class="descname">indicator</code><span class="sig-paren">(</span><em>name</em>, <em>kind=None</em>, <em>period=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.indicator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the last calculated value(s) for the given indicator alias.
:param kind: string, kind of the ohlc on which indicators are calculated.</p>
<blockquote>
<div>Valid values are &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.
If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> &#8211; string, name of the indicator.</li>
<li><strong>period</strong> &#8211; Periodicity or int/float, the period of the indicator. If None, use self.strategy_period().
If kind is &#8216;volatility-based&#8217;, type of period is int/float, indicating volatility threshold.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id on which the indicator is calculated.
If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object, indicator result.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.initialize_before_run">
<code class="descname">initialize_before_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.initialize_before_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.initialize_states">
<code class="descname">initialize_states</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.initialize_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the states used in current strategy.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.is_trading_connected">
<code class="descname">is_trading_connected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.is_trading_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.last_bar_so_far">
<code class="descname">last_bar_so_far</code><span class="sig-paren">(</span><em>periodicity</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_cancel_order">
<code class="descname">log_cancel_order</code><span class="sig-paren">(</span><em>order_ref_id</em>, <em>order_ref</em>, <em>reason</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_cancel_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Log cancel order.
:param order_ref: string, order reference.
:param reason: string, the reason for order.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_connect_to_market">
<code class="descname">log_connect_to_market</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_connect_to_market" title="Permalink to this definition">¶</a></dt>
<dd><p>Log the action to connect to the market data server.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_connect_to_trading">
<code class="descname">log_connect_to_trading</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_connect_to_trading" title="Permalink to this definition">¶</a></dt>
<dd><p>Log the action to connect to the trading server.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_err_order_action">
<code class="descname">log_err_order_action</code><span class="sig-paren">(</span><em>order_ref</em>, <em>order_action</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_err_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_err_order_insert">
<code class="descname">log_err_order_insert</code><span class="sig-paren">(</span><em>order_ref</em>, <em>input_order</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_err_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_exception">
<code class="descname">log_exception</code><span class="sig-paren">(</span><em>e</em>, <em>tb</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_exception" title="Permalink to this definition">¶</a></dt>
<dd><p>Log exception.
:param Exception, the exception object.
:param tb string, the traceback.
:param other_data: dict{string: object}, other kinds of data.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_investor_position">
<code class="descname">log_investor_position</code><span class="sig-paren">(</span><em>investor_position</em>, <em>timestamp</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Log investor position.
:param investor_position: The investor position object.
:param is_last: boolean, is the result the last batch.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_ohlc">
<code class="descname">log_ohlc</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>bars</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Log ohlc.
:param instrument_id: string, the instrument id.
:param bars: dict{string: dict{Periodicity or int/float: Bar}} The bars.</p>
<blockquote>
<div>Outer keys are ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.
Inner keys are Periodicity or volatility thresholds, inner values are the generated bars.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_order">
<code class="descname">log_order</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>action</em>, <em>volume</em>, <em>order_ref</em>, <em>reason</em>, <em>transaction_id</em>, <em>order_kind='Market'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Log order.
:param instrument_id: string, the instrument id.
:param action: OrderAction, the action of this order.
:param volume: int, volume to trade.</p>
<blockquote>
<div>Positive volume means long position, negative volume means short position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>order_ref</strong> &#8211; int, order reference.</li>
<li><strong>reason</strong> &#8211; string the reason for order.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param transaction_id, int, the transaction id.
:param order_kind: OrderKind. The kind of the order.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_order_action">
<code class="descname">log_order_action</code><span class="sig-paren">(</span><em>order_ref</em>, <em>order_action</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_order_insert">
<code class="descname">log_order_insert</code><span class="sig-paren">(</span><em>order_ref</em>, <em>input_order</em>, <em>rsp_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_rtn_order">
<code class="descname">log_rtn_order</code><span class="sig-paren">(</span><em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_rtn_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_signal">
<code class="descname">log_signal</code><span class="sig-paren">(</span><em>signal</em>, <em>tag=None</em>, <em>reason=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Log signal.
:param signal: EntrySignal, the signal to log.
:param tag: string, the tag to use, if None, the method will decide a tag name.
:param reason: string, some additional reason. Can be None if there is no reason.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_state_transition">
<code class="descname">log_state_transition</code><span class="sig-paren">(</span><em>start_state</em>, <em>end_state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_state_transition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_stop_loss">
<code class="descname">log_stop_loss</code><span class="sig-paren">(</span><em>timestamp</em>, <em>direction</em>, <em>value</em>, <em>transaction_id</em>, <em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_stop_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Log stop loss.
Parameters:</p>
<blockquote>
<div><p>timestamp: datetime, the time when the stop loss is calculated.
direction: int, 1 means long stop loss, -1 means short stop loss.
value: float, the stop loss value.
transaction_id: string, transaction id.
name: string, a possible additional name for the stop loss line. This is helpful to</p>
<blockquote>
<div>support multiple stop lines (for example, a close-bar stop loss and an in-bar stop loss)
for the same transaction.</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_strategy">
<code class="descname">log_strategy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_strategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Log information about current strategy.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_strategy_info">
<code class="descname">log_strategy_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_strategy_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_trade">
<code class="descname">log_trade</code><span class="sig-paren">(</span><em>trade</em>, <em>extra_info</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_trade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_trading_account">
<code class="descname">log_trading_account</code><span class="sig-paren">(</span><em>account</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Log trading account.
:param account, the trading account object.
:param is_last: boolean, is the result the last batch.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_with_tag">
<code class="descname">log_with_tag</code><span class="sig-paren">(</span><em>tag</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.log_with_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Log data with tag.
:param tag: string, the log message tag indicating the kind of the message, for example, BAR, ORDER, ACCOUNT.
:param data: dict{string: object}, the data to be logged. Keys are data item names, values are data items.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.long_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return long positions for future_id.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: int, the long position, positive value or zero.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.market">
<code class="descname">market</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.mission_control">
<code class="descname">mission_control</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.mission_control" title="Permalink to this definition">¶</a></dt>
<dd><p>The mission control. The mission control is set through self.ctp_factory.set_mission_control.
:return: MissionControl. If no mission control is set, return None.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.now" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_bar">
<code class="descname">on_bar</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>bars</em>, <em>tick</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_bar" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when there is some ohlc bars generated.
:param instrument_id, string, the instrument id of the generated bar(s).
:param bars: dict{string: dict{Periodicity or int/float: Bar}.</p>
<blockquote>
<div>Meaning: dict{ohlc_kind: dict{period or volatility threshold: Bar}
Outer keys are ohlc kind such as &#8216;time-based&#8217;, &#8216;volatility-based&#8217; from OhlcGeneratorConstants.
Outer values are dict from Periodicity to Bar in the case of time-based ohlcs or
dict from int/float to Bar in the case of volatility-based ohlcs.
It may contains more than one bars: a single bar under each periodicity.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tick</strong> &#8211; dict{string: object}, the tick which triggers current ohlc bar(s) generation.
The object has the following keys (non-exhaustive):
timestamp, last_price, volume, ask_price1, ask_volume1, bid_price1, bid_volume1,
pre_open_interest, open_interest. Note that when backtesting, only when the data source is tick level,
tick includes order book information such as ask_price1, bid_price1. Otherwise, those order book
related fields will have default values.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_bar_from_zmq">
<code class="descname">on_bar_from_zmq</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_bar_from_zmq" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when there is a bar arrives from zeromq bar feed.
:param data: dict{string: object}, the bar information.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_bar_method">
<code class="descname">on_bar_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_bar_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the function pointer for on_bar.
:return: function pointer.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_before_run">
<code class="descname">on_before_run</code><span class="sig-paren">(</span><em>strategy</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_before_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_err_order_insert">
<code class="descname">on_err_order_insert</code><span class="sig-paren">(</span><em>order_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_err_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoke when insert order is considered to be invalid by the exchange.
:param order_info: dict, order information.</p>
<blockquote>
<div>Keys (non-exhaustively) include:
instrument_id, order_ref, traded_volume, left_volume, status, error_id, error_message</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_error_order_action">
<code class="descname">on_error_order_action</code><span class="sig-paren">(</span><em>order_action_error</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_error_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when cancel order is considered to be invalid by the exchange.
:param order_action_error: dict{string: object}. Information about the order action error.</p>
<blockquote>
<div>Keys (non-exhausively) include: instrument_id, order_ref, error_id, error_message, status_message.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated. Use on_after_run_actions instead.
The action to be invoked when a new trading_day ends.
Parameters:</p>
<blockquote>
<div>context: dict, can store arbitrary data.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_idle_event">
<code class="descname">on_idle_event</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_idle_event" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_investor_position">
<code class="descname">on_investor_position</code><span class="sig-paren">(</span><em>investor_position</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when investor position for a particular future arrived,
requested by get_investor_position.
:param investor_position: dict{string: object}</p>
<blockquote>
<div><dl class="docutils">
<dt>Keys (non-exhaustively) include:</dt>
<dd>instrument_id, volume, direction.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_market_connected">
<code class="descname">on_market_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_market_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_market_disconnected">
<code class="descname">on_market_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_market_disconnected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_market_rsp_error">
<code class="descname">on_market_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_market_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_market_rtn_depth_market_data">
<code class="descname">on_market_rtn_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em>, <em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_market_rtn_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Note: on_* methods which inherits from CtpCallbacks cannot have their parameters renamed.
Parameters:</p>
<blockquote>
<div>p_api: a Python object wrapper for a C pointer, do not need to care.
depth_market_data: CThostFtdcDepthMarketDataField, the data received from CTP market server.
timestamp: datetime, this parameter will be set only in backtesting to avoid parsing time from string.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_mission_control">
<code class="descname">on_mission_control</code><span class="sig-paren">(</span><em>message</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_mission_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when a message from control center is arrived.
:param message: string, the message from the the control center.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_order">
<code class="descname">on_order</code><span class="sig-paren">(</span><em>order_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when order status changes.
:param order_info: dict, order information. The dict includes the following keys (non-exhaustive):</p>
<blockquote>
<div>instrument_id, order_ref, action (type OrderAction), price, volume, timestamp, transaction_id,
traded_volume, left_volume, reason, order_kind (type OrderKind), status.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_order_action">
<code class="descname">on_order_action</code><span class="sig-paren">(</span><em>order_action_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when cancel order is considered to be invalid by front.
:param order_action_info: dict{string: object}, information about the order action.</p>
<blockquote>
<div>Keys (non-exhaustively) include:
broker_id, investor_id, order_ref, action_flag, volume_change, instrument_id, error_id, error_message</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_order_insert">
<code class="descname">on_order_insert</code><span class="sig-paren">(</span><em>order_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when insert order is considered to be invalid by front.
:param order_info: dict, order information.</p>
<blockquote>
<div>Keys (non-exhaustively) include:
instrument_id, order_ref, traded_volume, left_volume, status, error_id, error_message.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_start">
<code class="descname">on_start</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated. Use on_before_run_actions instead.
The action to be invoked when a new trading_day starts.
Parameters:</p>
<blockquote>
<div>context: dict, can store arbitrary data.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_tick">
<code class="descname">on_tick</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>tick</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when there is some new market data.
Note: When current new data can cause one or more
ohlc bars to be generated, those bars are first generated, meaning that the callback on_bar
will be first invoked with the generated new bars, and then this callback will be invoked.
:param instrument_id: string, instrument id.
:param tick: dict{string: object}, tick data. The object has the following keys (non-exhaustive):</p>
<blockquote>
<div>timestamp, last_price, volume, ask_price1, ask_volume1, bid_price1, bid_volume1,
pre_open_interest, open_interest.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_timer">
<code class="descname">on_timer</code><span class="sig-paren">(</span><em>trigger_time</em>, <em>supposed_trigger_time</em>, <em>timer_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when some timer is triggered.
:param trigger_time: datetime, the time when the timer is actually triggered.</p>
<blockquote>
<div>trigger_time and supposed_trigger_time may be different because the timer may be a simulated timer.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>supposed_trigger_time</strong> &#8211; datetime, the time when the timer is supposed to be triggered.</li>
<li><strong>timer_name</strong> &#8211; string, the name of the triggered timer.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trade">
<code class="descname">on_trade</code><span class="sig-paren">(</span><em>trade_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when a trade occurs in the exchange. After an order is placed ,
when (part of) the order is traded, there is a callback to this action.
An order may be executed through several trades, so there may be several invocation
of this action for a single order.
:param trade_info: dict, providing information of the trade.</p>
<blockquote>
<div>Keys (non-exhaustively) include:
instrument_id, slippage, commission, profits, transaction_id, traded_volume, left_volume,
order_ref, current_traded_volume, current_traded_price, action, reason, kind, status.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_account">
<code class="descname">on_trading_account</code><span class="sig-paren">(</span><em>trading_account</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when trading account information arrives, requested by get_trading_account.
:param trading_account: dict{string:object}</p>
<blockquote>
<div>Keys (non-exhaustively) include: balance, available, curr_margin, commission, close_profit.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_connected">
<code class="descname">on_trading_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_disconnected">
<code class="descname">on_trading_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_disconnected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_err_rtn_order_action">
<code class="descname">on_trading_err_rtn_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>order_action</em>, <em>res_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_err_rtn_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_err_rtn_order_insert">
<code class="descname">on_trading_err_rtn_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>res_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_err_rtn_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_error">
<code class="descname">on_trading_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_order_action">
<code class="descname">on_trading_rsp_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order_action</em>, <em>res_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_order_insert">
<code class="descname">on_trading_rsp_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>res_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_depth_market_data">
<code class="descname">on_trading_rsp_qry_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询行情响应。当客户端发出请求查询行情指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param depth_market_data: CThostFtdcDepthMarketDataField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_instrument">
<code class="descname">on_trading_rsp_qry_instrument</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询合约响应。当客户端发出请求查询合约指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param instrument: CThostFtdcInstrumentField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_instrument_commission_rate">
<code class="descname">on_trading_rsp_qry_instrument_commission_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_commission_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_instrument_commission_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询手续费响应。
:param p_api: c_void_p
:param instrument_commission_rate: CThostFtdcInstrumentCommissionRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_instrument_margin_rate">
<code class="descname">on_trading_rsp_qry_instrument_margin_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_margin_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_instrument_margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询保证金响应。
:param p_api: c_void_p
:param instrument_margin_rate: CThostFtdcInstrumentMarginRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_instrument_order_comm_rate">
<code class="descname">on_trading_rsp_qry_instrument_order_comm_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_order_comm_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_instrument_order_comm_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询下单撤单手续费响应。
:param p_api: c_void_p
:param instrument_order_comm_rate: CThostFtdcInstrumentOrderCommRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_investor_position">
<code class="descname">on_trading_rsp_qry_investor_position</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>b_is_last</strong> &#8211; boolean, True if current information is the last from a possibly list of
information about the requested investor position. One piece of information is returned
for one position direction. If there is positions for both long and short trades for the asked future,
then this callback will be invoked twice, once for each position direction.
This callback will be invoked at most twice for an investor position request.</td>
</tr>
</tbody>
</table>
<p>Note: on_* methods which inherits from CtpCallbacks cannot have their parameters renamed.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_investor_position_detail">
<code class="descname">on_trading_rsp_qry_investor_position_detail</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position_detail</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_investor_position_detail" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询投资者持仓明细响应。当客户端发出请求请求查询投资者持仓明细指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api:c_void_p
:param investor_position_detail: CThostFtdcInvestorPositionDetailField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_order">
<code class="descname">on_trading_rsp_qry_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_order" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询报单响应
:param p_api: c_void_p
:param order: CThostFtdcOrderField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_trade">
<code class="descname">on_trading_rsp_qry_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询成交响应
:param p_api: c_void_p
:param trade: CThostFtdcTradeField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_trading_account">
<code class="descname">on_trading_rsp_qry_trading_account</code><span class="sig-paren">(</span><em>p_api</em>, <em>trading_account</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rsp_qry_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>b_is_last</strong> &#8211; boolean, True if current information is the last from a possibly list of
information about trading account. Normally, there should be only one piece of information
about a trading account. In case the account has multiple currencies (RMB, USD, GDP), there will be
multiple pieces of information, one piece for each currency.</td>
</tr>
</tbody>
</table>
<p>Note: on_* methods which inherits from CtpCallbacks cannot have their parameters renamed.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rtn_order">
<code class="descname">on_trading_rtn_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rtn_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rtn_trade">
<code class="descname">on_trading_rtn_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.on_trading_rtn_trade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.open_limit_order">
<code class="descname">open_limit_order</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.open_limit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a limit order at price. Note that for limit orders, there is no support for enforce_one_direction,
because limit orders cannot guarantee that all positions in one direction are fully closed.
The strategy is responsible for maintaining positions in a single direction, if desirable.
:param price: float, the price.
:param volume: int, the volume to open. Positive volume means open long; Negative volume means open short.
:param kind: OrderKind. Distinguish between Normal, FAK, FOK limit orders.
:param reason: string, a reason for the open operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>enforce_one_direction</strong> &#8211; boolean. If True, close existing positions (if any) which are in the
direction opposite to the direction indicated by volume.
For example, if volume &gt; 0 (meaning to open a long position), and if currently, the account holds some
short directions, enforce_one_direction is True will force the strategy to make an order to close
all short positions as well, resulting in two orders: one to close existing short positions, and the
other to open long directions. Note that the strategy will not wait for the first order to fully execute,
it will place two orders at the same time. This is a simplification, and can be improved in the future.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.
If None, no cancellation policy is specified. The cancellation policy does not affect the
order that has to be placed when enforce_one_direction is True.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.open_market_order">
<code class="descname">open_market_order</code><span class="sig-paren">(</span><em>volume</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.open_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Open market order for future_id. If there is only one future in current strategy, you don&#8217;t need to
provide future_id, self.future_id will be used implicitly.
:param volume: int, the volume to open. Positive volume means open long; Negative volume means open short.
:param reason: string, a reason for the open operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>enforce_one_direction</strong> &#8211; boolean. If True, close existing positions (if any) which are in the
direction opposite to the direction indicated by volume.
For example, if volume &gt; 0 (meaning to open a long position), and if currently, the account holds some
short directions, enforce_one_direction is True will force the strategy to make an order to close
all short positions as well, resulting in two orders: one to close existing short positions, and the
other to open long directions. Note that the strategy will not wait for the first order to fully execute,
it will place two orders at the same time. This is a simplification, and can be improved in the future.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.
If None, no cancellation policy is specified. The cancellation policy does not affect the
order that has to be placed when enforce_one_direction is True.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.open_position">
<code class="descname">open_position</code><span class="sig-paren">(</span><em>volume</em>, <em>price=None</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.open_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a position for the instrument given by instrument_id.
:param volume: int, the position to open,</p>
<blockquote>
<div>positive number means long position, negative number means short position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>price</strong> &#8211; float, if None, send a market order. If not None, send a limit order at that price.</li>
<li><strong>kind</strong> &#8211; OrderKind, the order kind.</li>
<li><strong>reason</strong> &#8211; string, reason for this open position operation.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
<li><strong>transaction_id</strong> &#8211; string, transaction id.</li>
<li><strong>enforce_one_direction</strong> &#8211; boolean. If True, close existing positions (if any) which are in the
direction opposite to the direction indicated by volume.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.place_market_order">
<code class="descname">place_market_order</code><span class="sig-paren">(</span><em>action</em>, <em>volume</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.place_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>make market order for instrument id.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param action: OrderAction, the action kind of current order.
:param volume: int, the volume to close. Positive volume means open close; Negative volume means close short.
:param reason: string, a reason for the close operation.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.
:param enforce_one_direction: boolean. If True, close existing positions (if any) which are in the</p>
<blockquote>
<div>direction opposite to the direction indicated by volume.
For example, if volume &gt; 0 (meaning to open a long position), and if currently, the account holds some
short directions, enforce_one_direction is True will force the strategy to make an order to close
all short positions as well, resulting in two orders: one to close existing short positions, and the
other to open long directions. Note that the strategy will not wait for the first order to fully execute,
it will place two orders at the same time. This is a simplification, and can be improved in the future.</div></blockquote>
<dl class="docutils">
<dt>:return:f</dt>
<dd><dl class="first last docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.product">
<code class="descname">product</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return name of the product to which this strategy belongs.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.remove_bar_arrival_action">
<code class="descname">remove_bar_arrival_action</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.remove_bar_arrival_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the specified bar arrival action.
:param name: string, the bar arrival action name.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.remove_order_cancellations">
<code class="descname">remove_order_cancellations</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.remove_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove order cancellations.
:param order_ref: string, full order reference.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.remove_timer">
<code class="descname">remove_timer</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.remove_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the timer with name.
:param name: string, the timer name.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.safe_instrument_id">
<code class="descname">safe_instrument_id</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.safe_instrument_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the final instrument id.
:param instrument_id: string.
:return: string, the final instrument id.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.send_message">
<code class="descname">send_message</code><span class="sig-paren">(</span><em>message</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.send_message" title="Permalink to this definition">¶</a></dt>
<dd><p>Send message using self.message_sender.
:param message: string, the message to send.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_all_callbacks">
<code class="descname">set_all_callbacks</code><span class="sig-paren">(</span><em>all_callbacks</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_all_callbacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.all_callbacks to all_callbacks.
:param all_callbacks: OrderedDict{string: AbstractStrategyCallbacks},</p>
<blockquote>
<div>The set of individual strategy callbacks. Keys are strategy callback names,
values are callbacks. Note that it is an ordered dict. So when callbacks are invoked,
they follow the order that is given here. The callback names are useful to find
corresponding strategy callbacks from outside.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_ctp_factory">
<code class="descname">set_ctp_factory</code><span class="sig-paren">(</span><em>ctp_factory</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_ctp_factory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_is_invariant_enabled">
<code class="descname">set_is_invariant_enabled</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_is_invariant_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or display invariant evaluation.
:param b: boolean, True means enable, False means disable.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_is_postcondition_enabled">
<code class="descname">set_is_postcondition_enabled</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_is_postcondition_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or display postcondition evaluation.
:param b: boolean, True means enable, False means disable.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_is_precondition_enabled">
<code class="descname">set_is_precondition_enabled</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_is_precondition_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or display precondition evaluation.
:param b: boolean, True means enable, False means disable.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_market">
<code class="descname">set_market</code><span class="sig-paren">(</span><em>market</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_market_and_trading">
<code class="descname">set_market_and_trading</code><span class="sig-paren">(</span><em>market</em>, <em>trading</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_market_and_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_should_exit">
<code class="descname">set_should_exit</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_should_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self._should_exit to the given boolean.
:param b: boolean, the value to set self._should_exit.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_should_use_remote_account_and_position">
<code class="descname">set_should_use_remote_account_and_position</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_should_use_remote_account_and_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_step_action">
<code class="descname">set_step_action</code><span class="sig-paren">(</span><em>action</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_step_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_strategy_callbacks">
<code class="descname">set_strategy_callbacks</code><span class="sig-paren">(</span><em>callbacks</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_strategy_callbacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.strategy_callbacks according to callbacks.
:param callbacks: AbstractStrategyCallbacks, the external strategy callbacks.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_trading">
<code class="descname">set_trading</code><span class="sig-paren">(</span><em>trading</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_use_mid_ask_bid">
<code class="descname">set_use_mid_ask_bid</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.set_use_mid_ask_bid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.setup_order_cancellations">
<code class="descname">setup_order_cancellations</code><span class="sig-paren">(</span><em>order_ref</em>, <em>order_place_time</em>, <em>instrument_id</em>, <em>cancellation</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.setup_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup order cancellation.
:param order_ref: string, full order reference.
:param order_place_time: datetime, the time when the order is placed.
:param instrument_id: string, the instrument to trade.
:param cancellation: AbstractOrderCancellation, order cancellation policy.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.short_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return long positions for future_id.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: int, the short position, negative value or zero.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.should_exit">
<code class="descname">should_exit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.should_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Should current strategy exit?
:return: boolean, True if current strategy should exit.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.should_use_remote_account_and_position">
<code class="descname">should_use_remote_account_and_position</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.should_use_remote_account_and_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.store_ohlcs">
<code class="descname">store_ohlcs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.store_ohlcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Store OHLCS for all instruments, all registered periods into files.
Only needed in real-trading mode.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.strategy_last_bar_so_far">
<code class="descname">strategy_last_bar_so_far</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.strategy_last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of current strategy.
:return: string, name of the current strategy.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.strategy_ohlc">
<code class="descname">strategy_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.strategy_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.strategy_period">
<code class="descname">strategy_period</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.strategy_period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.strategy_period_kind">
<code class="descname">strategy_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.strategy_period_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.trading">
<code class="descname">trading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.trading_account_id">
<code class="descname">trading_account_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.trading_account_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Current trading account id.
:return: string, the trading account id.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.transit_state">
<code class="descname">transit_state</code><span class="sig-paren">(</span><em>state_inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.transit_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply state_inputs to self._state. This will possibly trigger state transition.
If no state transition occurs, self._state stays the same.
:param state_inputs: Arbitrary data as state transition inputs.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.transit_to_start_state">
<code class="descname">transit_to_start_state</code><span class="sig-paren">(</span><em>data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.transit_to_start_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Transit current state machine to the start_state.
Parameters:</p>
<blockquote>
<div>data: dict from string to objects.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStateBasedStrategy.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.strategy.</code><code class="descname">StrategyInitializerCallbacks</code><span class="sig-paren">(</span><em>ctp_factory</em>, <em>future_ids</em>, <em>base_folder</em>, <em>logger</em>, <em>adaptation_timedelta</em>, <em>should_get_commission_ratio</em>, <em>should_get_order_comm_rate</em>, <em>should_use_remote_instrument_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.strategy.CallbackBase" title="ctxalgoctp.ctp.strategy.CallbackBase"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.strategy.CallbackBase</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ctp_factory</strong> &#8211; </li>
<li><strong>future_ids</strong> &#8211; </li>
<li><strong>base_folder</strong> &#8211; </li>
<li><strong>logger</strong> &#8211; </li>
<li><strong>adaptation_timedelta</strong> &#8211; </li>
<li><strong>should_get_commission_ratio</strong> &#8211; bool, If True, retrieve commission ratio information from CTP.
If False, use values from CTX directly. The CTX values may not be the same as the actual CTP ratios,
because different security companies, and different trading account may have different commission ratio.</li>
<li><strong>should_get_order_comm_rate</strong> &#8211; bool, If True, retrieve order commission rate from CTP, otherwise, don&#8217;t.</li>
<li><strong>should_use_remote_instrument_info</strong> &#8211; bool, True means that the strategy is configured to use
remote positions.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.get_details">
<code class="descname">get_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.get_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.get_info">
<code class="descname">get_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.get_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the retrieved information about the trading account, positions and so on.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.has_details_initialized">
<code class="descname">has_details_initialized</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.has_details_initialized" title="Permalink to this definition">¶</a></dt>
<dd><p>Has the initialization phase finished?
:return: dict{string: object}, if finished, return None, otherwise, the returned dict indicates which</p>
<blockquote>
<div>values are still missing.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_instrument">
<code class="descname">on_trading_rsp_qry_instrument</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_instrument" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_instrument_margin_rate">
<code class="descname">on_trading_rsp_qry_instrument_margin_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_margin_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_instrument_margin_rate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_instrument_commission_rate">
<code class="descname">on_trading_rsp_qry_instrument_commission_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_commission_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_instrument_commission_rate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_instrument_order_comm_rate">
<code class="descname">on_trading_rsp_qry_instrument_order_comm_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_order_comm_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_instrument_order_comm_rate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_trading_account">
<code class="descname">on_trading_rsp_qry_trading_account</code><span class="sig-paren">(</span><em>p_api</em>, <em>trading_account</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_trading_account" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_investor_position">
<code class="descname">on_trading_rsp_qry_investor_position</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_investor_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_market_rtn_depth_market_data">
<code class="descname">on_market_rtn_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em>, <em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_market_rtn_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.TRADING_CONNECTED">
<code class="descname">TRADING_CONNECTED</code><em class="property"> = 1</em><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.TRADING_CONNECTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.TRADING_NOT_CONNECTED">
<code class="descname">TRADING_NOT_CONNECTED</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.TRADING_NOT_CONNECTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.dump_json">
<code class="descname">dump_json</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.dump_json" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.get_datetime_from_string">
<code class="descname">get_datetime_from_string</code><span class="sig-paren">(</span><em>day</em>, <em>time_</em>, <em>milli</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.get_datetime_from_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a datetime object from day, <a href="#id17"><span class="problematic" id="id18">time_</span></a> and milli.
Parameters:</p>
<blockquote>
<div>day: string, a string representation of a date, in format yyyymmdd.
<a href="#id19"><span class="problematic" id="id20">time_</span></a>: string, a string representation of a time, in format HH:MM:SS.
milli: string, a strign representation of milliseconds, in format of an integer.</div></blockquote>
<p>Return: datetime, a parsed datetime object.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.is_trading_connected">
<code class="descname">is_trading_connected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.is_trading_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_connect_to_market">
<code class="descname">log_connect_to_market</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_connect_to_market" title="Permalink to this definition">¶</a></dt>
<dd><p>Log the action to connect to the market data server.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_connect_to_trading">
<code class="descname">log_connect_to_trading</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_connect_to_trading" title="Permalink to this definition">¶</a></dt>
<dd><p>Log the action to connect to the trading server.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_err_order_action">
<code class="descname">log_err_order_action</code><span class="sig-paren">(</span><em>order_ref</em>, <em>order_action</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_err_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_err_order_insert">
<code class="descname">log_err_order_insert</code><span class="sig-paren">(</span><em>order_ref</em>, <em>input_order</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_err_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_exception">
<code class="descname">log_exception</code><span class="sig-paren">(</span><em>e</em>, <em>tb</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_exception" title="Permalink to this definition">¶</a></dt>
<dd><p>Log exception.
:param Exception, the exception object.
:param tb string, the traceback.
:param other_data: dict{string: object}, other kinds of data.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_investor_position">
<code class="descname">log_investor_position</code><span class="sig-paren">(</span><em>investor_position</em>, <em>timestamp</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Log investor position.
:param investor_position: The investor position object.
:param is_last: boolean, is the result the last batch.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_order_action">
<code class="descname">log_order_action</code><span class="sig-paren">(</span><em>order_ref</em>, <em>order_action</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_order_insert">
<code class="descname">log_order_insert</code><span class="sig-paren">(</span><em>order_ref</em>, <em>input_order</em>, <em>rsp_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_state_transition">
<code class="descname">log_state_transition</code><span class="sig-paren">(</span><em>start_state</em>, <em>end_state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_state_transition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_stop_loss">
<code class="descname">log_stop_loss</code><span class="sig-paren">(</span><em>timestamp</em>, <em>direction</em>, <em>value</em>, <em>transaction_id</em>, <em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_stop_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Log stop loss.
Parameters:</p>
<blockquote>
<div><p>timestamp: datetime, the time when the stop loss is calculated.
direction: int, 1 means long stop loss, -1 means short stop loss.
value: float, the stop loss value.
transaction_id: string, transaction id.
name: string, a possible additional name for the stop loss line. This is helpful to</p>
<blockquote>
<div>support multiple stop lines (for example, a close-bar stop loss and an in-bar stop loss)
for the same transaction.</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_trade">
<code class="descname">log_trade</code><span class="sig-paren">(</span><em>trade</em>, <em>extra_info</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_trade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_trading_account">
<code class="descname">log_trading_account</code><span class="sig-paren">(</span><em>account</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Log trading account.
:param account, the trading account object.
:param is_last: boolean, is the result the last batch.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_with_tag">
<code class="descname">log_with_tag</code><span class="sig-paren">(</span><em>tag</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.log_with_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Log data with tag.
:param tag: string, the log message tag indicating the kind of the message, for example, BAR, ORDER, ACCOUNT.
:param data: dict{string: object}, the data to be logged. Keys are data item names, values are data items.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.market">
<code class="descname">market</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.now" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_idle_event">
<code class="descname">on_idle_event</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_idle_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when there is no event from the outside.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_market_connected">
<code class="descname">on_market_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_market_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_market_disconnected">
<code class="descname">on_market_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_market_disconnected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_market_rsp_error">
<code class="descname">on_market_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_market_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_mission_control">
<code class="descname">on_mission_control</code><span class="sig-paren">(</span><em>message</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_mission_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when a message from control center is arrived.
:param message: string, the message from the the control center.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_connected">
<code class="descname">on_trading_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_disconnected">
<code class="descname">on_trading_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_disconnected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_err_rtn_order_action">
<code class="descname">on_trading_err_rtn_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>order_action</em>, <em>res_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_err_rtn_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>如果交易所认为撤单错误。由交易托管系统主动通知客户端，该方法会被调用。
:param p_api: c_void_p
:param order_action: CThostFtdcOrderActionField
:param res_info: CThostFtdcRspInfoField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_err_rtn_order_insert">
<code class="descname">on_trading_err_rtn_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>res_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_err_rtn_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>如果交易所认为报单错误。由交易托管系统主动通知客户端，该方法会被调用。
:param p_api: c_void_p
:param input_order: CThostFtdcInputOrderField
:param res_info: CThostFtdcRspInfoField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_error">
<code class="descname">on_trading_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_order_action">
<code class="descname">on_trading_rsp_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order_action</em>, <em>res_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>交易托管系统收到撤单指令，如果没有通过参数校验，拒绝接受撤单指令。用户就会收到此消息，其中包含了错误编码和错误消息
:param p_api: c_void_p
:param order_action: CThostFtdcInputOrderActionField
:param res_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_order_insert">
<code class="descname">on_trading_rsp_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>res_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>交易托管系统收到报单指令，如果没有通过参数校验，拒绝接受报单指令。用户就会收到此消息，其中包含了错误编码和错误消息
:param p_api: c_void_p
:param input_order: CThostFtdcInputOrderField
:param res_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_depth_market_data">
<code class="descname">on_trading_rsp_qry_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询行情响应。当客户端发出请求查询行情指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param depth_market_data: CThostFtdcDepthMarketDataField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_investor_position_detail">
<code class="descname">on_trading_rsp_qry_investor_position_detail</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position_detail</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_investor_position_detail" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询投资者持仓明细响应。当客户端发出请求请求查询投资者持仓明细指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api:c_void_p
:param investor_position_detail: CThostFtdcInvestorPositionDetailField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_order">
<code class="descname">on_trading_rsp_qry_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_order" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询报单响应
:param p_api: c_void_p
:param order: CThostFtdcOrderField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_trade">
<code class="descname">on_trading_rsp_qry_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rsp_qry_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询成交响应
:param p_api: c_void_p
:param trade: CThostFtdcTradeField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rtn_order">
<code class="descname">on_trading_rtn_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rtn_order" title="Permalink to this definition">¶</a></dt>
<dd><p>报单回报。当客户端进行报单录入、报单操作及其它原因（如部分成交）导致报单状态发生变化时，交易托管系统会主动通知客户端，该方法会被调用。
:param p_api: c_void_p
:param order: CThostFtdcOrderField</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rtn_trade">
<code class="descname">on_trading_rtn_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.on_trading_rtn_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>成交回报。当发生成交时交易托管系统会通知客户端，该方法会被调用。
:param p_api: c_void_p
:param trade:CThostFtdcTradeField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.set_ctp_factory">
<code class="descname">set_ctp_factory</code><span class="sig-paren">(</span><em>ctp_factory</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.set_ctp_factory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.set_market">
<code class="descname">set_market</code><span class="sig-paren">(</span><em>market</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.set_market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.set_market_and_trading">
<code class="descname">set_market_and_trading</code><span class="sig-paren">(</span><em>market</em>, <em>trading</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.set_market_and_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.set_trading">
<code class="descname">set_trading</code><span class="sig-paren">(</span><em>trading</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.set_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.trading">
<code class="descname">trading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.trading_account_id">
<code class="descname">trading_account_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyInitializerCallbacks.trading_account_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Current trading account id.
:return: string, the trading account id.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.strategy.</code><code class="descname">AbstractStrategyExecutionDriver</code><span class="sig-paren">(</span><em>future_ids</em>, <em>strategy</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.datetime_format">
<code class="descname">datetime_format</code><em class="property"> = '%Y-%m-%d %H:%M:%S'</em><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.datetime_format" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.create_trading">
<code class="descname">create_trading</code><span class="sig-paren">(</span><em>msg_queue</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.create_trading" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new trading object and return it.
:param msg_queue: CtpMessageQueue.
:return: CtpTrading.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.create_market">
<code class="descname">create_market</code><span class="sig-paren">(</span><em>msg_queue</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.create_market" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new market object and return it.
:param msg_queue: CtpMessageQueue.
:return: CtpMarket.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.reset_market_and_trading">
<code class="descname">reset_market_and_trading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.reset_market_and_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.market">
<code class="descname">market</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.trading">
<code class="descname">trading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.set_market">
<code class="descname">set_market</code><span class="sig-paren">(</span><em>market</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.set_market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.set_trading">
<code class="descname">set_trading</code><span class="sig-paren">(</span><em>trading</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.set_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.set_step_action">
<code class="descname">set_step_action</code><span class="sig-paren">(</span><em>action</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.set_step_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.adapted_time">
<code class="descname">adapted_time</code><span class="sig-paren">(</span><em>dt</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.adapted_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.now" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.drive">
<code class="descname">drive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver.drive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.strategy.StrategyExecutionDriver">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.strategy.</code><code class="descname">StrategyExecutionDriver</code><span class="sig-paren">(</span><em>future_ids</em>, <em>strategy</em>, <em>should_get_commission_ratio=False</em>, <em>should_get_order_comm_rate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyExecutionDriver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver" title="ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver</span></code></a></p>
<p>Initialize current strategy.
:param future_ids, [string], the list of future ids to trade.
:param strategy: AbstractStrategy, the strategy who needs drive.</p>
<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyExecutionDriver.initialize_info">
<code class="descname">initialize_info</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyExecutionDriver.initialize_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Get information about the traded future and current trading account.
Initialize self.market_periods using the collected future.
Set self.info with the retrieved values.
:param now: datetime, current timestamp.
:return bool, True if initialization succeeded, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyExecutionDriver.get_market_periods">
<code class="descname">get_market_periods</code><span class="sig-paren">(</span><em>future_id</em>, <em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyExecutionDriver.get_market_periods" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the trading periods (within one trading day) for the given future.
Note: only support IF for the moment.
:param future_id: string, the future_id
:param now: datetime, current timestamp.
:return: trading_day, market_periods</p>
<blockquote>
<div><p>trading_day: date, the current trading date for the given future.
market_periods: [(time, time)], the list of trading periods,</p>
<blockquote>
<div>each of which is defined by start time and end time.</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyExecutionDriver.should_exit">
<code class="descname">should_exit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyExecutionDriver.should_exit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyExecutionDriver.adapted_time">
<code class="descname">adapted_time</code><span class="sig-paren">(</span><em>dt</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyExecutionDriver.adapted_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyExecutionDriver.create_market">
<code class="descname">create_market</code><span class="sig-paren">(</span><em>msg_queue</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyExecutionDriver.create_market" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new market object and return it.
:param msg_queue: CtpMessageQueue.
:return: CtpMarket.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyExecutionDriver.create_trading">
<code class="descname">create_trading</code><span class="sig-paren">(</span><em>msg_queue</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyExecutionDriver.create_trading" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new trading object and return it.
:param msg_queue: CtpMessageQueue.
:return: CtpTrading.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.strategy.StrategyExecutionDriver.datetime_format">
<code class="descname">datetime_format</code><em class="property"> = '%Y-%m-%d %H:%M:%S'</em><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyExecutionDriver.datetime_format" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyExecutionDriver.drive">
<code class="descname">drive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyExecutionDriver.drive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyExecutionDriver.market">
<code class="descname">market</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyExecutionDriver.market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyExecutionDriver.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyExecutionDriver.now" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyExecutionDriver.reset_market_and_trading">
<code class="descname">reset_market_and_trading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyExecutionDriver.reset_market_and_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyExecutionDriver.set_market">
<code class="descname">set_market</code><span class="sig-paren">(</span><em>market</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyExecutionDriver.set_market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyExecutionDriver.set_step_action">
<code class="descname">set_step_action</code><span class="sig-paren">(</span><em>action</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyExecutionDriver.set_step_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyExecutionDriver.set_trading">
<code class="descname">set_trading</code><span class="sig-paren">(</span><em>trading</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyExecutionDriver.set_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyExecutionDriver.trading">
<code class="descname">trading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyExecutionDriver.trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.StrategyExecutionDriver.dispose_logger">
<code class="descname">dispose_logger</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.StrategyExecutionDriver.dispose_logger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.strategy.InitializerStrategyDriver">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.strategy.</code><code class="descname">InitializerStrategyDriver</code><span class="sig-paren">(</span><em>future_ids</em>, <em>strategy</em>, <em>should_get_commission_ratio=False</em>, <em>should_get_order_comm_rate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.InitializerStrategyDriver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver" title="ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.strategy.AbstractStrategyExecutionDriver</span></code></a></p>
<p>This class will collect basic information about the traded future and the current investor.
Information include: future delivery date, investor position for that future.</p>
<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.InitializerStrategyDriver.adapted_time">
<code class="descname">adapted_time</code><span class="sig-paren">(</span><em>dt</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.InitializerStrategyDriver.adapted_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.InitializerStrategyDriver.create_market">
<code class="descname">create_market</code><span class="sig-paren">(</span><em>msg_queue</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.InitializerStrategyDriver.create_market" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new market object and return it.
:param msg_queue: CtpMessageQueue.
:return: CtpMarket.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.InitializerStrategyDriver.create_trading">
<code class="descname">create_trading</code><span class="sig-paren">(</span><em>msg_queue</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.InitializerStrategyDriver.create_trading" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new trading object and return it.
:param msg_queue: CtpMessageQueue.
:return: CtpTrading.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.strategy.InitializerStrategyDriver.datetime_format">
<code class="descname">datetime_format</code><em class="property"> = '%Y-%m-%d %H:%M:%S'</em><a class="headerlink" href="#ctxalgoctp.ctp.strategy.InitializerStrategyDriver.datetime_format" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.InitializerStrategyDriver.market">
<code class="descname">market</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.InitializerStrategyDriver.market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.InitializerStrategyDriver.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.InitializerStrategyDriver.now" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.InitializerStrategyDriver.reset_market_and_trading">
<code class="descname">reset_market_and_trading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.InitializerStrategyDriver.reset_market_and_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.InitializerStrategyDriver.set_market">
<code class="descname">set_market</code><span class="sig-paren">(</span><em>market</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.InitializerStrategyDriver.set_market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.InitializerStrategyDriver.set_step_action">
<code class="descname">set_step_action</code><span class="sig-paren">(</span><em>action</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.InitializerStrategyDriver.set_step_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.InitializerStrategyDriver.set_trading">
<code class="descname">set_trading</code><span class="sig-paren">(</span><em>trading</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.InitializerStrategyDriver.set_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.InitializerStrategyDriver.trading">
<code class="descname">trading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.InitializerStrategyDriver.trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategy.InitializerStrategyDriver.drive">
<code class="descname">drive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategy.InitializerStrategyDriver.drive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.tick_and_bar_publisher"></span><dl class="class">
<dt id="ctxalgoctp.ctp.tick_and_bar_publisher.AbstractTickAndBarPublisher">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.tick_and_bar_publisher.</code><code class="descname">AbstractTickAndBarPublisher</code><a class="headerlink" href="#ctxalgoctp.ctp.tick_and_bar_publisher.AbstractTickAndBarPublisher" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="ctxalgoctp.ctp.tick_and_bar_publisher.AbstractTickAndBarPublisher.get_ohlc_generators">
<code class="descname">get_ohlc_generators</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>ohlcs</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.tick_and_bar_publisher.AbstractTickAndBarPublisher.get_ohlc_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ohlc generators needed to generate the kinds of
:param instrument_id: string, instrument id whose ohlcs are to be generated.
:param ohlcs:
:return:</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.tick_and_bar_publisher.CtpTickAndBarPublisher">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.tick_and_bar_publisher.</code><code class="descname">CtpTickAndBarPublisher</code><a class="headerlink" href="#ctxalgoctp.ctp.tick_and_bar_publisher.CtpTickAndBarPublisher" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.trading_account"></span><dl class="class">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.trading_account.</code><code class="descname">TradingAccount</code><span class="sig-paren">(</span><em>security_company</em>, <em>available=1000000.0</em>, <em>has_commission=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Class that represents a trading account.</p>
<p>Initialize current.
:param security_company: string, the security company which holds this account.</p>
<blockquote>
<div>Different security companies may have different commission rates, margins, etc. This parameter
takes that into consideration. If None, use a default security company.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>available</strong> &#8211; float, the available money that can be used to open positions..</li>
<li><strong>has_commission</strong> &#8211; bool, if True, all trades have normal commission. Otherwise, trades have 0 commission.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.clear_positions">
<code class="descname">clear_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.clear_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.is_position_info_valid">
<code class="descname">is_position_info_valid</code><span class="sig-paren">(</span><em>position_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.is_position_info_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the given position info contain the necessary information?
:param position_info: dict{string, object}, position info, keys are position data values.
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.get_current_margin">
<code class="descname">get_current_margin</code><span class="sig-paren">(</span><em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.get_current_margin" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current margin money.
:return: float, current margin money.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.update_instrument_price">
<code class="descname">update_instrument_price</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>price</em>, <em>actual_instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.update_instrument_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Update current trading account with the last known future price. This future price is used
to calculate running profit of this account. This is only needed for backtesting.
:param instrument_id: string, future id.
:param price: float, price of the future.
:param actual_instrument_id: float, the actual instrument id.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.get_total_profit">
<code class="descname">get_total_profit</code><span class="sig-paren">(</span><em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.get_total_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the last known total profit.
Return: float, the total profit.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.get_position_simple">
<code class="descname">get_position_simple</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>today=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.get_position_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Return positions for a given future in current account.
:param instrument_id: string, future id.
:param today: date, the current trading day.
:return: {string: int}, keys are position directions &#8216;long&#8217; and &#8216;short&#8217;,</p>
<blockquote>
<div>values are the volumes in those directions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.get_instruments_with_position">
<code class="descname">get_instruments_with_position</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.get_instruments_with_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the instrument ids of held positions.
:return: [(instrument_id, actual_instrument_id)], list of instrument ids of held positions.</p>
<blockquote>
<div>instrument_id: string, the instrument id, can be relative, such as IF00.
actual_instrument_id: string, actual instrument id, cannot be relative.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.get_position">
<code class="descname">get_position</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>today=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.get_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return positions for a given future in current account.
:param instrument_id: string, future id.
:param today: date, the current trading day.
:return: [(direction, volume, yesterday_volume, today_volume)],</p>
<blockquote>
<div>direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
volume: int, the overall positions.
yesterday_volume: int, the positions from previous trading days.
today_volume: int, the positions from current trading day.
A list of positions. direction is &#8216;long&#8217; or &#8216;short&#8217; and volume is of type int.
Positive volume means long position; negative volume means short position. zero volumes means
there is no position in that direction. The returned list has maximal two elements.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.get_position_detail">
<code class="descname">get_position_detail</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.get_position_detail" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given future in current account.
:param instrument_id: string, future id.
:return: dict{string:dict{string:object}}</p>
<blockquote>
<div>Outer keys are directions, can have value &#8220;long&#8221; or &#8220;short&#8221;.
Inner keys are position property names, inner values are property values.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.get_positions">
<code class="descname">get_positions</code><span class="sig-paren">(</span><em>instrument_id=''</em>, <em>today=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.get_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of all holding instrument positions.
:param instrument_id: string, the instrument id.</p>
<blockquote>
<div>If instrument_id is an empty string, return positions for all held instruments,
otherwise, return positions for the specified instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>today</strong> &#8211; date, current trading day.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: [(direction, volume, yesterday_volume, today_volume)]}, keys are instrument ids.
A value is a list of positions. direction is &#8216;long&#8217; or &#8216;short&#8217; and volume is of type int.
Positive volume means long position; negative volume means short position. zero volumes means
there is no position in that direction. Each list has maximal two elements.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.get_transaction_id">
<code class="descname">get_transaction_id</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.get_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd><p>The the transaction id for the given future.
:param: instrument_id, string, the instrument id.
:return: [(direction, transaction_id)], a list of transaction ids. direction is &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>transaction_id is string, representing the transaction id of that direction. If there is no
transaction for a direction, the transaction id for that direction is None.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.add_position_info">
<code class="descname">add_position_info</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>position_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.add_position_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Add position_info into current account.
:param instrument_id: string, instrument id.
:param position_info: dict{string: object}, keys are position info data item names.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.get_close_position_action_flag">
<code class="descname">get_close_position_action_flag</code><span class="sig-paren">(</span><em>open_date</em>, <em>close_date</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.get_close_position_action_flag" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the close position flag, such as CloseToday, CloseYesterday from open_date and close_date.
:param open_date: date, the trading day (not calendar day), when the position is opened.
:param close_date: date, the trading day (not calendar day), when the position is closed.
:return: string, close position flag.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.calculate_max_floating_profit_and_loss">
<code class="descname">calculate_max_floating_profit_and_loss</code><span class="sig-paren">(</span><em>volume</em>, <em>volume_multiple</em>, <em>open_price</em>, <em>min_price</em>, <em>max_price</em>, <em>open_commission</em>, <em>close_commission</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.calculate_max_floating_profit_and_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the max floating profit and floating loss for a held position from its open to is close.
:param volume: int, volume of the position.
:param volume_multiple: int, volume multiple.
:param open_price: float, the price when the position is opened.
:param min_price: float, the min price that the corresponding instrument has reached during the holding period.
:param max_price: float, the max price that the corresponding instrument has reached during the holding period.
:param open_commission: float, the open commission for current position.
:param close_commission: float, the close commission for current position.
:return: (max_float_profit, min_float_profit), both elements are of type float.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.open_positions">
<code class="descname">open_positions</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>price</em>, <em>volume</em>, <em>trade_id</em>, <em>order_ref</em>, <em>timestamp</em>, <em>reason</em>, <em>transaction_id</em>, <em>trading_day</em>, <em>actual_instrument_id</em>, <em>volume_multiple=None</em>, <em>margin_rate=None</em>, <em>open_today=None</em>, <em>close_yesterday=None</em>, <em>close_today=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.open_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Open positions.
:param instrument_id, string, the instrument id.
:param price: float, the price at which the positions are open.
:param volume: the opened position volume. Positive if long, negative is short.
:param trade_id: int, id of the trade.
:param order_ref, int, order reference.
:param timestamp: datetime, time stamp.
:param reason: string, the reason for opening the position.
:param transaction_id: string, transaction id.
:param trading_day: date, the current trading day.
:param actual_instrument_id: string, the actual instrument id.
:param volume_multiple: int, volume multiple. If None, use volume multiple information from CTX.</p>
<blockquote>
<div>If not None, it is because we get this value directly from the exchange.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>margin_rate</strong> &#8211; double, margin rate. If None, use margin rate information from CTX.
If not None, it is because we get this value directly from the exchange.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return [dict{string:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">object}], the list of opened positions. Even if it is a list, the result
always contains only a single element. Each element is a dict, keys are position data item names.
The keys are: trade_id, timestamp, price, volume, reason, transaction_id,
trading_day, open_commission, order_ref, margin.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.close_positions">
<code class="descname">close_positions</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>price</em>, <em>volume</em>, <em>timestamp</em>, <em>trading_day</em>, <em>actual_instrument_id=None</em>, <em>open_today=None</em>, <em>close_yesterday=None</em>, <em>close_today=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.close_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Close positions.
:param instrument_id, string, the instrument id.
:param price: float, the price at which the positions are closed.
:param volume: int, the volume that needs to be closed.
:param timestamp: datetime, current timestamp.
:param trading_day, date, the trading day on which this position is closed.
:param actual_instrument_id: string, the actual instrument id. If None, defaults to instrument_id.
:return: [dict{string: object}], the list of closed positions.</p>
<blockquote>
<div>It is a list because one close order may close off several previously opened positions. For example,
I opened 1 position at price_1, 2 positions as price_2, and now I close 3 positions. The close operations
will close off the price_1 trade and the price_2 trade, so in the result, there are two elements,
one for closing the trade at price_1 and the other for the trade at price_2.
Each element in the list is a dict{string: object}, keys are position info data names.
Keys are: order_ref, trade_id, timestamp, price, volume, reason, transaction_id,
open_commission, close_commission, max_float_profit, max_float_loss, profit.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.get_held_instruments">
<code class="descname">get_held_instruments</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.get_held_instruments" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the instrument ids for which we hold some positions.
:return: [string], instrument ids.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.get_all_positions">
<code class="descname">get_all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.get_all_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return currently holding positions in all traded instruments.
:return dict from string to dict. The outer keys are instrument ids. The inner dict is from string to int.</p>
<blockquote>
<div><p>Inner keys can be either &#8216;long&#8217; or &#8216;short&#8217;, and the inner values are positions in that direction.
A positive number means long positions. A negative number means short positions.
For example:
{</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;IF99&#8217;: {</dt>
<dd><blockquote class="first">
<div>&#8216;long&#8217;: 5,
&#8216;short&#8217;: -3</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.get_current_balance">
<code class="descname">get_current_balance</code><span class="sig-paren">(</span><em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.get_current_balance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current balance in this account.
:return: float, balance.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.get_position_change_actions">
<em class="property">static </em><code class="descname">get_position_change_actions</code><span class="sig-paren">(</span><em>new_position</em>, <em>long_position</em>, <em>short_position</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.get_position_change_actions" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the positions to open and close to reach new_position given current long_position and short_position.</p>
<p>It uses the following semantics to decide how much positions to open and close.
If current positions for the given instrument is single-sided, then the orders to place is decided by
the following case analysis: let the current position be p, and new position be p2
old_position    new_position            action
p                               p2==p                           Nothing
p&gt;=0                    p2&gt;p                            open_long(p2-p)
p&gt;=0                    0&lt;=p2&lt;=p                        close_long(p-p2)
p&gt;=0                    p2&lt;0                            close_long(p); open_short(p2)
p&lt;=0                    p2&lt;p                            open_short(p2-p)
p&lt;=0                    p&lt;p2&lt;=0                         close_short(p-p2)
p&lt;=0                    p2&gt;0                            close_short(p); open_long(p2)</p>
<p>If current positions for the given instrument is two-sided, then the orders to place is decided by
the following case analysis: let the long positions be L, short positions be S, and the new position be p2,
and by definition, L &gt; 0, S &lt; 0:
Long    Short   New                             Action
L&gt;0             S&lt;0             p2==0                   close_long(L), close_short(S)
L&gt;0             S&lt;0             p2&gt;L                    open_long(p2-L), close_short(S)
L&gt;0             S&lt;0             p2&gt;0, p2&lt;L              close_long(L-p2), close_short(S)
L&gt;0             S&lt;0             p2&gt;0, p2==L             close_short(S)
L&gt;0             S&lt;0             p2&lt;0, p2&gt;S              close_long(L), close_short(S-p2)
L&gt;0             S&lt;0             p2&lt;0, p2&lt;S              close_long(L), open_short(p2-S)
L&gt;0             S&lt;0             p2&lt;0, p2==S     close_long(L)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>new_position</strong> &#8211; int, the new volume to reach.</li>
<li><strong>long_position</strong> &#8211; int, the current long position.</li>
<li><strong>short_position</strong> &#8211; int, the current short position.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">([int], [int]), meaning ([positions_to_open], [positions_to_close]).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.get_datetime_prefixed_id_str">
<em class="property">static </em><code class="descname">get_datetime_prefixed_id_str</code><span class="sig-paren">(</span><em>future_id</em>, <em>some_id</em>, <em>timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.get_datetime_prefixed_id_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string which represents a multi-day-wise unique id.
:param future_id: string, id of the future to trade.
:param some_id: int, some integer for intra-day id..
:return: string, the order ref string in format of yyyy_mm_dd_HH_MM_SS_zeio_padded_some_id.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.to_json">
<em class="property">static </em><code class="descname">to_json</code><span class="sig-paren">(</span><em>account</em>, <em>json_encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn account into json string.
:param: account: TradingAccount.
:return: string, the json string for account.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.trading_account.TradingAccount.from_json">
<em class="property">static </em><code class="descname">from_json</code><span class="sig-paren">(</span><em>security_company</em>, <em>json_str</em>, <em>has_commission=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_account.TradingAccount.from_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse json_str into TradingAccount.
:param security_company: string, security company
:param json_str: string, json string.
:param has_commission: bool.
:return: TradingAccount.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.trading_constants"></span><dl class="class">
<dt id="ctxalgoctp.ctp.trading_constants.OrderAction">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.trading_constants.</code><code class="descname">OrderAction</code><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderAction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Constant values for different kinds of orders.</p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.OrderAction.Open">
<code class="descname">Open</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderAction.Open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.OrderAction.Close">
<code class="descname">Close</code><em class="property"> = 1</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderAction.Close" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.OrderAction.ForceClose">
<code class="descname">ForceClose</code><em class="property"> = 2</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderAction.ForceClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.OrderAction.CloseToday">
<code class="descname">CloseToday</code><em class="property"> = 3</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderAction.CloseToday" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.OrderAction.CloseYesterday">
<code class="descname">CloseYesterday</code><em class="property"> = 4</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderAction.CloseYesterday" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.OrderAction.ForceOff">
<code class="descname">ForceOff</code><em class="property"> = 5</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderAction.ForceOff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.OrderAction.LocalForceClose">
<code class="descname">LocalForceClose</code><em class="property"> = 6</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderAction.LocalForceClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.OrderAction.Cancel">
<code class="descname">Cancel</code><em class="property"> = 7</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderAction.Cancel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.trading_constants.OrderAction.get_action_name">
<em class="property">static </em><code class="descname">get_action_name</code><span class="sig-paren">(</span><em>action</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderAction.get_action_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the action.
Parameters:</p>
<blockquote>
<div>action: int, one of the order action constant defined above.</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>string: the name for that action.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.trading_constants.OrderAction.get_action_from_name">
<em class="property">static </em><code class="descname">get_action_from_name</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderAction.get_action_from_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the action from its name.
Parameters:</p>
<blockquote>
<div>name: string, name of the action.</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>int: the action value.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.trading_constants.OrderStatus">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.trading_constants.</code><code class="descname">OrderStatus</code><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Order status</p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.OrderStatus.AllTraded">
<code class="descname">AllTraded</code><em class="property"> = '0'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderStatus.AllTraded" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.OrderStatus.PartTradedQueueing">
<code class="descname">PartTradedQueueing</code><em class="property"> = '1'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderStatus.PartTradedQueueing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.OrderStatus.PartTradedNotQueueing">
<code class="descname">PartTradedNotQueueing</code><em class="property"> = '2'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderStatus.PartTradedNotQueueing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.OrderStatus.NoTradeQueueing">
<code class="descname">NoTradeQueueing</code><em class="property"> = '3'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderStatus.NoTradeQueueing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.OrderStatus.NoTradeNotQueueing">
<code class="descname">NoTradeNotQueueing</code><em class="property"> = '4'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderStatus.NoTradeNotQueueing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.OrderStatus.Canceled">
<code class="descname">Canceled</code><em class="property"> = '5'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderStatus.Canceled" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.OrderStatus.Unknown">
<code class="descname">Unknown</code><em class="property"> = 'a'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderStatus.Unknown" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.OrderStatus.NotTouched">
<code class="descname">NotTouched</code><em class="property"> = 'b'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderStatus.NotTouched" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.OrderStatus.Touched">
<code class="descname">Touched</code><em class="property"> = 'c'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderStatus.Touched" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.OrderStatus.Error">
<code class="descname">Error</code><em class="property"> = 'x'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.OrderStatus.Error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.trading_constants.</code><code class="descname">LogTags</code><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tags used for logging.</p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.ACCOUNT">
<code class="descname">ACCOUNT</code><em class="property"> = 'ACCOUNT'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.ACCOUNT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.BAR">
<code class="descname">BAR</code><em class="property"> = 'BAR'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.BAR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.COMMISSION_RATE">
<code class="descname">COMMISSION_RATE</code><em class="property"> = 'COMMISSION_RATE'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.COMMISSION_RATE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.CANCEL_ORDER">
<code class="descname">CANCEL_ORDER</code><em class="property"> = 'CANCEL_ORDER'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.CANCEL_ORDER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.CONNECT_MARKET">
<code class="descname">CONNECT_MARKET</code><em class="property"> = 'CONNECT_MARKET'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.CONNECT_MARKET" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.CONNECT_TRADING">
<code class="descname">CONNECT_TRADING</code><em class="property"> = 'CONNECT_TRADING'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.CONNECT_TRADING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.ERROR_ORDER_ACTION">
<code class="descname">ERROR_ORDER_ACTION</code><em class="property"> = 'ERROR_ORDER_ACTION'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.ERROR_ORDER_ACTION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.ERROR_ORDER_INSERT">
<code class="descname">ERROR_ORDER_INSERT</code><em class="property"> = 'ERROR_ORDER_INSERT'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.ERROR_ORDER_INSERT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.ERROR">
<code class="descname">ERROR</code><em class="property"> = 'ERROR'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.ERROR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.EXCEPTION">
<code class="descname">EXCEPTION</code><em class="property"> = 'EXCEPTION'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.EXCEPTION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.INSTRUMENT">
<code class="descname">INSTRUMENT</code><em class="property"> = 'INSTRUMENT'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.INSTRUMENT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.MARGIN_RATE">
<code class="descname">MARGIN_RATE</code><em class="property"> = 'MARGIN_RATE'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.MARGIN_RATE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.MARKET">
<code class="descname">MARKET</code><em class="property"> = 'MARKET'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.MARKET" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.MARKET_CONNECTED">
<code class="descname">MARKET_CONNECTED</code><em class="property"> = 'MARKET_CONNECTED'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.MARKET_CONNECTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.MARKET_DISCONNECTED">
<code class="descname">MARKET_DISCONNECTED</code><em class="property"> = 'MARKET_DISCONNECTED'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.MARKET_DISCONNECTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.MARKET_PERIOD">
<code class="descname">MARKET_PERIOD</code><em class="property"> = 'MARKET_PERIOD'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.MARKET_PERIOD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.OHLC">
<code class="descname">OHLC</code><em class="property"> = 'OHLC'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.OHLC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.ORDER">
<code class="descname">ORDER</code><em class="property"> = 'ORDER'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.ORDER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.ORDER_ACTION">
<code class="descname">ORDER_ACTION</code><em class="property"> = 'ORDER_ACTION'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.ORDER_ACTION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.ORDER_COMMISSION_RATE">
<code class="descname">ORDER_COMMISSION_RATE</code><em class="property"> = 'ORDER_COMMISSION_RATE'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.ORDER_COMMISSION_RATE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.ORDER_INSERT">
<code class="descname">ORDER_INSERT</code><em class="property"> = 'ORDER_INSERT'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.ORDER_INSERT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.POSITION">
<code class="descname">POSITION</code><em class="property"> = 'POSITION'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.POSITION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.POSITION_SIZING">
<code class="descname">POSITION_SIZING</code><em class="property"> = 'POSITION_SIZING'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.POSITION_SIZING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.RTN_ORDER">
<code class="descname">RTN_ORDER</code><em class="property"> = 'RTN_ORDER'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.RTN_ORDER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.SIGNAL">
<code class="descname">SIGNAL</code><em class="property"> = 'SIGNAL'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.SIGNAL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.SIGNAL_CONFIRMED">
<code class="descname">SIGNAL_CONFIRMED</code><em class="property"> = 'SIGNAL_CONFIRMED'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.SIGNAL_CONFIRMED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.SIGNAL_IGNORED">
<code class="descname">SIGNAL_IGNORED</code><em class="property"> = 'SIGNAL_IGNORED'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.SIGNAL_IGNORED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.STATE_TRANSITION">
<code class="descname">STATE_TRANSITION</code><em class="property"> = 'STATE_TRANSITION'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.STATE_TRANSITION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.STRATEGY">
<code class="descname">STRATEGY</code><em class="property"> = 'STRATEGY'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.STRATEGY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.STRATEGY_EXTRA">
<code class="descname">STRATEGY_EXTRA</code><em class="property"> = 'STRATEGY_EXTRA'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.STRATEGY_EXTRA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.STOP_LOSS">
<code class="descname">STOP_LOSS</code><em class="property"> = 'STOP_LOSS'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.STOP_LOSS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.TRADED">
<code class="descname">TRADED</code><em class="property"> = 'TRADED'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.TRADED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.TRADING_CONNECTED">
<code class="descname">TRADING_CONNECTED</code><em class="property"> = 'TRADING_CONNECTED'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.TRADING_CONNECTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.TRADING_DISCONNECTED">
<code class="descname">TRADING_DISCONNECTED</code><em class="property"> = 'TRADING_DISCONNECTED'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.TRADING_DISCONNECTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.VOLATILITY_BAR">
<code class="descname">VOLATILITY_BAR</code><em class="property"> = 'VOLATILITY_BAR'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.VOLATILITY_BAR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.WALK_FORWARD_TRAINING">
<code class="descname">WALK_FORWARD_TRAINING</code><em class="property"> = 'WALK_FORWARD_TRAINING'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.WALK_FORWARD_TRAINING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.WALK_FORWARD_PREDICTION">
<code class="descname">WALK_FORWARD_PREDICTION</code><em class="property"> = 'WALK_FORWARD_PREDICATION'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.WALK_FORWARD_PREDICTION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.trading_constants.LogTags.EXTERNAL">
<code class="descname">EXTERNAL</code><em class="property"> = 'EXTERNAL'</em><a class="headerlink" href="#ctxalgoctp.ctp.trading_constants.LogTags.EXTERNAL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.utils"></span><dl class="class">
<dt id="ctxalgoctp.ctp.utils.CtpVisualizationUtils">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.utils.</code><code class="descname">CtpVisualizationUtils</code><a class="headerlink" href="#ctxalgoctp.ctp.utils.CtpVisualizationUtils" title="Permalink to this definition">¶</a></dt>
<dd><dl class="staticmethod">
<dt id="ctxalgoctp.ctp.utils.CtpVisualizationUtils.visualize_report">
<em class="property">static </em><code class="descname">visualize_report</code><span class="sig-paren">(</span><em>report_file</em>, <em>user</em>, <em>password</em>, <em>report_name_to_save=None</em>, <em>server=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.utils.CtpVisualizationUtils.visualize_report" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.utils.CtpVisualizationUtils.send_report_to_server">
<em class="property">static </em><code class="descname">send_report_to_server</code><span class="sig-paren">(</span><em>report_file</em>, <em>user</em>, <em>password</em>, <em>report_name_to_save</em>, <em>server=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.utils.CtpVisualizationUtils.send_report_to_server" title="Permalink to this definition">¶</a></dt>
<dd><p>Send the report file to server.
:param report_file: string, path to the report file.
:param report_name_to_save: string, is not None, save the uploaded</p>
<blockquote>
<div>report to the reports page with this name. If None, do not store
the report.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>user</strong> &#8211; string, the name used to save the uploaded report.
If None, use the default user name.</li>
<li><strong>password</strong> &#8211; string, the password to the website.</li>
<li><strong>server</strong> &#8211; string, the server ip. If None, use the default.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">string, return an url <a class="reference external" href="http://ctxalgo.com/detailed-report">http://ctxalgo.com/detailed-report</a>...
for the user to open detailed report link.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="ctxalgoctp.ctp.utils.CtpVisualizationUtils.send_url_and_open_browser">
<em class="property">static </em><code class="descname">send_url_and_open_browser</code><span class="sig-paren">(</span><em>url</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.utils.CtpVisualizationUtils.send_url_and_open_browser" title="Permalink to this definition">¶</a></dt>
<dd><p>Send url to visualize by posting the url to ctxalgo.com and open a new tab in the browser.
:param url: string, the url to be opened.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.code_gen.backtesting_template"></span><dl class="function">
<dt id="ctxalgoctp.ctp.code_gen.backtesting_template.backtest">
<code class="descclassname">ctxalgoctp.ctp.code_gen.backtesting_template.</code><code class="descname">backtest</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.backtesting_template.backtest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.code_gen.base_template_info_extractor"></span><dl class="class">
<dt id="ctxalgoctp.ctp.code_gen.base_template_info_extractor.BaseTemplateInfoExtractor">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.code_gen.base_template_info_extractor.</code><code class="descname">BaseTemplateInfoExtractor</code><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.base_template_info_extractor.BaseTemplateInfoExtractor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.base_template_info_extractor.BaseTemplateInfoExtractor.extract">
<code class="descname">extract</code><span class="sig-paren">(</span><em>base_template</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.base_template_info_extractor.BaseTemplateInfoExtractor.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract information from the base template.
:param base_template: string, name of the template to be used in code generation.</p>
<blockquote>
<div>The name corresponds to file names in the templates folder.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: dict{string:string}}
Outer keys are language tags, either &#8220;en&#8221; or &#8220;zh&#8221;.
Inner keys are information tags: title, description, dot.<blockquote>
<div>title: string, the title of the template.
description: string, the description of the template.
dot: string, the dot description of the template. Note that the dot description is the same<blockquote>
<div>for both en and zh language.</div></blockquote>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.code_gen.code_gen_utils"></span><dl class="class">
<dt id="ctxalgoctp.ctp.code_gen.code_gen_utils.PlaceholderFinder">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.code_gen.code_gen_utils.</code><code class="descname">PlaceholderFinder</code><span class="sig-paren">(</span><em>placeholders=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.code_gen_utils.PlaceholderFinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Class to find placeholders from a content string.</p>
<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.code_gen_utils.PlaceholderFinder.find">
<code class="descname">find</code><span class="sig-paren">(</span><em>template_content</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.code_gen_utils.PlaceholderFinder.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Find present placeholder in template_content.
:param template_content: string, the template content in which we try to find placeholders.
:return: [string], The placeholders that appear in both template_content and self.placeholders.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.code_gen.template_strategy_generator"></span><dl class="class">
<dt id="ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.code_gen.template_strategy_generator.</code><code class="descname">TemplateStrategyGenerator</code><span class="sig-paren">(</span><em>dot</em>, <em>spec</em>, <em>base_template='template0'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Initialize current.
:param dot: string, the DOT description for the state machine.
:param spec: dict{string:object}, the extra configuration for code generation.
:param base_template: string, name of the template to be used in code generation.</p>
<blockquote>
<div>The name corresponds to file names in the templates folder.</div></blockquote>
<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate">
<code class="descname">generate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the template strategy class and make result available at self.template_strategy.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_strategy_classes">
<code class="descname">generate_strategy_classes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_strategy_classes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_imports">
<code class="descname">generate_imports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_imports" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the $IMPORTS part.
Note that the imports will include the import from referenced indicators, from the backtesting,</p>
<blockquote>
<div>from the live trading and from the optimization parts.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_parameters">
<code class="descname">generate_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the $PARAMETERS part and make result available at self.parameters_placeholder.
Use the information from self.indicator_info. Each element in indicator_info has a parameters property,
which contains the code used to generate the $PARAMETERS part.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_indicator_calculators">
<code class="descname">generate_indicator_calculators</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_indicator_calculators" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the $INDICATOR_CALCULATORS part and make result available at self.indicator_calculators_placeholder.
Use both the information from self.transformed_indicators and self.indicator_info to generate code.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_indicator_results">
<code class="descname">generate_indicator_results</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_indicator_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the $INDICATOR_RESULTS part and make result available at self.indicator_results_placeholder.
Use both the information from self.transformed_indicators and self.indicator_info to generate code.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_indicator_calculation_method">
<code class="descname">generate_indicator_calculation_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_indicator_calculation_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the $INDICATOR_CALCULATION_METHOD part and make result
available at self.indicator_calculation_method_placeholder.
Note: if there is no indicator, this part should be an empty string.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_indicator_calculation_before_run_method">
<code class="descname">generate_indicator_calculation_before_run_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_indicator_calculation_before_run_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the $INDICATOR_CALCULATION_BEFORE_RUN_METHOD part and make result
available at self.indicator_calculation_before_run_method_placeholder.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_on_before_run_indicator_calculation">
<code class="descname">generate_on_before_run_indicator_calculation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_on_before_run_indicator_calculation" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the $ON_BEFORE_RUN_INDICATOR_CALCULATION part and make result
available at self.on_before_run_indicator_calculation_placeholder.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_on_bar_method">
<code class="descname">generate_on_bar_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_on_bar_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the $ON_BAR_METHOD part of the code and make
result available at self.on_bar_method_placeholder.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_get_strategy_config">
<code class="descname">generate_get_strategy_config</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_get_strategy_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate strategy config, the $GET_STRATEGY_CONFIG part.
The template for strategy config is at templates.template_strategy_config.
Make result available at self.get_strategy_config_placeholder.
Use self.indicator_info[_].url_indicator to generate $URL_INDICATORS.
Use self.transformed_indicators[_][&#8216;instrument&#8217;] to generate $INSTRUMENT_IDS.
Use self.spec[&#8216;strategy_period&#8217;] to generate $STRATEGY_PERIOD.
Use self.spec[&#8216;registered_periods&#8217;] to generate $REGISTERED_OHLC_PERIODS.
Use self.indicator_info[_].indicator_parameters to generate $PARAMETERS.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_backtesting_data_period">
<code class="descname">generate_backtesting_data_period</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_backtesting_data_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate data period for backtesting, the $BACKTESTING_DATA_PERIOD part.
Make result available at self.backtesting_data_period_placeholder.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_get_optimization_config">
<code class="descname">generate_get_optimization_config</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_get_optimization_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate walk-forward optimization , the $WALK_FORWARD_OPTIMIZATION part, and make result
available at self.walk_forward_optimization_placeholder.
The template for this part is at templates.template_walk_forward_optimization.
Use self.indicator_info to generate the parameters (for optimization).
Note:  The way each parameter is generated will be different depending on the type of the parameter,</p>
<blockquote>
<div>accessible through self.indicator_info[_][&#8216;indicator_parameters&#8217;]</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_state_classes">
<code class="descname">generate_state_classes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_state_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate state classes, the $STATE_CLASSES part and make result available at self.state_classes_placeholder.
Use self.state_classes for the code generation.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_state_classes_creation">
<code class="descname">generate_state_classes_creation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_state_classes_creation" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate state classes creation, the $STATE_CLASSES_CREATION part and
make result available at self.state_classes_creation_placeholder.
Use self.state_classes for the code generation.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_dot_description">
<code class="descname">generate_dot_description</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_dot_description" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate dot description, the $DOT_DESCRIPTION part and
make result at self.dot_description_placeholder.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_parse_ohlc_line">
<code class="descname">generate_parse_ohlc_line</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_parse_ohlc_line" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_main">
<code class="descname">generate_main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.code_gen.template_strategy_generator.TemplateStrategyGenerator.generate_main" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the $MAIN part and make result available at self.main_placeholder.
The template for this part is at templates.template_main.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.live.change_positions"></span><dl class="class">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.live.change_positions.</code><code class="descname">ChangePositionStrategy</code><span class="sig-paren">(</span><em>instrument_ids</em>, <em>strategy_period</em>, <em>parameters</em>, <em>base_folder</em>, <em>periods=None</em>, <em>description=None</em>, <em>logger=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.strategy.AbstractStrategy" title="ctxalgoctp.ctp.strategy.AbstractStrategy"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.strategy.AbstractStrategy</span></code></a></p>
<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_tick">
<code class="descname">on_tick</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>tick</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_tick" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trade">
<code class="descname">on_trade</code><span class="sig-paren">(</span><em>trade_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.TRADING_CONNECTED">
<code class="descname">TRADING_CONNECTED</code><em class="property"> = 1</em><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.TRADING_CONNECTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.TRADING_NOT_CONNECTED">
<code class="descname">TRADING_NOT_CONNECTED</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.TRADING_NOT_CONNECTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.add_bar_arrival_action">
<code class="descname">add_bar_arrival_action</code><span class="sig-paren">(</span><em>action</em>, <em>period=None</em>, <em>instrument_ids=None</em>, <em>ohlc_kind='time-based'</em>, <em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.add_bar_arrival_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup an action, which will be called when all required ohlc bars have arrived.
For example, if period=Periodicity.HOURLY, and instrument_ids are the list of all the traded instruments,
then action will be called the next time when all hourly bars for the traded instruments have arrived.
:param action: function pointer with the following four parameters:</p>
<blockquote>
<div><p>ohlc_kind: string, the ohlc kind, can be &#8216;time-based&#8217;, &#8216;volatility-based&#8217;.
period: Periodicity in case of time-based ohlc, or int/float as volatility threshold</p>
<blockquote>
<div>in case of volatility-based ohlc.</div></blockquote>
<p>name: string, the bar arrival action name, same as the name parameter specified here.
ohlcs: dict{string: OHLC}, the list of ohlcs, keys are instrument ids, values are the ohlc objects.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>period</strong> &#8211; Periodicity in case of time-based ohlc, or int/float as volatility threshold
in case of volatility-based ohlc. This is the period for the required ohlc bars.
If None, use self.strategy_period().
This will be passed into the action when it is invoked.</li>
<li><strong>instrument_ids</strong> &#8211; [string], the list of instruments whose last ohlc bar of required period must
arrived before action can be invoked. If None, defaults to self.instrument_ids(), which are
the full list of traded instruments.</li>
<li><strong>ohlc_kind</strong> &#8211; string, the ohlc kind, can be &#8216;time-based&#8217;, &#8216;volatility-based&#8217;.
This will be passed into the action when it is invoked.</li>
<li><strong>name</strong> &#8211; string, the bar arrival action name, used to identify different bar arrival requests.
This will be passed into the action when it is invoked.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.add_timer">
<code class="descname">add_timer</code><span class="sig-paren">(</span><em>timer=None</em>, <em>trigger_time=None</em>, <em>timedelta=None</em>, <em>on_time_action=None</em>, <em>start=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.add_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Add timer into current strategy.
:param timer: SimulatedTimer, the timer to add. If None, use trigger_time to create a timer.
:param trigger_time: datetime or time, or string in form of yyyy-mm-dd or yyyy-mm-dd HH:MM:SS, or</p>
<blockquote>
<div>a list of the above types. The time(s) used to create a timer .
If specified, create an alarm timer.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>timedelta</strong> &#8211; timedelta, if specified, create a repeated count down timer.</li>
<li><strong>on_time_action</strong> &#8211; function pointer whose signature is same as self.on_timer.
If not None and there is no on_time_action set in timer, then set this as the callback for timer.
If None and there is no on_time_action in timer, then set self.on_timer into the timer.</li>
<li><strong>start</strong> &#8211; boolean, if True start the timer right away.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return string, the name of the added timer.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd><p>Return position details for all traded instruments.
:return: dict{string: dict{string: [dict{string: object}]}}</p>
<blockquote>
<div><p>The out most keys are instrument ides, and the values are the same as the result of self.position_details.
For example:
{</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;IF99&#8217;: {</dt>
<dd><dl class="first last docutils">
<dt>&#8216;long&#8217;: [</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>{</dt>
<dd>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</dd>
</dl>
<p>}, ...</p>
</div></blockquote>
<p class="last">],</p>
</dd>
<dt>&#8216;short&#8217;: [</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>{</dt>
<dd>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</dd>
</dl>
<p>}, ...</p>
</div></blockquote>
<p class="last">],</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.calculate_latest_market_end_time">
<code class="descname">calculate_latest_market_end_time</code><span class="sig-paren">(</span><em>market_periods</em>, <em>now</em>, <em>delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.calculate_latest_market_end_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Given traded instruments and current timestamp, calculate when the market will be closed.
This is used by the strategy infrastructure to decide when to exit strategies: strategies
should terminate after the latest market periods of the traded instrument ends, plus</p>
<blockquote>
<div>a given extra time. This automatic termination only has effect
when self.should_terminate_after_market_close is True.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param:</th><td class="field-body"><p class="first">market_periods, dict{string: [(time, time)]}, keys are instrument ids, values are market periods.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>now</strong> &#8211; datetime, current timestamp.</li>
<li><strong>delta</strong> &#8211; timedelta, some extra amount of time that is added into the traded market periods to allow
the strategy to continue running for some time after the market closes, for example, to do
some bookkeeping work. If None, no extra time is added.</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">datetime, the time when strategies should terminate.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.cancel_order">
<code class="descname">cancel_order</code><span class="sig-paren">(</span><em>order_ref</em>, <em>reason=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.cancel_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel order.
:param order_ref: string, the order reference.
:param reason: string, the reason for cancelling the order.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.change_position_to">
<code class="descname">change_position_to</code><span class="sig-paren">(</span><em>new_position</em>, <em>price=None</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.change_position_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the position of the given instrument to new_position. If price is given, all underlying orders
are limit orders at that price, otherwise, market orders.
:param new_position: int, the new position for the instrument.
:param price: float, if None, newly placed orders are market orders, otherwise, limit orders.
:param reason: string, the reason for this operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.
:param cancellation: AbstractOrderCancellation, the cancellation policy for current order.</p>
<blockquote>
<div>If None, no cancellation policy is specified.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd>may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.change_positions_to">
<code class="descname">change_positions_to</code><span class="sig-paren">(</span><em>new_positions</em>, <em>prices=None</em>, <em>reason=''</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.change_positions_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Change positions of multiple instruments to their new values.
:param new_positions: dict{string: int}, keys are instrument ids,</p>
<blockquote>
<div>values are the new positions for those instruments.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>prices</strong> &#8211; dict{string: float}, keys are instrument ids,
values are prices at which limit orders are placed. If prices is None, all orders are market orders.
If prices is a dict and for some instrument (through dict keys), the key is missing or the value
is None, then the orders for that instrument are market orders, otherwise, limit orders.</li>
<li><strong>reason</strong> &#8211; string, the reason for current order(s).</li>
<li><strong>transaction_id</strong> &#8211; string, transition id, set to None.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the order cancellation policy used to
cancel all the placed orders.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.check_bar_based_order_cancellations">
<code class="descname">check_bar_based_order_cancellations</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>bars</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.check_bar_based_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.check_order_cancellations">
<code class="descname">check_order_cancellations</code><span class="sig-paren">(</span><em>cancellations</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.check_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if we should cancel some orders because of previously setup order cancellations.
:param cancellations: [AbstractOrderCancellation], the list of order cancellations.
:param data: dict{string: object}, the data needed by order cancellations to decide</p>
<blockquote>
<div>whether pending orders should be cancelled. Different kinds of order cancellations
need different data.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.check_time_based_order_cancellations">
<code class="descname">check_time_based_order_cancellations</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.check_time_based_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if there are some order cancellation that should be triggered by the given timestamp now.
If so, cancel those orders.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.check_timers">
<code class="descname">check_timers</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.check_timers" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if there are some timers that can be triggered by the given timestamp now.
If so, call self.on_timer.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.close_limit_order">
<code class="descname">close_limit_order</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.close_limit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a limit order at price. Note that for limit orders, there is no support for enforce_one_direction,
because limit orders cannot guarantee that all positions in one direction are fully closed.
The strategy is responsible for maintaining positions in a single direction, if desirable.
:param price: float, the price.
:param volume: int, the volume to open. Positive volume means open long; Negative volume means open short.
:param kind: OrderKind. Distinguish between Normal, FAK, FOK limit orders.
:param reason: string, a reason for the open operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd>may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.close_market_order">
<code class="descname">close_market_order</code><span class="sig-paren">(</span><em>volume</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.close_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Close market order for future_id. If there is only one future in current strategy, you don&#8217;t need to
provide future_id, self.future_id will be used implicitly.
:param volume: int, the volume to close. Positive volume means open close; Negative volume means close short.
:param reason: string, a reason for the close operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd>may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.close_position">
<code class="descname">close_position</code><span class="sig-paren">(</span><em>volume</em>, <em>price=None</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.close_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a position for the instrumeent given by instrument_id.
:param price: float, if None, send a market order. If not None, send a limit order at that price.
:param kind: OrderKind, the order kind.
:param reason: string, reason for this open position operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:param transaction_id: string, transaction id.
:param cancellation: AbstractOrderCancellation, the cancellation policy for current order.
:return:</p>
<blockquote>
<div><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.data_feed">
<code class="descname">data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.data_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.delete_context_file">
<code class="descname">delete_context_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.delete_context_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the context.txt file.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.does_indicator_calculator_contain_ohlc_kind">
<code class="descname">does_indicator_calculator_contain_ohlc_kind</code><span class="sig-paren">(</span><em>indicator_calculators</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.does_indicator_calculator_contain_ohlc_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Does indicator_calculators contains ohlc kind information?
:param indicator_calculators:
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.dominant_instrument">
<code class="descname">dominant_instrument</code><span class="sig-paren">(</span><em>instrument_prefix</em>, <em>trading_day</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.dominant_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level dominant instrument id on the given trading day.
:param instrument_prefix: string, instrument id prefix, such as IF, cu.
:param trading_day: date, or string in form of yyyy-mm-dd. trading day.
:param level: int, 0 means the dominant contract, 1 means the next dominant contract, and so on.
:return: string, the instrument id of the asked dominant contract.</p>
<blockquote>
<div>If no such dominant contract, return None.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.dump_json">
<code class="descname">dump_json</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.dump_json" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.get_datetime_from_string">
<code class="descname">get_datetime_from_string</code><span class="sig-paren">(</span><em>day</em>, <em>time_</em>, <em>milli</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.get_datetime_from_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a datetime object from day, <a href="#id21"><span class="problematic" id="id22">time_</span></a> and milli.
Parameters:</p>
<blockquote>
<div>day: string, a string representation of a date, in format yyyymmdd.
<a href="#id23"><span class="problematic" id="id24">time_</span></a>: string, a string representation of a time, in format HH:MM:SS.
milli: string, a strign representation of milliseconds, in format of an integer.</div></blockquote>
<p>Return: datetime, a parsed datetime object.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.get_investor_position">
<code class="descname">get_investor_position</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.get_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a request for investor position for the given future.
:param instrument_id: string, instrument id. If an empty string, then get</p>
<blockquote>
<div>positions for all the held instruments.</div></blockquote>
<p>The returned information will be accessible through the corresponding callback function.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.get_order">
<code class="descname">get_order</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.get_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Return order information.
:param order_ref: string, the order reference number returned when placing an order via</p>
<blockquote>
<div>open_market_order, open_limit_order, close_market_order or close_limit_order.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}. The order object. None if no order if found by order_ref.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.get_order_status">
<code class="descname">get_order_status</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.get_order_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the status of an order.
:param order_ref: string, the order reference number returned when placing an order via</p>
<blockquote>
<div>open_market_order, open_limit_order, close_market_order or close_limit_order.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">OrderStatus. The status of the order. None if no order is found by order_ref.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.get_trading_account">
<code class="descname">get_trading_account</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.get_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a request for trading account information.
The returned information will be accessible through the corresponding callback function.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.has_data_feed">
<code class="descname">has_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.has_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is data feed set?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.has_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Has current strategy started running&gt;
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.indicator">
<code class="descname">indicator</code><span class="sig-paren">(</span><em>name</em>, <em>kind=None</em>, <em>period=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.indicator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the last calculated value(s) for the given indicator alias.
:param kind: string, kind of the ohlc on which indicators are calculated.</p>
<blockquote>
<div>Valid values are &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.
If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> &#8211; string, name of the indicator.</li>
<li><strong>period</strong> &#8211; Periodicity or int/float, the period of the indicator. If None, use self.strategy_period().
If kind is &#8216;volatility-based&#8217;, type of period is int/float, indicating volatility threshold.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id on which the indicator is calculated.
If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object, indicator result.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.initialize_before_run">
<code class="descname">initialize_before_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.initialize_before_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.is_trading_connected">
<code class="descname">is_trading_connected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.is_trading_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.last_bar_so_far">
<code class="descname">last_bar_so_far</code><span class="sig-paren">(</span><em>periodicity</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_cancel_order">
<code class="descname">log_cancel_order</code><span class="sig-paren">(</span><em>order_ref_id</em>, <em>order_ref</em>, <em>reason</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_cancel_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Log cancel order.
:param order_ref: string, order reference.
:param reason: string, the reason for order.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_connect_to_market">
<code class="descname">log_connect_to_market</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_connect_to_market" title="Permalink to this definition">¶</a></dt>
<dd><p>Log the action to connect to the market data server.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_connect_to_trading">
<code class="descname">log_connect_to_trading</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_connect_to_trading" title="Permalink to this definition">¶</a></dt>
<dd><p>Log the action to connect to the trading server.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_err_order_action">
<code class="descname">log_err_order_action</code><span class="sig-paren">(</span><em>order_ref</em>, <em>order_action</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_err_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_err_order_insert">
<code class="descname">log_err_order_insert</code><span class="sig-paren">(</span><em>order_ref</em>, <em>input_order</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_err_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_exception">
<code class="descname">log_exception</code><span class="sig-paren">(</span><em>e</em>, <em>tb</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_exception" title="Permalink to this definition">¶</a></dt>
<dd><p>Log exception.
:param Exception, the exception object.
:param tb string, the traceback.
:param other_data: dict{string: object}, other kinds of data.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_investor_position">
<code class="descname">log_investor_position</code><span class="sig-paren">(</span><em>investor_position</em>, <em>timestamp</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Log investor position.
:param investor_position: The investor position object.
:param is_last: boolean, is the result the last batch.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_ohlc">
<code class="descname">log_ohlc</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>bars</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Log ohlc.
:param instrument_id: string, the instrument id.
:param bars: dict{string: dict{Periodicity or int/float: Bar}} The bars.</p>
<blockquote>
<div>Outer keys are ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.
Inner keys are Periodicity or volatility thresholds, inner values are the generated bars.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_order">
<code class="descname">log_order</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>action</em>, <em>volume</em>, <em>order_ref</em>, <em>reason</em>, <em>transaction_id</em>, <em>order_kind='Market'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Log order.
:param instrument_id: string, the instrument id.
:param action: OrderAction, the action of this order.
:param volume: int, volume to trade.</p>
<blockquote>
<div>Positive volume means long position, negative volume means short position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>order_ref</strong> &#8211; int, order reference.</li>
<li><strong>reason</strong> &#8211; string the reason for order.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param transaction_id, int, the transaction id.
:param order_kind: OrderKind. The kind of the order.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_order_action">
<code class="descname">log_order_action</code><span class="sig-paren">(</span><em>order_ref</em>, <em>order_action</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_order_insert">
<code class="descname">log_order_insert</code><span class="sig-paren">(</span><em>order_ref</em>, <em>input_order</em>, <em>rsp_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_rtn_order">
<code class="descname">log_rtn_order</code><span class="sig-paren">(</span><em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_rtn_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_signal">
<code class="descname">log_signal</code><span class="sig-paren">(</span><em>signal</em>, <em>tag=None</em>, <em>reason=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Log signal.
:param signal: EntrySignal, the signal to log.
:param tag: string, the tag to use, if None, the method will decide a tag name.
:param reason: string, some additional reason. Can be None if there is no reason.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_state_transition">
<code class="descname">log_state_transition</code><span class="sig-paren">(</span><em>start_state</em>, <em>end_state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_state_transition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_stop_loss">
<code class="descname">log_stop_loss</code><span class="sig-paren">(</span><em>timestamp</em>, <em>direction</em>, <em>value</em>, <em>transaction_id</em>, <em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_stop_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Log stop loss.
Parameters:</p>
<blockquote>
<div><p>timestamp: datetime, the time when the stop loss is calculated.
direction: int, 1 means long stop loss, -1 means short stop loss.
value: float, the stop loss value.
transaction_id: string, transaction id.
name: string, a possible additional name for the stop loss line. This is helpful to</p>
<blockquote>
<div>support multiple stop lines (for example, a close-bar stop loss and an in-bar stop loss)
for the same transaction.</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_strategy">
<code class="descname">log_strategy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_strategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Log information about current strategy.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_strategy_info">
<code class="descname">log_strategy_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_strategy_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_trade">
<code class="descname">log_trade</code><span class="sig-paren">(</span><em>trade</em>, <em>extra_info</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_trade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_trading_account">
<code class="descname">log_trading_account</code><span class="sig-paren">(</span><em>account</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Log trading account.
:param account, the trading account object.
:param is_last: boolean, is the result the last batch.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_with_tag">
<code class="descname">log_with_tag</code><span class="sig-paren">(</span><em>tag</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.log_with_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Log data with tag.
:param tag: string, the log message tag indicating the kind of the message, for example, BAR, ORDER, ACCOUNT.
:param data: dict{string: object}, the data to be logged. Keys are data item names, values are data items.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.long_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return long positions for future_id.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: int, the long position, positive value or zero.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.market">
<code class="descname">market</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.mission_control">
<code class="descname">mission_control</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.mission_control" title="Permalink to this definition">¶</a></dt>
<dd><p>The mission control. The mission control is set through self.ctp_factory.set_mission_control.
:return: MissionControl. If no mission control is set, return None.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.now" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_bar">
<code class="descname">on_bar</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>bars</em>, <em>tick</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_bar" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when there is some ohlc bars generated.
:param instrument_id, string, the instrument id of the generated bar(s).
:param bars: dict{string: dict{Periodicity or int/float: Bar}.</p>
<blockquote>
<div>Meaning: dict{ohlc_kind: dict{period or volatility threshold: Bar}
Outer keys are ohlc kind such as &#8216;time-based&#8217;, &#8216;volatility-based&#8217; from OhlcGeneratorConstants.
Outer values are dict from Periodicity to Bar in the case of time-based ohlcs or
dict from int/float to Bar in the case of volatility-based ohlcs.
It may contains more than one bars: a single bar under each periodicity.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tick</strong> &#8211; dict{string: object}, the tick which triggers current ohlc bar(s) generation.
The object has the following keys (non-exhaustive):
timestamp, last_price, volume, ask_price1, ask_volume1, bid_price1, bid_volume1,
pre_open_interest, open_interest. Note that when backtesting, only when the data source is tick level,
tick includes order book information such as ask_price1, bid_price1. Otherwise, those order book
related fields will have default values.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_bar_from_zmq">
<code class="descname">on_bar_from_zmq</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_bar_from_zmq" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when there is a bar arrives from zeromq bar feed.
:param data: dict{string: object}, the bar information.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_bar_method">
<code class="descname">on_bar_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_bar_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the function pointer for on_bar.
:return: function pointer.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_before_run">
<code class="descname">on_before_run</code><span class="sig-paren">(</span><em>strategy</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_before_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_err_order_insert">
<code class="descname">on_err_order_insert</code><span class="sig-paren">(</span><em>order_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_err_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoke when insert order is considered to be invalid by the exchange.
:param order_info: dict, order information.</p>
<blockquote>
<div>Keys (non-exhaustively) include:
instrument_id, order_ref, traded_volume, left_volume, status, error_id, error_message</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_error_order_action">
<code class="descname">on_error_order_action</code><span class="sig-paren">(</span><em>order_action_error</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_error_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when cancel order is considered to be invalid by the exchange.
:param order_action_error: dict{string: object}. Information about the order action error.</p>
<blockquote>
<div>Keys (non-exhausively) include: instrument_id, order_ref, error_id, error_message, status_message.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated. Use on_after_run_actions instead.
The action to be invoked when a new trading_day ends.
Parameters:</p>
<blockquote>
<div>context: dict, can store arbitrary data.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_idle_event">
<code class="descname">on_idle_event</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_idle_event" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_investor_position">
<code class="descname">on_investor_position</code><span class="sig-paren">(</span><em>investor_position</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when investor position for a particular future arrived,
requested by get_investor_position.
:param investor_position: dict{string: object}</p>
<blockquote>
<div><dl class="docutils">
<dt>Keys (non-exhaustively) include:</dt>
<dd>instrument_id, volume, direction.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_market_connected">
<code class="descname">on_market_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_market_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_market_disconnected">
<code class="descname">on_market_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_market_disconnected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_market_rsp_error">
<code class="descname">on_market_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_market_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_market_rtn_depth_market_data">
<code class="descname">on_market_rtn_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em>, <em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_market_rtn_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Note: on_* methods which inherits from CtpCallbacks cannot have their parameters renamed.
Parameters:</p>
<blockquote>
<div>p_api: a Python object wrapper for a C pointer, do not need to care.
depth_market_data: CThostFtdcDepthMarketDataField, the data received from CTP market server.
timestamp: datetime, this parameter will be set only in backtesting to avoid parsing time from string.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_mission_control">
<code class="descname">on_mission_control</code><span class="sig-paren">(</span><em>message</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_mission_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when a message from control center is arrived.
:param message: string, the message from the the control center.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_order">
<code class="descname">on_order</code><span class="sig-paren">(</span><em>order_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when order status changes.
:param order_info: dict, order information. The dict includes the following keys (non-exhaustive):</p>
<blockquote>
<div>instrument_id, order_ref, action (type OrderAction), price, volume, timestamp, transaction_id,
traded_volume, left_volume, reason, order_kind (type OrderKind), status.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_order_action">
<code class="descname">on_order_action</code><span class="sig-paren">(</span><em>order_action_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when cancel order is considered to be invalid by front.
:param order_action_info: dict{string: object}, information about the order action.</p>
<blockquote>
<div>Keys (non-exhaustively) include:
broker_id, investor_id, order_ref, action_flag, volume_change, instrument_id, error_id, error_message</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_order_insert">
<code class="descname">on_order_insert</code><span class="sig-paren">(</span><em>order_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when insert order is considered to be invalid by front.
:param order_info: dict, order information.</p>
<blockquote>
<div>Keys (non-exhaustively) include:
instrument_id, order_ref, traded_volume, left_volume, status, error_id, error_message.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_start">
<code class="descname">on_start</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated. Use on_before_run_actions instead.
The action to be invoked when a new trading_day starts.
Parameters:</p>
<blockquote>
<div>context: dict, can store arbitrary data.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_timer">
<code class="descname">on_timer</code><span class="sig-paren">(</span><em>trigger_time</em>, <em>supposed_trigger_time</em>, <em>timer_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when some timer is triggered.
:param trigger_time: datetime, the time when the timer is actually triggered.</p>
<blockquote>
<div>trigger_time and supposed_trigger_time may be different because the timer may be a simulated timer.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>supposed_trigger_time</strong> &#8211; datetime, the time when the timer is supposed to be triggered.</li>
<li><strong>timer_name</strong> &#8211; string, the name of the triggered timer.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_account">
<code class="descname">on_trading_account</code><span class="sig-paren">(</span><em>trading_account</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when trading account information arrives, requested by get_trading_account.
:param trading_account: dict{string:object}</p>
<blockquote>
<div>Keys (non-exhaustively) include: balance, available, curr_margin, commission, close_profit.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_connected">
<code class="descname">on_trading_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_disconnected">
<code class="descname">on_trading_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_disconnected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_err_rtn_order_action">
<code class="descname">on_trading_err_rtn_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>order_action</em>, <em>res_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_err_rtn_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_err_rtn_order_insert">
<code class="descname">on_trading_err_rtn_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>res_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_err_rtn_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_error">
<code class="descname">on_trading_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_order_action">
<code class="descname">on_trading_rsp_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order_action</em>, <em>res_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_order_insert">
<code class="descname">on_trading_rsp_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>res_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_depth_market_data">
<code class="descname">on_trading_rsp_qry_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询行情响应。当客户端发出请求查询行情指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param depth_market_data: CThostFtdcDepthMarketDataField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_instrument">
<code class="descname">on_trading_rsp_qry_instrument</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询合约响应。当客户端发出请求查询合约指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param instrument: CThostFtdcInstrumentField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_instrument_commission_rate">
<code class="descname">on_trading_rsp_qry_instrument_commission_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_commission_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_instrument_commission_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询手续费响应。
:param p_api: c_void_p
:param instrument_commission_rate: CThostFtdcInstrumentCommissionRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_instrument_margin_rate">
<code class="descname">on_trading_rsp_qry_instrument_margin_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_margin_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_instrument_margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询保证金响应。
:param p_api: c_void_p
:param instrument_margin_rate: CThostFtdcInstrumentMarginRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_instrument_order_comm_rate">
<code class="descname">on_trading_rsp_qry_instrument_order_comm_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_order_comm_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_instrument_order_comm_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询下单撤单手续费响应。
:param p_api: c_void_p
:param instrument_order_comm_rate: CThostFtdcInstrumentOrderCommRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_investor_position">
<code class="descname">on_trading_rsp_qry_investor_position</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>b_is_last</strong> &#8211; boolean, True if current information is the last from a possibly list of
information about the requested investor position. One piece of information is returned
for one position direction. If there is positions for both long and short trades for the asked future,
then this callback will be invoked twice, once for each position direction.
This callback will be invoked at most twice for an investor position request.</td>
</tr>
</tbody>
</table>
<p>Note: on_* methods which inherits from CtpCallbacks cannot have their parameters renamed.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_investor_position_detail">
<code class="descname">on_trading_rsp_qry_investor_position_detail</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position_detail</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_investor_position_detail" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询投资者持仓明细响应。当客户端发出请求请求查询投资者持仓明细指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api:c_void_p
:param investor_position_detail: CThostFtdcInvestorPositionDetailField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_order">
<code class="descname">on_trading_rsp_qry_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_order" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询报单响应
:param p_api: c_void_p
:param order: CThostFtdcOrderField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_trade">
<code class="descname">on_trading_rsp_qry_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询成交响应
:param p_api: c_void_p
:param trade: CThostFtdcTradeField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_trading_account">
<code class="descname">on_trading_rsp_qry_trading_account</code><span class="sig-paren">(</span><em>p_api</em>, <em>trading_account</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rsp_qry_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>b_is_last</strong> &#8211; boolean, True if current information is the last from a possibly list of
information about trading account. Normally, there should be only one piece of information
about a trading account. In case the account has multiple currencies (RMB, USD, GDP), there will be
multiple pieces of information, one piece for each currency.</td>
</tr>
</tbody>
</table>
<p>Note: on_* methods which inherits from CtpCallbacks cannot have their parameters renamed.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rtn_order">
<code class="descname">on_trading_rtn_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rtn_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rtn_trade">
<code class="descname">on_trading_rtn_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.on_trading_rtn_trade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.open_limit_order">
<code class="descname">open_limit_order</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.open_limit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a limit order at price. Note that for limit orders, there is no support for enforce_one_direction,
because limit orders cannot guarantee that all positions in one direction are fully closed.
The strategy is responsible for maintaining positions in a single direction, if desirable.
:param price: float, the price.
:param volume: int, the volume to open. Positive volume means open long; Negative volume means open short.
:param kind: OrderKind. Distinguish between Normal, FAK, FOK limit orders.
:param reason: string, a reason for the open operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>enforce_one_direction</strong> &#8211; boolean. If True, close existing positions (if any) which are in the
direction opposite to the direction indicated by volume.
For example, if volume &gt; 0 (meaning to open a long position), and if currently, the account holds some
short directions, enforce_one_direction is True will force the strategy to make an order to close
all short positions as well, resulting in two orders: one to close existing short positions, and the
other to open long directions. Note that the strategy will not wait for the first order to fully execute,
it will place two orders at the same time. This is a simplification, and can be improved in the future.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.
If None, no cancellation policy is specified. The cancellation policy does not affect the
order that has to be placed when enforce_one_direction is True.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.open_market_order">
<code class="descname">open_market_order</code><span class="sig-paren">(</span><em>volume</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.open_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Open market order for future_id. If there is only one future in current strategy, you don&#8217;t need to
provide future_id, self.future_id will be used implicitly.
:param volume: int, the volume to open. Positive volume means open long; Negative volume means open short.
:param reason: string, a reason for the open operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>enforce_one_direction</strong> &#8211; boolean. If True, close existing positions (if any) which are in the
direction opposite to the direction indicated by volume.
For example, if volume &gt; 0 (meaning to open a long position), and if currently, the account holds some
short directions, enforce_one_direction is True will force the strategy to make an order to close
all short positions as well, resulting in two orders: one to close existing short positions, and the
other to open long directions. Note that the strategy will not wait for the first order to fully execute,
it will place two orders at the same time. This is a simplification, and can be improved in the future.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.
If None, no cancellation policy is specified. The cancellation policy does not affect the
order that has to be placed when enforce_one_direction is True.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.open_position">
<code class="descname">open_position</code><span class="sig-paren">(</span><em>volume</em>, <em>price=None</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.open_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a position for the instrument given by instrument_id.
:param volume: int, the position to open,</p>
<blockquote>
<div>positive number means long position, negative number means short position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>price</strong> &#8211; float, if None, send a market order. If not None, send a limit order at that price.</li>
<li><strong>kind</strong> &#8211; OrderKind, the order kind.</li>
<li><strong>reason</strong> &#8211; string, reason for this open position operation.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
<li><strong>transaction_id</strong> &#8211; string, transaction id.</li>
<li><strong>enforce_one_direction</strong> &#8211; boolean. If True, close existing positions (if any) which are in the
direction opposite to the direction indicated by volume.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.place_market_order">
<code class="descname">place_market_order</code><span class="sig-paren">(</span><em>action</em>, <em>volume</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.place_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>make market order for instrument id.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param action: OrderAction, the action kind of current order.
:param volume: int, the volume to close. Positive volume means open close; Negative volume means close short.
:param reason: string, a reason for the close operation.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.
:param enforce_one_direction: boolean. If True, close existing positions (if any) which are in the</p>
<blockquote>
<div>direction opposite to the direction indicated by volume.
For example, if volume &gt; 0 (meaning to open a long position), and if currently, the account holds some
short directions, enforce_one_direction is True will force the strategy to make an order to close
all short positions as well, resulting in two orders: one to close existing short positions, and the
other to open long directions. Note that the strategy will not wait for the first order to fully execute,
it will place two orders at the same time. This is a simplification, and can be improved in the future.</div></blockquote>
<dl class="docutils">
<dt>:return:f</dt>
<dd><dl class="first last docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.product">
<code class="descname">product</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return name of the product to which this strategy belongs.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.remove_bar_arrival_action">
<code class="descname">remove_bar_arrival_action</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.remove_bar_arrival_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the specified bar arrival action.
:param name: string, the bar arrival action name.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.remove_order_cancellations">
<code class="descname">remove_order_cancellations</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.remove_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove order cancellations.
:param order_ref: string, full order reference.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.remove_timer">
<code class="descname">remove_timer</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.remove_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the timer with name.
:param name: string, the timer name.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.safe_instrument_id">
<code class="descname">safe_instrument_id</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.safe_instrument_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the final instrument id.
:param instrument_id: string.
:return: string, the final instrument id.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.send_message">
<code class="descname">send_message</code><span class="sig-paren">(</span><em>message</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.send_message" title="Permalink to this definition">¶</a></dt>
<dd><p>Send message using self.message_sender.
:param message: string, the message to send.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_all_callbacks">
<code class="descname">set_all_callbacks</code><span class="sig-paren">(</span><em>all_callbacks</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_all_callbacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.all_callbacks to all_callbacks.
:param all_callbacks: OrderedDict{string: AbstractStrategyCallbacks},</p>
<blockquote>
<div>The set of individual strategy callbacks. Keys are strategy callback names,
values are callbacks. Note that it is an ordered dict. So when callbacks are invoked,
they follow the order that is given here. The callback names are useful to find
corresponding strategy callbacks from outside.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_ctp_factory">
<code class="descname">set_ctp_factory</code><span class="sig-paren">(</span><em>ctp_factory</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_ctp_factory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_market">
<code class="descname">set_market</code><span class="sig-paren">(</span><em>market</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_market_and_trading">
<code class="descname">set_market_and_trading</code><span class="sig-paren">(</span><em>market</em>, <em>trading</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_market_and_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_should_exit">
<code class="descname">set_should_exit</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_should_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self._should_exit to the given boolean.
:param b: boolean, the value to set self._should_exit.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_should_use_remote_account_and_position">
<code class="descname">set_should_use_remote_account_and_position</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_should_use_remote_account_and_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_step_action">
<code class="descname">set_step_action</code><span class="sig-paren">(</span><em>action</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_step_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_strategy_callbacks">
<code class="descname">set_strategy_callbacks</code><span class="sig-paren">(</span><em>callbacks</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_strategy_callbacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.strategy_callbacks according to callbacks.
:param callbacks: AbstractStrategyCallbacks, the external strategy callbacks.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_trading">
<code class="descname">set_trading</code><span class="sig-paren">(</span><em>trading</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_use_mid_ask_bid">
<code class="descname">set_use_mid_ask_bid</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.set_use_mid_ask_bid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.setup_order_cancellations">
<code class="descname">setup_order_cancellations</code><span class="sig-paren">(</span><em>order_ref</em>, <em>order_place_time</em>, <em>instrument_id</em>, <em>cancellation</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.setup_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup order cancellation.
:param order_ref: string, full order reference.
:param order_place_time: datetime, the time when the order is placed.
:param instrument_id: string, the instrument to trade.
:param cancellation: AbstractOrderCancellation, order cancellation policy.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.short_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return long positions for future_id.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: int, the short position, negative value or zero.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.should_exit">
<code class="descname">should_exit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.should_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Should current strategy exit?
:return: boolean, True if current strategy should exit.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.should_use_remote_account_and_position">
<code class="descname">should_use_remote_account_and_position</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.should_use_remote_account_and_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in stat machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.store_ohlcs">
<code class="descname">store_ohlcs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.store_ohlcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Store OHLCS for all instruments, all registered periods into files.
Only needed in real-trading mode.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.strategy_last_bar_so_far">
<code class="descname">strategy_last_bar_so_far</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.strategy_last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of current strategy.
:return: string, name of the current strategy.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.strategy_ohlc">
<code class="descname">strategy_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.strategy_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.strategy_period">
<code class="descname">strategy_period</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.strategy_period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.strategy_period_kind">
<code class="descname">strategy_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.strategy_period_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.trading">
<code class="descname">trading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.trading_account_id">
<code class="descname">trading_account_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.trading_account_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Current trading account id.
:return: string, the trading account id.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.ChangePositionStrategy.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="ctxalgoctp.ctp.live.change_positions.main">
<code class="descclassname">ctxalgoctp.ctp.live.change_positions.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.change_positions.main" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.live.connect_to_ctp"></span><dl class="class">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.live.connect_to_ctp.</code><code class="descname">JustConnectStrategy</code><span class="sig-paren">(</span><em>instrument_ids</em>, <em>strategy_period</em>, <em>parameters</em>, <em>base_folder</em>, <em>periods=None</em>, <em>description=None</em>, <em>logger=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.strategy.AbstractStrategy" title="ctxalgoctp.ctp.strategy.AbstractStrategy"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.strategy.AbstractStrategy</span></code></a></p>
<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_before_run">
<code class="descname">on_before_run</code><span class="sig-paren">(</span><em>strategy</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_before_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_timer">
<code class="descname">on_timer</code><span class="sig-paren">(</span><em>trigger_time</em>, <em>supposed_trigger_time</em>, <em>timer_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_timer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.TRADING_CONNECTED">
<code class="descname">TRADING_CONNECTED</code><em class="property"> = 1</em><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.TRADING_CONNECTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.TRADING_NOT_CONNECTED">
<code class="descname">TRADING_NOT_CONNECTED</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.TRADING_NOT_CONNECTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.add_bar_arrival_action">
<code class="descname">add_bar_arrival_action</code><span class="sig-paren">(</span><em>action</em>, <em>period=None</em>, <em>instrument_ids=None</em>, <em>ohlc_kind='time-based'</em>, <em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.add_bar_arrival_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup an action, which will be called when all required ohlc bars have arrived.
For example, if period=Periodicity.HOURLY, and instrument_ids are the list of all the traded instruments,
then action will be called the next time when all hourly bars for the traded instruments have arrived.
:param action: function pointer with the following four parameters:</p>
<blockquote>
<div><p>ohlc_kind: string, the ohlc kind, can be &#8216;time-based&#8217;, &#8216;volatility-based&#8217;.
period: Periodicity in case of time-based ohlc, or int/float as volatility threshold</p>
<blockquote>
<div>in case of volatility-based ohlc.</div></blockquote>
<p>name: string, the bar arrival action name, same as the name parameter specified here.
ohlcs: dict{string: OHLC}, the list of ohlcs, keys are instrument ids, values are the ohlc objects.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>period</strong> &#8211; Periodicity in case of time-based ohlc, or int/float as volatility threshold
in case of volatility-based ohlc. This is the period for the required ohlc bars.
If None, use self.strategy_period().
This will be passed into the action when it is invoked.</li>
<li><strong>instrument_ids</strong> &#8211; [string], the list of instruments whose last ohlc bar of required period must
arrived before action can be invoked. If None, defaults to self.instrument_ids(), which are
the full list of traded instruments.</li>
<li><strong>ohlc_kind</strong> &#8211; string, the ohlc kind, can be &#8216;time-based&#8217;, &#8216;volatility-based&#8217;.
This will be passed into the action when it is invoked.</li>
<li><strong>name</strong> &#8211; string, the bar arrival action name, used to identify different bar arrival requests.
This will be passed into the action when it is invoked.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.add_timer">
<code class="descname">add_timer</code><span class="sig-paren">(</span><em>timer=None</em>, <em>trigger_time=None</em>, <em>timedelta=None</em>, <em>on_time_action=None</em>, <em>start=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.add_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Add timer into current strategy.
:param timer: SimulatedTimer, the timer to add. If None, use trigger_time to create a timer.
:param trigger_time: datetime or time, or string in form of yyyy-mm-dd or yyyy-mm-dd HH:MM:SS, or</p>
<blockquote>
<div>a list of the above types. The time(s) used to create a timer .
If specified, create an alarm timer.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>timedelta</strong> &#8211; timedelta, if specified, create a repeated count down timer.</li>
<li><strong>on_time_action</strong> &#8211; function pointer whose signature is same as self.on_timer.
If not None and there is no on_time_action set in timer, then set this as the callback for timer.
If None and there is no on_time_action in timer, then set self.on_timer into the timer.</li>
<li><strong>start</strong> &#8211; boolean, if True start the timer right away.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return string, the name of the added timer.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd><p>Return position details for all traded instruments.
:return: dict{string: dict{string: [dict{string: object}]}}</p>
<blockquote>
<div><p>The out most keys are instrument ides, and the values are the same as the result of self.position_details.
For example:
{</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;IF99&#8217;: {</dt>
<dd><dl class="first last docutils">
<dt>&#8216;long&#8217;: [</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>{</dt>
<dd>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</dd>
</dl>
<p>}, ...</p>
</div></blockquote>
<p class="last">],</p>
</dd>
<dt>&#8216;short&#8217;: [</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>{</dt>
<dd>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</dd>
</dl>
<p>}, ...</p>
</div></blockquote>
<p class="last">],</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.calculate_latest_market_end_time">
<code class="descname">calculate_latest_market_end_time</code><span class="sig-paren">(</span><em>market_periods</em>, <em>now</em>, <em>delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.calculate_latest_market_end_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Given traded instruments and current timestamp, calculate when the market will be closed.
This is used by the strategy infrastructure to decide when to exit strategies: strategies
should terminate after the latest market periods of the traded instrument ends, plus</p>
<blockquote>
<div>a given extra time. This automatic termination only has effect
when self.should_terminate_after_market_close is True.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param:</th><td class="field-body"><p class="first">market_periods, dict{string: [(time, time)]}, keys are instrument ids, values are market periods.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>now</strong> &#8211; datetime, current timestamp.</li>
<li><strong>delta</strong> &#8211; timedelta, some extra amount of time that is added into the traded market periods to allow
the strategy to continue running for some time after the market closes, for example, to do
some bookkeeping work. If None, no extra time is added.</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">datetime, the time when strategies should terminate.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.cancel_order">
<code class="descname">cancel_order</code><span class="sig-paren">(</span><em>order_ref</em>, <em>reason=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.cancel_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel order.
:param order_ref: string, the order reference.
:param reason: string, the reason for cancelling the order.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.change_position_to">
<code class="descname">change_position_to</code><span class="sig-paren">(</span><em>new_position</em>, <em>price=None</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.change_position_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the position of the given instrument to new_position. If price is given, all underlying orders
are limit orders at that price, otherwise, market orders.
:param new_position: int, the new position for the instrument.
:param price: float, if None, newly placed orders are market orders, otherwise, limit orders.
:param reason: string, the reason for this operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.
:param cancellation: AbstractOrderCancellation, the cancellation policy for current order.</p>
<blockquote>
<div>If None, no cancellation policy is specified.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd>may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.change_positions_to">
<code class="descname">change_positions_to</code><span class="sig-paren">(</span><em>new_positions</em>, <em>prices=None</em>, <em>reason=''</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.change_positions_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Change positions of multiple instruments to their new values.
:param new_positions: dict{string: int}, keys are instrument ids,</p>
<blockquote>
<div>values are the new positions for those instruments.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>prices</strong> &#8211; dict{string: float}, keys are instrument ids,
values are prices at which limit orders are placed. If prices is None, all orders are market orders.
If prices is a dict and for some instrument (through dict keys), the key is missing or the value
is None, then the orders for that instrument are market orders, otherwise, limit orders.</li>
<li><strong>reason</strong> &#8211; string, the reason for current order(s).</li>
<li><strong>transaction_id</strong> &#8211; string, transition id, set to None.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the order cancellation policy used to
cancel all the placed orders.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.check_bar_based_order_cancellations">
<code class="descname">check_bar_based_order_cancellations</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>bars</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.check_bar_based_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.check_order_cancellations">
<code class="descname">check_order_cancellations</code><span class="sig-paren">(</span><em>cancellations</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.check_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if we should cancel some orders because of previously setup order cancellations.
:param cancellations: [AbstractOrderCancellation], the list of order cancellations.
:param data: dict{string: object}, the data needed by order cancellations to decide</p>
<blockquote>
<div>whether pending orders should be cancelled. Different kinds of order cancellations
need different data.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.check_time_based_order_cancellations">
<code class="descname">check_time_based_order_cancellations</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.check_time_based_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if there are some order cancellation that should be triggered by the given timestamp now.
If so, cancel those orders.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.check_timers">
<code class="descname">check_timers</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.check_timers" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if there are some timers that can be triggered by the given timestamp now.
If so, call self.on_timer.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.close_limit_order">
<code class="descname">close_limit_order</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.close_limit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a limit order at price. Note that for limit orders, there is no support for enforce_one_direction,
because limit orders cannot guarantee that all positions in one direction are fully closed.
The strategy is responsible for maintaining positions in a single direction, if desirable.
:param price: float, the price.
:param volume: int, the volume to open. Positive volume means open long; Negative volume means open short.
:param kind: OrderKind. Distinguish between Normal, FAK, FOK limit orders.
:param reason: string, a reason for the open operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd>may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.close_market_order">
<code class="descname">close_market_order</code><span class="sig-paren">(</span><em>volume</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.close_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Close market order for future_id. If there is only one future in current strategy, you don&#8217;t need to
provide future_id, self.future_id will be used implicitly.
:param volume: int, the volume to close. Positive volume means open close; Negative volume means close short.
:param reason: string, a reason for the close operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd>may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.close_position">
<code class="descname">close_position</code><span class="sig-paren">(</span><em>volume</em>, <em>price=None</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.close_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a position for the instrumeent given by instrument_id.
:param price: float, if None, send a market order. If not None, send a limit order at that price.
:param kind: OrderKind, the order kind.
:param reason: string, reason for this open position operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:param transaction_id: string, transaction id.
:param cancellation: AbstractOrderCancellation, the cancellation policy for current order.
:return:</p>
<blockquote>
<div><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.data_feed">
<code class="descname">data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.data_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.delete_context_file">
<code class="descname">delete_context_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.delete_context_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the context.txt file.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.does_indicator_calculator_contain_ohlc_kind">
<code class="descname">does_indicator_calculator_contain_ohlc_kind</code><span class="sig-paren">(</span><em>indicator_calculators</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.does_indicator_calculator_contain_ohlc_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Does indicator_calculators contains ohlc kind information?
:param indicator_calculators:
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.dominant_instrument">
<code class="descname">dominant_instrument</code><span class="sig-paren">(</span><em>instrument_prefix</em>, <em>trading_day</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.dominant_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level dominant instrument id on the given trading day.
:param instrument_prefix: string, instrument id prefix, such as IF, cu.
:param trading_day: date, or string in form of yyyy-mm-dd. trading day.
:param level: int, 0 means the dominant contract, 1 means the next dominant contract, and so on.
:return: string, the instrument id of the asked dominant contract.</p>
<blockquote>
<div>If no such dominant contract, return None.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.dump_json">
<code class="descname">dump_json</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.dump_json" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.get_datetime_from_string">
<code class="descname">get_datetime_from_string</code><span class="sig-paren">(</span><em>day</em>, <em>time_</em>, <em>milli</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.get_datetime_from_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a datetime object from day, <a href="#id25"><span class="problematic" id="id26">time_</span></a> and milli.
Parameters:</p>
<blockquote>
<div>day: string, a string representation of a date, in format yyyymmdd.
<a href="#id27"><span class="problematic" id="id28">time_</span></a>: string, a string representation of a time, in format HH:MM:SS.
milli: string, a strign representation of milliseconds, in format of an integer.</div></blockquote>
<p>Return: datetime, a parsed datetime object.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.get_investor_position">
<code class="descname">get_investor_position</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.get_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a request for investor position for the given future.
:param instrument_id: string, instrument id. If an empty string, then get</p>
<blockquote>
<div>positions for all the held instruments.</div></blockquote>
<p>The returned information will be accessible through the corresponding callback function.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.get_order">
<code class="descname">get_order</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.get_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Return order information.
:param order_ref: string, the order reference number returned when placing an order via</p>
<blockquote>
<div>open_market_order, open_limit_order, close_market_order or close_limit_order.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}. The order object. None if no order if found by order_ref.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.get_order_status">
<code class="descname">get_order_status</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.get_order_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the status of an order.
:param order_ref: string, the order reference number returned when placing an order via</p>
<blockquote>
<div>open_market_order, open_limit_order, close_market_order or close_limit_order.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">OrderStatus. The status of the order. None if no order is found by order_ref.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.get_trading_account">
<code class="descname">get_trading_account</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.get_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a request for trading account information.
The returned information will be accessible through the corresponding callback function.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.has_data_feed">
<code class="descname">has_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.has_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is data feed set?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.has_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Has current strategy started running&gt;
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.indicator">
<code class="descname">indicator</code><span class="sig-paren">(</span><em>name</em>, <em>kind=None</em>, <em>period=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.indicator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the last calculated value(s) for the given indicator alias.
:param kind: string, kind of the ohlc on which indicators are calculated.</p>
<blockquote>
<div>Valid values are &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.
If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> &#8211; string, name of the indicator.</li>
<li><strong>period</strong> &#8211; Periodicity or int/float, the period of the indicator. If None, use self.strategy_period().
If kind is &#8216;volatility-based&#8217;, type of period is int/float, indicating volatility threshold.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id on which the indicator is calculated.
If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object, indicator result.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.initialize_before_run">
<code class="descname">initialize_before_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.initialize_before_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.is_trading_connected">
<code class="descname">is_trading_connected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.is_trading_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.last_bar_so_far">
<code class="descname">last_bar_so_far</code><span class="sig-paren">(</span><em>periodicity</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_cancel_order">
<code class="descname">log_cancel_order</code><span class="sig-paren">(</span><em>order_ref_id</em>, <em>order_ref</em>, <em>reason</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_cancel_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Log cancel order.
:param order_ref: string, order reference.
:param reason: string, the reason for order.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_connect_to_market">
<code class="descname">log_connect_to_market</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_connect_to_market" title="Permalink to this definition">¶</a></dt>
<dd><p>Log the action to connect to the market data server.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_connect_to_trading">
<code class="descname">log_connect_to_trading</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_connect_to_trading" title="Permalink to this definition">¶</a></dt>
<dd><p>Log the action to connect to the trading server.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_err_order_action">
<code class="descname">log_err_order_action</code><span class="sig-paren">(</span><em>order_ref</em>, <em>order_action</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_err_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_err_order_insert">
<code class="descname">log_err_order_insert</code><span class="sig-paren">(</span><em>order_ref</em>, <em>input_order</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_err_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_exception">
<code class="descname">log_exception</code><span class="sig-paren">(</span><em>e</em>, <em>tb</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_exception" title="Permalink to this definition">¶</a></dt>
<dd><p>Log exception.
:param Exception, the exception object.
:param tb string, the traceback.
:param other_data: dict{string: object}, other kinds of data.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_investor_position">
<code class="descname">log_investor_position</code><span class="sig-paren">(</span><em>investor_position</em>, <em>timestamp</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Log investor position.
:param investor_position: The investor position object.
:param is_last: boolean, is the result the last batch.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_ohlc">
<code class="descname">log_ohlc</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>bars</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Log ohlc.
:param instrument_id: string, the instrument id.
:param bars: dict{string: dict{Periodicity or int/float: Bar}} The bars.</p>
<blockquote>
<div>Outer keys are ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.
Inner keys are Periodicity or volatility thresholds, inner values are the generated bars.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_order">
<code class="descname">log_order</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>action</em>, <em>volume</em>, <em>order_ref</em>, <em>reason</em>, <em>transaction_id</em>, <em>order_kind='Market'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Log order.
:param instrument_id: string, the instrument id.
:param action: OrderAction, the action of this order.
:param volume: int, volume to trade.</p>
<blockquote>
<div>Positive volume means long position, negative volume means short position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>order_ref</strong> &#8211; int, order reference.</li>
<li><strong>reason</strong> &#8211; string the reason for order.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param transaction_id, int, the transaction id.
:param order_kind: OrderKind. The kind of the order.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_order_action">
<code class="descname">log_order_action</code><span class="sig-paren">(</span><em>order_ref</em>, <em>order_action</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_order_insert">
<code class="descname">log_order_insert</code><span class="sig-paren">(</span><em>order_ref</em>, <em>input_order</em>, <em>rsp_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_rtn_order">
<code class="descname">log_rtn_order</code><span class="sig-paren">(</span><em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_rtn_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_signal">
<code class="descname">log_signal</code><span class="sig-paren">(</span><em>signal</em>, <em>tag=None</em>, <em>reason=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Log signal.
:param signal: EntrySignal, the signal to log.
:param tag: string, the tag to use, if None, the method will decide a tag name.
:param reason: string, some additional reason. Can be None if there is no reason.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_state_transition">
<code class="descname">log_state_transition</code><span class="sig-paren">(</span><em>start_state</em>, <em>end_state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_state_transition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_stop_loss">
<code class="descname">log_stop_loss</code><span class="sig-paren">(</span><em>timestamp</em>, <em>direction</em>, <em>value</em>, <em>transaction_id</em>, <em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_stop_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Log stop loss.
Parameters:</p>
<blockquote>
<div><p>timestamp: datetime, the time when the stop loss is calculated.
direction: int, 1 means long stop loss, -1 means short stop loss.
value: float, the stop loss value.
transaction_id: string, transaction id.
name: string, a possible additional name for the stop loss line. This is helpful to</p>
<blockquote>
<div>support multiple stop lines (for example, a close-bar stop loss and an in-bar stop loss)
for the same transaction.</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_strategy">
<code class="descname">log_strategy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_strategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Log information about current strategy.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_strategy_info">
<code class="descname">log_strategy_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_strategy_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_trade">
<code class="descname">log_trade</code><span class="sig-paren">(</span><em>trade</em>, <em>extra_info</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_trade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_trading_account">
<code class="descname">log_trading_account</code><span class="sig-paren">(</span><em>account</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Log trading account.
:param account, the trading account object.
:param is_last: boolean, is the result the last batch.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_with_tag">
<code class="descname">log_with_tag</code><span class="sig-paren">(</span><em>tag</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.log_with_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Log data with tag.
:param tag: string, the log message tag indicating the kind of the message, for example, BAR, ORDER, ACCOUNT.
:param data: dict{string: object}, the data to be logged. Keys are data item names, values are data items.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.long_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return long positions for future_id.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: int, the long position, positive value or zero.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.market">
<code class="descname">market</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.mission_control">
<code class="descname">mission_control</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.mission_control" title="Permalink to this definition">¶</a></dt>
<dd><p>The mission control. The mission control is set through self.ctp_factory.set_mission_control.
:return: MissionControl. If no mission control is set, return None.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.now" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_bar">
<code class="descname">on_bar</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>bars</em>, <em>tick</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_bar" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when there is some ohlc bars generated.
:param instrument_id, string, the instrument id of the generated bar(s).
:param bars: dict{string: dict{Periodicity or int/float: Bar}.</p>
<blockquote>
<div>Meaning: dict{ohlc_kind: dict{period or volatility threshold: Bar}
Outer keys are ohlc kind such as &#8216;time-based&#8217;, &#8216;volatility-based&#8217; from OhlcGeneratorConstants.
Outer values are dict from Periodicity to Bar in the case of time-based ohlcs or
dict from int/float to Bar in the case of volatility-based ohlcs.
It may contains more than one bars: a single bar under each periodicity.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tick</strong> &#8211; dict{string: object}, the tick which triggers current ohlc bar(s) generation.
The object has the following keys (non-exhaustive):
timestamp, last_price, volume, ask_price1, ask_volume1, bid_price1, bid_volume1,
pre_open_interest, open_interest. Note that when backtesting, only when the data source is tick level,
tick includes order book information such as ask_price1, bid_price1. Otherwise, those order book
related fields will have default values.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_bar_from_zmq">
<code class="descname">on_bar_from_zmq</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_bar_from_zmq" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when there is a bar arrives from zeromq bar feed.
:param data: dict{string: object}, the bar information.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_bar_method">
<code class="descname">on_bar_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_bar_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the function pointer for on_bar.
:return: function pointer.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_err_order_insert">
<code class="descname">on_err_order_insert</code><span class="sig-paren">(</span><em>order_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_err_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoke when insert order is considered to be invalid by the exchange.
:param order_info: dict, order information.</p>
<blockquote>
<div>Keys (non-exhaustively) include:
instrument_id, order_ref, traded_volume, left_volume, status, error_id, error_message</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_error_order_action">
<code class="descname">on_error_order_action</code><span class="sig-paren">(</span><em>order_action_error</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_error_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when cancel order is considered to be invalid by the exchange.
:param order_action_error: dict{string: object}. Information about the order action error.</p>
<blockquote>
<div>Keys (non-exhausively) include: instrument_id, order_ref, error_id, error_message, status_message.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated. Use on_after_run_actions instead.
The action to be invoked when a new trading_day ends.
Parameters:</p>
<blockquote>
<div>context: dict, can store arbitrary data.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_idle_event">
<code class="descname">on_idle_event</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_idle_event" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_investor_position">
<code class="descname">on_investor_position</code><span class="sig-paren">(</span><em>investor_position</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when investor position for a particular future arrived,
requested by get_investor_position.
:param investor_position: dict{string: object}</p>
<blockquote>
<div><dl class="docutils">
<dt>Keys (non-exhaustively) include:</dt>
<dd>instrument_id, volume, direction.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_market_connected">
<code class="descname">on_market_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_market_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_market_disconnected">
<code class="descname">on_market_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_market_disconnected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_market_rsp_error">
<code class="descname">on_market_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_market_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_market_rtn_depth_market_data">
<code class="descname">on_market_rtn_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em>, <em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_market_rtn_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Note: on_* methods which inherits from CtpCallbacks cannot have their parameters renamed.
Parameters:</p>
<blockquote>
<div>p_api: a Python object wrapper for a C pointer, do not need to care.
depth_market_data: CThostFtdcDepthMarketDataField, the data received from CTP market server.
timestamp: datetime, this parameter will be set only in backtesting to avoid parsing time from string.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_mission_control">
<code class="descname">on_mission_control</code><span class="sig-paren">(</span><em>message</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_mission_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when a message from control center is arrived.
:param message: string, the message from the the control center.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_order">
<code class="descname">on_order</code><span class="sig-paren">(</span><em>order_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when order status changes.
:param order_info: dict, order information. The dict includes the following keys (non-exhaustive):</p>
<blockquote>
<div>instrument_id, order_ref, action (type OrderAction), price, volume, timestamp, transaction_id,
traded_volume, left_volume, reason, order_kind (type OrderKind), status.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_order_action">
<code class="descname">on_order_action</code><span class="sig-paren">(</span><em>order_action_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when cancel order is considered to be invalid by front.
:param order_action_info: dict{string: object}, information about the order action.</p>
<blockquote>
<div>Keys (non-exhaustively) include:
broker_id, investor_id, order_ref, action_flag, volume_change, instrument_id, error_id, error_message</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_order_insert">
<code class="descname">on_order_insert</code><span class="sig-paren">(</span><em>order_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when insert order is considered to be invalid by front.
:param order_info: dict, order information.</p>
<blockquote>
<div>Keys (non-exhaustively) include:
instrument_id, order_ref, traded_volume, left_volume, status, error_id, error_message.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_start">
<code class="descname">on_start</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated. Use on_before_run_actions instead.
The action to be invoked when a new trading_day starts.
Parameters:</p>
<blockquote>
<div>context: dict, can store arbitrary data.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_tick">
<code class="descname">on_tick</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>tick</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when there is some new market data.
Note: When current new data can cause one or more
ohlc bars to be generated, those bars are first generated, meaning that the callback on_bar
will be first invoked with the generated new bars, and then this callback will be invoked.
:param instrument_id: string, instrument id.
:param tick: dict{string: object}, tick data. The object has the following keys (non-exhaustive):</p>
<blockquote>
<div>timestamp, last_price, volume, ask_price1, ask_volume1, bid_price1, bid_volume1,
pre_open_interest, open_interest.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trade">
<code class="descname">on_trade</code><span class="sig-paren">(</span><em>trade_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when a trade occurs in the exchange. After an order is placed ,
when (part of) the order is traded, there is a callback to this action.
An order may be executed through several trades, so there may be several invocation
of this action for a single order.
:param trade_info: dict, providing information of the trade.</p>
<blockquote>
<div>Keys (non-exhaustively) include:
instrument_id, slippage, commission, profits, transaction_id, traded_volume, left_volume,
order_ref, current_traded_volume, current_traded_price, action, reason, kind, status.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_account">
<code class="descname">on_trading_account</code><span class="sig-paren">(</span><em>trading_account</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when trading account information arrives, requested by get_trading_account.
:param trading_account: dict{string:object}</p>
<blockquote>
<div>Keys (non-exhaustively) include: balance, available, curr_margin, commission, close_profit.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_connected">
<code class="descname">on_trading_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_disconnected">
<code class="descname">on_trading_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_disconnected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_err_rtn_order_action">
<code class="descname">on_trading_err_rtn_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>order_action</em>, <em>res_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_err_rtn_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_err_rtn_order_insert">
<code class="descname">on_trading_err_rtn_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>res_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_err_rtn_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_error">
<code class="descname">on_trading_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_order_action">
<code class="descname">on_trading_rsp_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order_action</em>, <em>res_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_order_insert">
<code class="descname">on_trading_rsp_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>res_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_depth_market_data">
<code class="descname">on_trading_rsp_qry_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询行情响应。当客户端发出请求查询行情指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param depth_market_data: CThostFtdcDepthMarketDataField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_instrument">
<code class="descname">on_trading_rsp_qry_instrument</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询合约响应。当客户端发出请求查询合约指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param instrument: CThostFtdcInstrumentField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_instrument_commission_rate">
<code class="descname">on_trading_rsp_qry_instrument_commission_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_commission_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_instrument_commission_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询手续费响应。
:param p_api: c_void_p
:param instrument_commission_rate: CThostFtdcInstrumentCommissionRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_instrument_margin_rate">
<code class="descname">on_trading_rsp_qry_instrument_margin_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_margin_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_instrument_margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询保证金响应。
:param p_api: c_void_p
:param instrument_margin_rate: CThostFtdcInstrumentMarginRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_instrument_order_comm_rate">
<code class="descname">on_trading_rsp_qry_instrument_order_comm_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_order_comm_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_instrument_order_comm_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询下单撤单手续费响应。
:param p_api: c_void_p
:param instrument_order_comm_rate: CThostFtdcInstrumentOrderCommRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_investor_position">
<code class="descname">on_trading_rsp_qry_investor_position</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>b_is_last</strong> &#8211; boolean, True if current information is the last from a possibly list of
information about the requested investor position. One piece of information is returned
for one position direction. If there is positions for both long and short trades for the asked future,
then this callback will be invoked twice, once for each position direction.
This callback will be invoked at most twice for an investor position request.</td>
</tr>
</tbody>
</table>
<p>Note: on_* methods which inherits from CtpCallbacks cannot have their parameters renamed.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_investor_position_detail">
<code class="descname">on_trading_rsp_qry_investor_position_detail</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position_detail</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_investor_position_detail" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询投资者持仓明细响应。当客户端发出请求请求查询投资者持仓明细指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api:c_void_p
:param investor_position_detail: CThostFtdcInvestorPositionDetailField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_order">
<code class="descname">on_trading_rsp_qry_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_order" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询报单响应
:param p_api: c_void_p
:param order: CThostFtdcOrderField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_trade">
<code class="descname">on_trading_rsp_qry_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询成交响应
:param p_api: c_void_p
:param trade: CThostFtdcTradeField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_trading_account">
<code class="descname">on_trading_rsp_qry_trading_account</code><span class="sig-paren">(</span><em>p_api</em>, <em>trading_account</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rsp_qry_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>b_is_last</strong> &#8211; boolean, True if current information is the last from a possibly list of
information about trading account. Normally, there should be only one piece of information
about a trading account. In case the account has multiple currencies (RMB, USD, GDP), there will be
multiple pieces of information, one piece for each currency.</td>
</tr>
</tbody>
</table>
<p>Note: on_* methods which inherits from CtpCallbacks cannot have their parameters renamed.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rtn_order">
<code class="descname">on_trading_rtn_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rtn_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rtn_trade">
<code class="descname">on_trading_rtn_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.on_trading_rtn_trade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.open_limit_order">
<code class="descname">open_limit_order</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.open_limit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a limit order at price. Note that for limit orders, there is no support for enforce_one_direction,
because limit orders cannot guarantee that all positions in one direction are fully closed.
The strategy is responsible for maintaining positions in a single direction, if desirable.
:param price: float, the price.
:param volume: int, the volume to open. Positive volume means open long; Negative volume means open short.
:param kind: OrderKind. Distinguish between Normal, FAK, FOK limit orders.
:param reason: string, a reason for the open operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>enforce_one_direction</strong> &#8211; boolean. If True, close existing positions (if any) which are in the
direction opposite to the direction indicated by volume.
For example, if volume &gt; 0 (meaning to open a long position), and if currently, the account holds some
short directions, enforce_one_direction is True will force the strategy to make an order to close
all short positions as well, resulting in two orders: one to close existing short positions, and the
other to open long directions. Note that the strategy will not wait for the first order to fully execute,
it will place two orders at the same time. This is a simplification, and can be improved in the future.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.
If None, no cancellation policy is specified. The cancellation policy does not affect the
order that has to be placed when enforce_one_direction is True.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.open_market_order">
<code class="descname">open_market_order</code><span class="sig-paren">(</span><em>volume</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.open_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Open market order for future_id. If there is only one future in current strategy, you don&#8217;t need to
provide future_id, self.future_id will be used implicitly.
:param volume: int, the volume to open. Positive volume means open long; Negative volume means open short.
:param reason: string, a reason for the open operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>enforce_one_direction</strong> &#8211; boolean. If True, close existing positions (if any) which are in the
direction opposite to the direction indicated by volume.
For example, if volume &gt; 0 (meaning to open a long position), and if currently, the account holds some
short directions, enforce_one_direction is True will force the strategy to make an order to close
all short positions as well, resulting in two orders: one to close existing short positions, and the
other to open long directions. Note that the strategy will not wait for the first order to fully execute,
it will place two orders at the same time. This is a simplification, and can be improved in the future.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.
If None, no cancellation policy is specified. The cancellation policy does not affect the
order that has to be placed when enforce_one_direction is True.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.open_position">
<code class="descname">open_position</code><span class="sig-paren">(</span><em>volume</em>, <em>price=None</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.open_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a position for the instrument given by instrument_id.
:param volume: int, the position to open,</p>
<blockquote>
<div>positive number means long position, negative number means short position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>price</strong> &#8211; float, if None, send a market order. If not None, send a limit order at that price.</li>
<li><strong>kind</strong> &#8211; OrderKind, the order kind.</li>
<li><strong>reason</strong> &#8211; string, reason for this open position operation.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
<li><strong>transaction_id</strong> &#8211; string, transaction id.</li>
<li><strong>enforce_one_direction</strong> &#8211; boolean. If True, close existing positions (if any) which are in the
direction opposite to the direction indicated by volume.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.place_market_order">
<code class="descname">place_market_order</code><span class="sig-paren">(</span><em>action</em>, <em>volume</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.place_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>make market order for instrument id.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param action: OrderAction, the action kind of current order.
:param volume: int, the volume to close. Positive volume means open close; Negative volume means close short.
:param reason: string, a reason for the close operation.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.
:param enforce_one_direction: boolean. If True, close existing positions (if any) which are in the</p>
<blockquote>
<div>direction opposite to the direction indicated by volume.
For example, if volume &gt; 0 (meaning to open a long position), and if currently, the account holds some
short directions, enforce_one_direction is True will force the strategy to make an order to close
all short positions as well, resulting in two orders: one to close existing short positions, and the
other to open long directions. Note that the strategy will not wait for the first order to fully execute,
it will place two orders at the same time. This is a simplification, and can be improved in the future.</div></blockquote>
<dl class="docutils">
<dt>:return:f</dt>
<dd><dl class="first last docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.product">
<code class="descname">product</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return name of the product to which this strategy belongs.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.remove_bar_arrival_action">
<code class="descname">remove_bar_arrival_action</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.remove_bar_arrival_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the specified bar arrival action.
:param name: string, the bar arrival action name.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.remove_order_cancellations">
<code class="descname">remove_order_cancellations</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.remove_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove order cancellations.
:param order_ref: string, full order reference.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.remove_timer">
<code class="descname">remove_timer</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.remove_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the timer with name.
:param name: string, the timer name.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.safe_instrument_id">
<code class="descname">safe_instrument_id</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.safe_instrument_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the final instrument id.
:param instrument_id: string.
:return: string, the final instrument id.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.send_message">
<code class="descname">send_message</code><span class="sig-paren">(</span><em>message</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.send_message" title="Permalink to this definition">¶</a></dt>
<dd><p>Send message using self.message_sender.
:param message: string, the message to send.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_all_callbacks">
<code class="descname">set_all_callbacks</code><span class="sig-paren">(</span><em>all_callbacks</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_all_callbacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.all_callbacks to all_callbacks.
:param all_callbacks: OrderedDict{string: AbstractStrategyCallbacks},</p>
<blockquote>
<div>The set of individual strategy callbacks. Keys are strategy callback names,
values are callbacks. Note that it is an ordered dict. So when callbacks are invoked,
they follow the order that is given here. The callback names are useful to find
corresponding strategy callbacks from outside.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_ctp_factory">
<code class="descname">set_ctp_factory</code><span class="sig-paren">(</span><em>ctp_factory</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_ctp_factory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_market">
<code class="descname">set_market</code><span class="sig-paren">(</span><em>market</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_market_and_trading">
<code class="descname">set_market_and_trading</code><span class="sig-paren">(</span><em>market</em>, <em>trading</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_market_and_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_should_exit">
<code class="descname">set_should_exit</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_should_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self._should_exit to the given boolean.
:param b: boolean, the value to set self._should_exit.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_should_use_remote_account_and_position">
<code class="descname">set_should_use_remote_account_and_position</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_should_use_remote_account_and_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_step_action">
<code class="descname">set_step_action</code><span class="sig-paren">(</span><em>action</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_step_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_strategy_callbacks">
<code class="descname">set_strategy_callbacks</code><span class="sig-paren">(</span><em>callbacks</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_strategy_callbacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.strategy_callbacks according to callbacks.
:param callbacks: AbstractStrategyCallbacks, the external strategy callbacks.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_trading">
<code class="descname">set_trading</code><span class="sig-paren">(</span><em>trading</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_use_mid_ask_bid">
<code class="descname">set_use_mid_ask_bid</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.set_use_mid_ask_bid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.setup_order_cancellations">
<code class="descname">setup_order_cancellations</code><span class="sig-paren">(</span><em>order_ref</em>, <em>order_place_time</em>, <em>instrument_id</em>, <em>cancellation</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.setup_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup order cancellation.
:param order_ref: string, full order reference.
:param order_place_time: datetime, the time when the order is placed.
:param instrument_id: string, the instrument to trade.
:param cancellation: AbstractOrderCancellation, order cancellation policy.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.short_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return long positions for future_id.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: int, the short position, negative value or zero.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.should_exit">
<code class="descname">should_exit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.should_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Should current strategy exit?
:return: boolean, True if current strategy should exit.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.should_use_remote_account_and_position">
<code class="descname">should_use_remote_account_and_position</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.should_use_remote_account_and_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in stat machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.store_ohlcs">
<code class="descname">store_ohlcs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.store_ohlcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Store OHLCS for all instruments, all registered periods into files.
Only needed in real-trading mode.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.strategy_last_bar_so_far">
<code class="descname">strategy_last_bar_so_far</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.strategy_last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of current strategy.
:return: string, name of the current strategy.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.strategy_ohlc">
<code class="descname">strategy_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.strategy_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.strategy_period">
<code class="descname">strategy_period</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.strategy_period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.strategy_period_kind">
<code class="descname">strategy_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.strategy_period_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.trading">
<code class="descname">trading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.trading_account_id">
<code class="descname">trading_account_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.trading_account_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Current trading account id.
:return: string, the trading account id.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.JustConnectStrategy.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="ctxalgoctp.ctp.live.connect_to_ctp.main">
<code class="descclassname">ctxalgoctp.ctp.live.connect_to_ctp.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.live.connect_to_ctp.main" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.logger.file_logger"></span><dl class="class">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.logger.file_logger.</code><code class="descname">CtpFileLogger</code><span class="sig-paren">(</span><em>folder</em>, <em>append=True</em>, <em>in_memory_records=100</em>, <em>datetime_format='%Y-%m-%d %H:%M:%S'</em>, <em>datetime_adapter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.logger.logger.CtpLogger" title="ctxalgoctp.ctp.logger.logger.CtpLogger"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.logger.logger.CtpLogger</span></code></a></p>
<p>A file based CTP logger.</p>
<p>Initialize current logger.
:param folder: string. folder of the log files. The folder will have the following sub-folders:</p>
<blockquote>
<div><ol class="arabic simple">
<li>market, this folder stores depth market data from the marketing api.</li>
</ol>
<p>(2) trading, this folder stores all the other kinds of data.
In each folder, the should be files yyyy-mm-dd.txt for each day.</p>
</div></blockquote>
<dl class="docutils">
<dt>:param in_memory_records, int, the maximal number of log records to keep in memory</dt>
<dd>before flushing them into the log file.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>append</strong> &#8211; boolean, if True and if a log file exists, append to that file;
otherwise empty the existing log file.</li>
<li><strong>datetime_format</strong> &#8211; string, datetime format in the log file.</li>
<li><strong>datetime_adapter</strong> &#8211; function pointer from datetime to datetime, used to adapt time in different time zones.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.flush_impl">
<code class="descname">flush_impl</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.flush_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.flush">
<code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush unwritten data into permanent storage. Can be used when the trading program ends.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.is_flushing">
<code class="descname">is_flushing</code><em class="property"> = False</em><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.is_flushing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.market_data">
<code class="descname">market_data</code><em class="property"> = []</em><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.market_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_idle_event">
<code class="descname">on_idle_event</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_idle_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when there is no event from the outside.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_market_connected">
<code class="descname">on_market_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_market_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on market server connect status change
:param p_api: c_void_p
:param rsp_user_login: CThostFtdcRspUserLoginField
:param status: ConnectionStatus int
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_market_disconnected">
<code class="descname">on_market_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_market_disconnected" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on market server disconnected</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_market_rsp_error">
<code class="descname">on_market_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_market_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on market server when error occurred
:param p_api: c_void_p
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_market_rtn_depth_market_data">
<code class="descname">on_market_rtn_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_market_rtn_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on market server when receive market data
:param p_api:  c_void_p
:param depth_market_data: CThostFtdcDepthMarketDataField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_mission_control">
<code class="descname">on_mission_control</code><span class="sig-paren">(</span><em>message</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_mission_control" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>message</strong> &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_connected">
<code class="descname">on_trading_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on trading server connect status change
:param p_api: c_void_p
:param rsp_user_login: CThostFtdcRspUserLoginField
:param status: ConnectionStatus int
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_disconnected">
<code class="descname">on_trading_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_disconnected" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on trading server disconnected
:param p_api: c_void_p
:param rsp_info: CThostFtdcRspInfoField
:param status: ConnectionStatus int
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_err_rtn_order_action">
<code class="descname">on_trading_err_rtn_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>order_action</em>, <em>rsp_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_err_rtn_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>如果交易所认为撤单错误。由交易托管系统主动通知客户端，该方法会被调用。
:param p_api: c_void_p
:param order_action: CThostFtdcOrderActionField
:param rsp_info: CThostFtdcRspInfoField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_err_rtn_order_insert">
<code class="descname">on_trading_err_rtn_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>rsp_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_err_rtn_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>如果交易所认为报单错误。由交易托管系统主动通知客户端，该方法会被调用。
:param p_api: c_void_p
:param input_order: CThostFtdcInputOrderField
:param rsp_info: CThostFtdcRspInfoField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_error">
<code class="descname">on_trading_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on trading server when error occurred
:param p_api: c_void_p
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_order_action">
<code class="descname">on_trading_rsp_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order_action</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>交易托管系统收到撤单指令，如果没有通过参数校验，拒绝接受撤单指令。用户就会收到此消息，其中包含了错误编码和错误消息
:param p_api: c_void_p
:param input_order_action: CThostFtdcInputOrderActionField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_order_insert">
<code class="descname">on_trading_rsp_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>交易托管系统收到报单指令，如果没有通过参数校验，拒绝接受报单指令。用户就会收到此消息，其中包含了错误编码和错误消息
:param p_api: c_void_p
:param input_order: CThostFtdcInputOrderField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_depth_market_data">
<code class="descname">on_trading_rsp_qry_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询行情响应。当客户端发出请求查询行情指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param depth_market_data: CThostFtdcDepthMarketDataField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_instrument">
<code class="descname">on_trading_rsp_qry_instrument</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询合约响应。当客户端发出请求查询合约指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param instrument: CThostFtdcInstrumentField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_instrument_commission_rate">
<code class="descname">on_trading_rsp_qry_instrument_commission_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_commission_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_instrument_commission_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询手续费响应。
:param p_api: c_void_p
:param instrument_commission_rate: CThostFtdcInstrumentCommissionRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_instrument_margin_rate">
<code class="descname">on_trading_rsp_qry_instrument_margin_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_margin_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_instrument_margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询保证金响应。
:param p_api: c_void_p
:param instrument_margin_rate: CThostFtdcInstrumentMarginRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_instrument_order_comm_rate">
<code class="descname">on_trading_rsp_qry_instrument_order_comm_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_order_comm_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_instrument_order_comm_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询报单撤单手续费。
:param p_api: c_void_p
:param instrument_order_comm_rate: CThostFtdcInstrumentOrderCommRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_investor_position">
<code class="descname">on_trading_rsp_qry_investor_position</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>投资者持仓查询应答。当客户端发出投资者持仓查询指令后，后交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param investor_position: CThostFtdcInvestorPositionField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_investor_position_detail">
<code class="descname">on_trading_rsp_qry_investor_position_detail</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position_detail</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_investor_position_detail" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询投资者持仓明细响应。当客户端发出请求请求查询投资者持仓明细指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api:c_void_p
:param investor_position_detail: CThostFtdcInvestorPositionDetailField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_order">
<code class="descname">on_trading_rsp_qry_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_order" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询报单响应
:param p_api: c_void_p
:param order: CThostFtdcOrderField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_trade">
<code class="descname">on_trading_rsp_qry_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询成交响应
:param p_api: c_void_p
:param trade: CThostFtdcTradeField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_trading_account">
<code class="descname">on_trading_rsp_qry_trading_account</code><span class="sig-paren">(</span><em>p_api</em>, <em>trading_account</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rsp_qry_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询资金账户响应。当客户端发出请求查询资金账户指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param trading_account: CThostFtdcTradingAccountField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rtn_order">
<code class="descname">on_trading_rtn_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rtn_order" title="Permalink to this definition">¶</a></dt>
<dd><p>报单回报。当客户端进行报单录入、报单操作及其它原因（如部分成交）导致报单状态发生变化时，交易托管系统会主动通知客户端，该方法会被调用。
:param p_api: c_void_p
:param order: CThostFtdcOrderField</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rtn_trade">
<code class="descname">on_trading_rtn_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.on_trading_rtn_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>成交回报。当发生成交时交易托管系统会通知客户端，该方法会被调用。
:param p_api: c_void_p
:param trade:CThostFtdcTradeField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.persist">
<code class="descname">persist</code><span class="sig-paren">(</span><em>now</em>, <em>data_kind</em>, <em>content</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.persist" title="Permalink to this definition">¶</a></dt>
<dd><p>Persist log data.
:param now: datetime, timestamp.
:param data_kind: string, the kind (tag) of the log data.
:param content: string, the actual log data.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.trading_data">
<code class="descname">trading_data</code><em class="property"> = []</em><a class="headerlink" href="#ctxalgoctp.ctp.logger.file_logger.CtpFileLogger.trading_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.logger.logger"></span><dl class="class">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.logger.logger.</code><code class="descname">CtpLogger</code><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.base.CtpCallBacks" title="ctxalgoctp.ctp.base.CtpCallBacks"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.base.CtpCallBacks</span></code></a></p>
<p>Initialize current callback.</p>
<dl class="attribute">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.is_flushing">
<code class="descname">is_flushing</code><em class="property"> = False</em><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.is_flushing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.market_data">
<code class="descname">market_data</code><em class="property"> = []</em><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.market_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.trading_data">
<code class="descname">trading_data</code><em class="property"> = []</em><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.trading_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_market_connected">
<code class="descname">on_market_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_market_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on market server connect status change
:param p_api: c_void_p
:param rsp_user_login: CThostFtdcRspUserLoginField
:param status: ConnectionStatus int
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_market_disconnected">
<code class="descname">on_market_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_market_disconnected" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on market server disconnected</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_market_rsp_error">
<code class="descname">on_market_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_market_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on market server when error occurred
:param p_api: c_void_p
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_market_rtn_depth_market_data">
<code class="descname">on_market_rtn_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_market_rtn_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on market server when receive market data
:param p_api:  c_void_p
:param depth_market_data: CThostFtdcDepthMarketDataField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_connected">
<code class="descname">on_trading_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on trading server connect status change
:param p_api: c_void_p
:param rsp_user_login: CThostFtdcRspUserLoginField
:param status: ConnectionStatus int
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_disconnected">
<code class="descname">on_trading_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_disconnected" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on trading server disconnected
:param p_api: c_void_p
:param rsp_info: CThostFtdcRspInfoField
:param status: ConnectionStatus int
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_error">
<code class="descname">on_trading_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on trading server when error occurred
:param p_api: c_void_p
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_err_rtn_order_action">
<code class="descname">on_trading_err_rtn_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>order_action</em>, <em>rsp_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_err_rtn_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>如果交易所认为撤单错误。由交易托管系统主动通知客户端，该方法会被调用。
:param p_api: c_void_p
:param order_action: CThostFtdcOrderActionField
:param rsp_info: CThostFtdcRspInfoField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_err_rtn_order_insert">
<code class="descname">on_trading_err_rtn_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>rsp_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_err_rtn_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>如果交易所认为报单错误。由交易托管系统主动通知客户端，该方法会被调用。
:param p_api: c_void_p
:param input_order: CThostFtdcInputOrderField
:param rsp_info: CThostFtdcRspInfoField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_order_action">
<code class="descname">on_trading_rsp_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order_action</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>交易托管系统收到撤单指令，如果没有通过参数校验，拒绝接受撤单指令。用户就会收到此消息，其中包含了错误编码和错误消息
:param p_api: c_void_p
:param input_order_action: CThostFtdcInputOrderActionField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_order_insert">
<code class="descname">on_trading_rsp_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>交易托管系统收到报单指令，如果没有通过参数校验，拒绝接受报单指令。用户就会收到此消息，其中包含了错误编码和错误消息
:param p_api: c_void_p
:param input_order: CThostFtdcInputOrderField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_depth_market_data">
<code class="descname">on_trading_rsp_qry_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询行情响应。当客户端发出请求查询行情指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param depth_market_data: CThostFtdcDepthMarketDataField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_instrument">
<code class="descname">on_trading_rsp_qry_instrument</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询合约响应。当客户端发出请求查询合约指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param instrument: CThostFtdcInstrumentField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_instrument_commission_rate">
<code class="descname">on_trading_rsp_qry_instrument_commission_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_commission_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_instrument_commission_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询手续费响应。
:param p_api: c_void_p
:param instrument_commission_rate: CThostFtdcInstrumentCommissionRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_instrument_margin_rate">
<code class="descname">on_trading_rsp_qry_instrument_margin_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_margin_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_instrument_margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询保证金响应。
:param p_api: c_void_p
:param instrument_margin_rate: CThostFtdcInstrumentMarginRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_instrument_order_comm_rate">
<code class="descname">on_trading_rsp_qry_instrument_order_comm_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_order_comm_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_instrument_order_comm_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询报单撤单手续费。
:param p_api: c_void_p
:param instrument_order_comm_rate: CThostFtdcInstrumentOrderCommRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_investor_position">
<code class="descname">on_trading_rsp_qry_investor_position</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>投资者持仓查询应答。当客户端发出投资者持仓查询指令后，后交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param investor_position: CThostFtdcInvestorPositionField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_investor_position_detail">
<code class="descname">on_trading_rsp_qry_investor_position_detail</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position_detail</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_investor_position_detail" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询投资者持仓明细响应。当客户端发出请求请求查询投资者持仓明细指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api:c_void_p
:param investor_position_detail: CThostFtdcInvestorPositionDetailField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_trading_account">
<code class="descname">on_trading_rsp_qry_trading_account</code><span class="sig-paren">(</span><em>p_api</em>, <em>trading_account</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询资金账户响应。当客户端发出请求查询资金账户指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param trading_account: CThostFtdcTradingAccountField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rtn_order">
<code class="descname">on_trading_rtn_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rtn_order" title="Permalink to this definition">¶</a></dt>
<dd><p>报单回报。当客户端进行报单录入、报单操作及其它原因（如部分成交）导致报单状态发生变化时，交易托管系统会主动通知客户端，该方法会被调用。
:param p_api: c_void_p
:param order: CThostFtdcOrderField</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rtn_trade">
<code class="descname">on_trading_rtn_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rtn_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>成交回报。当发生成交时交易托管系统会通知客户端，该方法会被调用。
:param p_api: c_void_p
:param trade:CThostFtdcTradeField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_order">
<code class="descname">on_trading_rsp_qry_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_order" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询报单响应
:param p_api: c_void_p
:param order: CThostFtdcOrderField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_trade">
<code class="descname">on_trading_rsp_qry_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_trading_rsp_qry_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询成交响应
:param p_api: c_void_p
:param trade: CThostFtdcTradeField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_mission_control">
<code class="descname">on_mission_control</code><span class="sig-paren">(</span><em>message</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_mission_control" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>message</strong> &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.persist">
<code class="descname">persist</code><span class="sig-paren">(</span><em>now</em>, <em>data_kind</em>, <em>content</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.persist" title="Permalink to this definition">¶</a></dt>
<dd><p>Persist log data.
:param now: datetime, timestamp.
:param data_kind: string, the kind (tag) of the log data.
:param content: string, the actual log data.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.flush">
<code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush unwritten data into permanent storage. Can be used when the trading program ends.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.flush_impl">
<code class="descname">flush_impl</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.flush_impl" title="Permalink to this definition">¶</a></dt>
<dd><p>Sub-class should redefine this to implement permanent storage..
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logger.CtpLogger.on_idle_event">
<code class="descname">on_idle_event</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logger.CtpLogger.on_idle_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when there is no event from the outside.
:return:</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.logger.logging_utils"></span><dl class="class">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.logger.logging_utils.</code><code class="descname">LogUrlGenerator</code><span class="sig-paren">(</span><em>day_separator=True</em>, <em>profit=False</em>, <em>investor_position=True</em>, <em>balance=True</em>, <em>available_money=False</em>, <em>pre_loaded_bars=200</em>, <em>max_days_per_chart=None</em>, <em>signal_with_price=True</em>, <em>stop_loss=True</em>, <em>chart_period=None</em>, <em>show_ignored_signals=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to generate urls for the website from strategy logs.</p>
<p>Initialize the url generator.
:param records: [LogRecord], the list of log records read from the output.txt file.
:param day_separator: boolean, if True, display vertical bar between trading days.
:param profit: boolean, if True, output an auxiliary chart to display position profits.
:param investor_position: boolean, if True, output an auxiliary chart to display investor positions.
:param balance: boolean, if True, output an auxiliary chart to display balance and available money.
:param pre_loaded_bars: int, the number of bars to load before the starting of the main data.
:param max_days_per_chart: int, the maximum number of trading days to display per chart.</p>
<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.get_end_timestamp">
<code class="descname">get_end_timestamp</code><span class="sig-paren">(</span><em>current_time</em>, <em>periodicity</em>, <em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.get_end_timestamp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.gettext">
<code class="descname">gettext</code><span class="sig-paren">(</span><em>text</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.gettext" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the translation of text in self.language.
:param text: string, the text in English to translate.
:return: string, the translated text.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate">
<code class="descname">generate</code><span class="sig-paren">(</span><em>records</em>, <em>sid=None</em>, <em>extra_indicators=None</em>, <em>kind='trade'</em>, <em>lang='en'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate urls. When kind is &#8216;trade&#8217;, the generation also sets self.last_transactions.
:param sid: string, the security id.
:param extra_indicators: string, extra indicators to display.</p>
<blockquote>
<div>If None, use the url_indicators information from the log.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>kind</strong> &#8211; string, can be &#8216;signal&#8217;, &#8216;trade&#8217;.</li>
<li><strong>lang</strong> &#8211; string, the language for the text in the generated url.
&#8216;zh&#8217; means Chinese, &#8216;en&#8217; means English.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">dict from string to string, keys are url titles, values are urls.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.get_base_url">
<code class="descname">get_base_url</code><span class="sig-paren">(</span><em>sid</em>, <em>extra_indicators</em>, <em>parameters</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.get_base_url" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.get_hmark_delta">
<code class="descname">get_hmark_delta</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.get_hmark_delta" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_trade">
<code class="descname">generate_trade</code><span class="sig-paren">(</span><em>date_ranges</em>, <em>trades</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_trade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_available_money">
<code class="descname">generate_available_money</code><span class="sig-paren">(</span><em>date_ranges</em>, <em>money</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_balance">
<code class="descname">generate_balance</code><span class="sig-paren">(</span><em>date_ranges</em>, <em>money</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_profit">
<code class="descname">generate_profit</code><span class="sig-paren">(</span><em>date_ranges</em>, <em>profits</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_investor_positions">
<code class="descname">generate_investor_positions</code><span class="sig-paren">(</span><em>date_ranges</em>, <em>positions</em>, <em>sizings</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_investor_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_account">
<code class="descname">process_account</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_account" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_investor_position">
<code class="descname">process_investor_position</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_investor_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_position_sizing">
<code class="descname">process_position_sizing</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_position_sizing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_bar">
<code class="descname">process_bar</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_bar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_order">
<code class="descname">process_order</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_trade">
<code class="descname">process_trade</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_trade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.handle_unfinished_trades">
<code class="descname">handle_unfinished_trades</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.handle_unfinished_trades" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_stop_loss">
<code class="descname">process_stop_loss</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_stop_loss" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_stop_loss">
<code class="descname">generate_stop_loss</code><span class="sig-paren">(</span><em>date_range</em>, <em>stop_loss_series</em>, <em>stop_loss_directions</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_stop_loss" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_orders">
<code class="descname">generate_orders</code><span class="sig-paren">(</span><em>date_range</em>, <em>orders</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_orders" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_signal">
<code class="descname">process_signal</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_signal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_signal_confirmed">
<code class="descname">process_signal_confirmed</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_signal_confirmed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_signal_ignored">
<code class="descname">process_signal_ignored</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_signal_ignored" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_strategy">
<code class="descname">process_strategy</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_strategy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_strategy_extra">
<code class="descname">process_strategy_extra</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.process_strategy_extra" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_datetime_range">
<code class="descname">generate_datetime_range</code><span class="sig-paren">(</span><em>date_range</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_datetime_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_period">
<code class="descname">generate_period</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_signals">
<code class="descname">generate_signals</code><span class="sig-paren">(</span><em>date_range</em>, <em>signals</em>, <em>confirmed_signals</em>, <em>ignored_signals</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_signals" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_day_separators">
<code class="descname">generate_day_separators</code><span class="sig-paren">(</span><em>date_range</em>, <em>days</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.generate_day_separators" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.get_bars_in_one_day">
<code class="descname">get_bars_in_one_day</code><span class="sig-paren">(</span><em>period</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.get_bars_in_one_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the approximate number of bars in a single trading day for a given periodicity.
:param period: Periodicity.
:return: int, the number of bars in a single trading day.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.get_pre_date">
<code class="descname">get_pre_date</code><span class="sig-paren">(</span><em>period</em>, <em>start_date</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.get_pre_date" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.get_actual_max_days_per_chart">
<code class="descname">get_actual_max_days_per_chart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.get_actual_max_days_per_chart" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogUrlGenerator.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogMergeKind">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.logger.logging_utils.</code><code class="descname">LogMergeKind</code><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogMergeKind" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogMergeKind.APPEND_ALL">
<code class="descname">APPEND_ALL</code><em class="property"> = 1</em><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogMergeKind.APPEND_ALL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogMergeKind.APPEND_NEW">
<code class="descname">APPEND_NEW</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogMergeKind.APPEND_NEW" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogFileManipulator">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.logger.logging_utils.</code><code class="descname">LogFileManipulator</code><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogFileManipulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogFileManipulator.merge">
<code class="descname">merge</code><span class="sig-paren">(</span><em>old_log</em>, <em>new_log</em>, <em>kind=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogFileManipulator.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge part or all of new_output into old_output.
:param old_log: string, path to the old output file.
:param new_log: string, path to the new output file.
:param kind: LogMergeKind.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.logging_utils.LogFileManipulator.extract">
<code class="descname">extract</code><span class="sig-paren">(</span><em>old_log</em>, <em>new_log</em>, <em>start_date</em>, <em>end_date=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.logging_utils.LogFileManipulator.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract part of the old_log file and store the extracted part into the new_log file.
:param old_log: string, the path to the old (existing) log file.
:param new_log: string, the path to the new (to be created) log file.
:param start_date: date or string in form of yyyy-mm-dd, specify the start date (inclusive) of the extraction.
:param end_date: date or string in form of yyyy-mm-dd, specify the end date (inclusive) of the extraction.</p>
<blockquote>
<div>If None, defaults to start_date.</div></blockquote>
</dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.logger.mysql_logger"></span><dl class="class">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.logger.mysql_logger.</code><code class="descname">CtpMysqlLogger</code><span class="sig-paren">(</span><em>user</em>, <em>password</em>, <em>schema</em>, <em>host='localhost'</em>, <em>port=3306</em>, <em>charset='utf8'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.logger.logger.CtpLogger" title="ctxalgoctp.ctp.logger.logger.CtpLogger"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.logger.logger.CtpLogger</span></code></a></p>
<p>A MySQL based CTP logger.</p>
<p>Initialize current MySQL based logger.
:param user: string, MySQL user.
:param password: string, MySQL password.
:param schema: string, MySQL schema name.
:param host: string, MySQL host ip.
:param port: int, MySQL port.
:param charset: string, MySQL charset.</p>
<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.flush">
<code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush unwritten data into permanent storage. Can be used when the trading program ends.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.flush_impl">
<code class="descname">flush_impl</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.flush_impl" title="Permalink to this definition">¶</a></dt>
<dd><p>Sub-class should redefine this to implement permanent storage..
:return:</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.is_flushing">
<code class="descname">is_flushing</code><em class="property"> = False</em><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.is_flushing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.market_data">
<code class="descname">market_data</code><em class="property"> = []</em><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.market_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_idle_event">
<code class="descname">on_idle_event</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_idle_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when there is no event from the outside.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_market_connected">
<code class="descname">on_market_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_market_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on market server connect status change
:param p_api: c_void_p
:param rsp_user_login: CThostFtdcRspUserLoginField
:param status: ConnectionStatus int
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_market_disconnected">
<code class="descname">on_market_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_market_disconnected" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on market server disconnected</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_market_rsp_error">
<code class="descname">on_market_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_market_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on market server when error occurred
:param p_api: c_void_p
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_market_rtn_depth_market_data">
<code class="descname">on_market_rtn_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_market_rtn_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on market server when receive market data
:param p_api:  c_void_p
:param depth_market_data: CThostFtdcDepthMarketDataField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_mission_control">
<code class="descname">on_mission_control</code><span class="sig-paren">(</span><em>message</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_mission_control" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>message</strong> &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_connected">
<code class="descname">on_trading_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on trading server connect status change
:param p_api: c_void_p
:param rsp_user_login: CThostFtdcRspUserLoginField
:param status: ConnectionStatus int
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_disconnected">
<code class="descname">on_trading_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_disconnected" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on trading server disconnected
:param p_api: c_void_p
:param rsp_info: CThostFtdcRspInfoField
:param status: ConnectionStatus int
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_err_rtn_order_action">
<code class="descname">on_trading_err_rtn_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>order_action</em>, <em>rsp_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_err_rtn_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>如果交易所认为撤单错误。由交易托管系统主动通知客户端，该方法会被调用。
:param p_api: c_void_p
:param order_action: CThostFtdcOrderActionField
:param rsp_info: CThostFtdcRspInfoField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_err_rtn_order_insert">
<code class="descname">on_trading_err_rtn_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>rsp_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_err_rtn_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>如果交易所认为报单错误。由交易托管系统主动通知客户端，该方法会被调用。
:param p_api: c_void_p
:param input_order: CThostFtdcInputOrderField
:param rsp_info: CThostFtdcRspInfoField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_error">
<code class="descname">on_trading_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd><p>callback on trading server when error occurred
:param p_api: c_void_p
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_order_action">
<code class="descname">on_trading_rsp_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order_action</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>交易托管系统收到撤单指令，如果没有通过参数校验，拒绝接受撤单指令。用户就会收到此消息，其中包含了错误编码和错误消息
:param p_api: c_void_p
:param input_order_action: CThostFtdcInputOrderActionField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_order_insert">
<code class="descname">on_trading_rsp_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>交易托管系统收到报单指令，如果没有通过参数校验，拒绝接受报单指令。用户就会收到此消息，其中包含了错误编码和错误消息
:param p_api: c_void_p
:param input_order: CThostFtdcInputOrderField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_depth_market_data">
<code class="descname">on_trading_rsp_qry_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询行情响应。当客户端发出请求查询行情指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param depth_market_data: CThostFtdcDepthMarketDataField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_instrument">
<code class="descname">on_trading_rsp_qry_instrument</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询合约响应。当客户端发出请求查询合约指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param instrument: CThostFtdcInstrumentField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_instrument_commission_rate">
<code class="descname">on_trading_rsp_qry_instrument_commission_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_commission_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_instrument_commission_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询手续费响应。
:param p_api: c_void_p
:param instrument_commission_rate: CThostFtdcInstrumentCommissionRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_instrument_margin_rate">
<code class="descname">on_trading_rsp_qry_instrument_margin_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_margin_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_instrument_margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询保证金响应。
:param p_api: c_void_p
:param instrument_margin_rate: CThostFtdcInstrumentMarginRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_instrument_order_comm_rate">
<code class="descname">on_trading_rsp_qry_instrument_order_comm_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_order_comm_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_instrument_order_comm_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询报单撤单手续费。
:param p_api: c_void_p
:param instrument_order_comm_rate: CThostFtdcInstrumentOrderCommRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_investor_position">
<code class="descname">on_trading_rsp_qry_investor_position</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>投资者持仓查询应答。当客户端发出投资者持仓查询指令后，后交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param investor_position: CThostFtdcInvestorPositionField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_investor_position_detail">
<code class="descname">on_trading_rsp_qry_investor_position_detail</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position_detail</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_investor_position_detail" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询投资者持仓明细响应。当客户端发出请求请求查询投资者持仓明细指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api:c_void_p
:param investor_position_detail: CThostFtdcInvestorPositionDetailField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_order">
<code class="descname">on_trading_rsp_qry_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_order" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询报单响应
:param p_api: c_void_p
:param order: CThostFtdcOrderField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_trade">
<code class="descname">on_trading_rsp_qry_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询成交响应
:param p_api: c_void_p
:param trade: CThostFtdcTradeField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_trading_account">
<code class="descname">on_trading_rsp_qry_trading_account</code><span class="sig-paren">(</span><em>p_api</em>, <em>trading_account</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rsp_qry_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询资金账户响应。当客户端发出请求查询资金账户指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param trading_account: CThostFtdcTradingAccountField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rtn_order">
<code class="descname">on_trading_rtn_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rtn_order" title="Permalink to this definition">¶</a></dt>
<dd><p>报单回报。当客户端进行报单录入、报单操作及其它原因（如部分成交）导致报单状态发生变化时，交易托管系统会主动通知客户端，该方法会被调用。
:param p_api: c_void_p
:param order: CThostFtdcOrderField</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rtn_trade">
<code class="descname">on_trading_rtn_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.on_trading_rtn_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>成交回报。当发生成交时交易托管系统会通知客户端，该方法会被调用。
:param p_api: c_void_p
:param trade:CThostFtdcTradeField
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.persist">
<code class="descname">persist</code><span class="sig-paren">(</span><em>now</em>, <em>data_kind</em>, <em>content</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.persist" title="Permalink to this definition">¶</a></dt>
<dd><p>Persist log data.
:param now: datetime, timestamp.
:param data_kind: string, the kind (tag) of the log data.
:param content: string, the actual log data.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.trading_data">
<code class="descname">trading_data</code><em class="property"> = []</em><a class="headerlink" href="#ctxalgoctp.ctp.logger.mysql_logger.CtpMysqlLogger.trading_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75"></span><dl class="class">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy">
<em class="property">class </em><code class="descclassname">ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.</code><code class="descname">MeanReversionRSI2575Strategy</code><span class="sig-paren">(</span><em>instrument_ids</em>, <em>strategy_period</em>, <em>parameters</em>, <em>base_folder</em>, <em>periods=None</em>, <em>description=None</em>, <em>logger=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ctxalgoctp.ctp.strategy.AbstractStrategy" title="ctxalgoctp.ctp.strategy.AbstractStrategy"><code class="xref py py-class docutils literal"><span class="pre">ctxalgoctp.ctp.strategy.AbstractStrategy</span></code></a></p>
<p>a simple strategy
see <a class="reference external" href="http://sanzprophet.blogspot.co.uk/2012/09/7-winning-trading-systems-reviewed-pt-3.html">http://sanzprophet.blogspot.co.uk/2012/09/7-winning-trading-systems-reviewed-pt-3.html</a></p>
<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_bar">
<code class="descname">on_bar</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>bars</em>, <em>tick</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_bar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.TRADING_CONNECTED">
<code class="descname">TRADING_CONNECTED</code><em class="property"> = 1</em><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.TRADING_CONNECTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.TRADING_NOT_CONNECTED">
<code class="descname">TRADING_NOT_CONNECTED</code><em class="property"> = 0</em><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.TRADING_NOT_CONNECTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.account_size">
<code class="descname">account_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.account_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.add_bar_arrival_action">
<code class="descname">add_bar_arrival_action</code><span class="sig-paren">(</span><em>action</em>, <em>period=None</em>, <em>instrument_ids=None</em>, <em>ohlc_kind='time-based'</em>, <em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.add_bar_arrival_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup an action, which will be called when all required ohlc bars have arrived.
For example, if period=Periodicity.HOURLY, and instrument_ids are the list of all the traded instruments,
then action will be called the next time when all hourly bars for the traded instruments have arrived.
:param action: function pointer with the following four parameters:</p>
<blockquote>
<div><p>ohlc_kind: string, the ohlc kind, can be &#8216;time-based&#8217;, &#8216;volatility-based&#8217;.
period: Periodicity in case of time-based ohlc, or int/float as volatility threshold</p>
<blockquote>
<div>in case of volatility-based ohlc.</div></blockquote>
<p>name: string, the bar arrival action name, same as the name parameter specified here.
ohlcs: dict{string: OHLC}, the list of ohlcs, keys are instrument ids, values are the ohlc objects.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>period</strong> &#8211; Periodicity in case of time-based ohlc, or int/float as volatility threshold
in case of volatility-based ohlc. This is the period for the required ohlc bars.
If None, use self.strategy_period().
This will be passed into the action when it is invoked.</li>
<li><strong>instrument_ids</strong> &#8211; [string], the list of instruments whose last ohlc bar of required period must
arrived before action can be invoked. If None, defaults to self.instrument_ids(), which are
the full list of traded instruments.</li>
<li><strong>ohlc_kind</strong> &#8211; string, the ohlc kind, can be &#8216;time-based&#8217;, &#8216;volatility-based&#8217;.
This will be passed into the action when it is invoked.</li>
<li><strong>name</strong> &#8211; string, the bar arrival action name, used to identify different bar arrival requests.
This will be passed into the action when it is invoked.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.add_timer">
<code class="descname">add_timer</code><span class="sig-paren">(</span><em>timer=None</em>, <em>trigger_time=None</em>, <em>timedelta=None</em>, <em>on_time_action=None</em>, <em>start=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.add_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Add timer into current strategy.
:param timer: SimulatedTimer, the timer to add. If None, use trigger_time to create a timer.
:param trigger_time: datetime or time, or string in form of yyyy-mm-dd or yyyy-mm-dd HH:MM:SS, or</p>
<blockquote>
<div>a list of the above types. The time(s) used to create a timer .
If specified, create an alarm timer.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>timedelta</strong> &#8211; timedelta, if specified, create a repeated count down timer.</li>
<li><strong>on_time_action</strong> &#8211; function pointer whose signature is same as self.on_timer.
If not None and there is no on_time_action set in timer, then set this as the callback for timer.
If None and there is no on_time_action in timer, then set self.on_timer into the timer.</li>
<li><strong>start</strong> &#8211; boolean, if True start the timer right away.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return string, the name of the added timer.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.all_position_details">
<code class="descname">all_position_details</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.all_position_details" title="Permalink to this definition">¶</a></dt>
<dd><p>Return position details for all traded instruments.
:return: dict{string: dict{string: [dict{string: object}]}}</p>
<blockquote>
<div><p>The out most keys are instrument ides, and the values are the same as the result of self.position_details.
For example:
{</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;IF99&#8217;: {</dt>
<dd><dl class="first last docutils">
<dt>&#8216;long&#8217;: [</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>{</dt>
<dd>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</dd>
</dl>
<p>}, ...</p>
</div></blockquote>
<p class="last">],</p>
</dd>
<dt>&#8216;short&#8217;: [</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>{</dt>
<dd>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</dd>
</dl>
<p>}, ...</p>
</div></blockquote>
<p class="last">],</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.all_positions">
<code class="descname">all_positions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.all_positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.available_money">
<code class="descname">available_money</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.available_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.balance">
<code class="descname">balance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.bars_in_last_days">
<code class="descname">bars_in_last_days</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.bars_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.calculate_latest_market_end_time">
<code class="descname">calculate_latest_market_end_time</code><span class="sig-paren">(</span><em>market_periods</em>, <em>now</em>, <em>delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.calculate_latest_market_end_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Given traded instruments and current timestamp, calculate when the market will be closed.
This is used by the strategy infrastructure to decide when to exit strategies: strategies
should terminate after the latest market periods of the traded instrument ends, plus</p>
<blockquote>
<div>a given extra time. This automatic termination only has effect
when self.should_terminate_after_market_close is True.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param:</th><td class="field-body"><p class="first">market_periods, dict{string: [(time, time)]}, keys are instrument ids, values are market periods.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>now</strong> &#8211; datetime, current timestamp.</li>
<li><strong>delta</strong> &#8211; timedelta, some extra amount of time that is added into the traded market periods to allow
the strategy to continue running for some time after the market closes, for example, to do
some bookkeeping work. If None, no extra time is added.</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">datetime, the time when strategies should terminate.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.can_close_position_wrt_time">
<code class="descname">can_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.can_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.can_open_and_close_position_wrt_time">
<code class="descname">can_open_and_close_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.can_open_and_close_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open and close positions for all the instruments given by instrument_ids?
Whether any position can be closed for an instrument id is defined by
now &lt;= self.latest_time_to_open_position and now &lt;= self.latest_time_to_close_position.
:param now: datetime, current time. If None, use current timestamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be closed.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open and close close positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.can_open_position_wrt_time">
<code class="descname">can_open_position_wrt_time</code><span class="sig-paren">(</span><em>now=None</em>, <em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.can_open_position_wrt_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Can we open positions for all the instruments given by instrument_ids?
Whether any position can be opened for an instrument id is defined by now &lt;= self.latest_time_to_open_position.
:param now: datetime, current time. If None, use current timstamp.
:param instrument_ids: [string], the list of instrument ids whose positions need to be opened.</p>
<blockquote>
<div>If None, use self.instrument_id() as the only instrument.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bool, True if we can open positions for all the given instrument ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.cancel_order">
<code class="descname">cancel_order</code><span class="sig-paren">(</span><em>order_ref</em>, <em>reason=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.cancel_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel order.
:param order_ref: string, the order reference.
:param reason: string, the reason for cancelling the order.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.change_position_to">
<code class="descname">change_position_to</code><span class="sig-paren">(</span><em>new_position</em>, <em>price=None</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.change_position_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the position of the given instrument to new_position. If price is given, all underlying orders
are limit orders at that price, otherwise, market orders.
:param new_position: int, the new position for the instrument.
:param price: float, if None, newly placed orders are market orders, otherwise, limit orders.
:param reason: string, the reason for this operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.
:param cancellation: AbstractOrderCancellation, the cancellation policy for current order.</p>
<blockquote>
<div>If None, no cancellation policy is specified.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd>may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.change_positions_to">
<code class="descname">change_positions_to</code><span class="sig-paren">(</span><em>new_positions</em>, <em>prices=None</em>, <em>reason=''</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.change_positions_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Change positions of multiple instruments to their new values.
:param new_positions: dict{string: int}, keys are instrument ids,</p>
<blockquote>
<div>values are the new positions for those instruments.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>prices</strong> &#8211; dict{string: float}, keys are instrument ids,
values are prices at which limit orders are placed. If prices is None, all orders are market orders.
If prices is a dict and for some instrument (through dict keys), the key is missing or the value
is None, then the orders for that instrument are market orders, otherwise, limit orders.</li>
<li><strong>reason</strong> &#8211; string, the reason for current order(s).</li>
<li><strong>transaction_id</strong> &#8211; string, transition id, set to None.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the order cancellation policy used to
cancel all the placed orders.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.check_bar_based_order_cancellations">
<code class="descname">check_bar_based_order_cancellations</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>bars</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.check_bar_based_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.check_order_cancellations">
<code class="descname">check_order_cancellations</code><span class="sig-paren">(</span><em>cancellations</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.check_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if we should cancel some orders because of previously setup order cancellations.
:param cancellations: [AbstractOrderCancellation], the list of order cancellations.
:param data: dict{string: object}, the data needed by order cancellations to decide</p>
<blockquote>
<div>whether pending orders should be cancelled. Different kinds of order cancellations
need different data.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.check_time_based_order_cancellations">
<code class="descname">check_time_based_order_cancellations</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.check_time_based_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if there are some order cancellation that should be triggered by the given timestamp now.
If so, cancel those orders.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.check_timers">
<code class="descname">check_timers</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.check_timers" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if there are some timers that can be triggered by the given timestamp now.
If so, call self.on_timer.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.close_limit_order">
<code class="descname">close_limit_order</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.close_limit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a limit order at price. Note that for limit orders, there is no support for enforce_one_direction,
because limit orders cannot guarantee that all positions in one direction are fully closed.
The strategy is responsible for maintaining positions in a single direction, if desirable.
:param price: float, the price.
:param volume: int, the volume to open. Positive volume means open long; Negative volume means open short.
:param kind: OrderKind. Distinguish between Normal, FAK, FOK limit orders.
:param reason: string, a reason for the open operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd>may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.close_market_order">
<code class="descname">close_market_order</code><span class="sig-paren">(</span><em>volume</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.close_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Close market order for future_id. If there is only one future in current strategy, you don&#8217;t need to
provide future_id, self.future_id will be used implicitly.
:param volume: int, the volume to close. Positive volume means open close; Negative volume means close short.
:param reason: string, a reason for the close operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd>may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.close_position">
<code class="descname">close_position</code><span class="sig-paren">(</span><em>volume</em>, <em>price=None</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.close_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a position for the instrumeent given by instrument_id.
:param price: float, if None, send a market order. If not None, send a limit order at that price.
:param kind: OrderKind, the order kind.
:param reason: string, reason for this open position operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:param transaction_id: string, transaction id.
:param cancellation: AbstractOrderCancellation, the cancellation policy for current order.
:return:</p>
<blockquote>
<div><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.current_transaction_id">
<code class="descname">current_transaction_id</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.current_transaction_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.data_feed">
<code class="descname">data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.data_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.delete_context_file">
<code class="descname">delete_context_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.delete_context_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the context.txt file.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.direction">
<code class="descname">direction</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return &#8216;long&#8217; or &#8216;short&#8217; as direction.
:param volume: int, positive number means long direction, negative numer means short direction.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.does_indicator_calculator_contain_ohlc_kind">
<code class="descname">does_indicator_calculator_contain_ohlc_kind</code><span class="sig-paren">(</span><em>indicator_calculators</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.does_indicator_calculator_contain_ohlc_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Does indicator_calculators contains ohlc kind information?
:param indicator_calculators:
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.dominant_instrument">
<code class="descname">dominant_instrument</code><span class="sig-paren">(</span><em>instrument_prefix</em>, <em>trading_day</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.dominant_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level dominant instrument id on the given trading day.
:param instrument_prefix: string, instrument id prefix, such as IF, cu.
:param trading_day: date, or string in form of yyyy-mm-dd. trading day.
:param level: int, 0 means the dominant contract, 1 means the next dominant contract, and so on.
:return: string, the instrument id of the asked dominant contract.</p>
<blockquote>
<div>If no such dominant contract, return None.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.dump_json">
<code class="descname">dump_json</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.dump_json" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.filtered_position">
<code class="descname">filtered_position</code><span class="sig-paren">(</span><em>direction</em>, <em>condition</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.filtered_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current position details for a given instrument.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param condition: string, values can be:</p>
<blockquote>
<div>highest_price: return the position which has the highest filled price.
lowest_price: return the position which has the lowest filled price.
earliest_filled: return the position which has the earliest filled time.
latest_filled: return the position which as the latest filled time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}
The details of a particular position which satisfy the given condition. The format is:
{<blockquote>
<div>&#8216;order_ref&#8217;: order reference string
&#8216;price&#8217;: the price when the position is opened.
&#8216;volume&#8217;: the volume that are executed at this price.
&#8216;timestamp&#8217;: the time when this position is executed.</div></blockquote>
<p>}.
If there are more than one position satisfies the condition, randomly choose one.
If there is no position, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.futures">
<code class="descname">futures</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.futures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.get_datetime_from_string">
<code class="descname">get_datetime_from_string</code><span class="sig-paren">(</span><em>day</em>, <em>time_</em>, <em>milli</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.get_datetime_from_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a datetime object from day, <a href="#id29"><span class="problematic" id="id30">time_</span></a> and milli.
Parameters:</p>
<blockquote>
<div>day: string, a string representation of a date, in format yyyymmdd.
<a href="#id31"><span class="problematic" id="id32">time_</span></a>: string, a string representation of a time, in format HH:MM:SS.
milli: string, a strign representation of milliseconds, in format of an integer.</div></blockquote>
<p>Return: datetime, a parsed datetime object.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.get_investor_position">
<code class="descname">get_investor_position</code><span class="sig-paren">(</span><em>instrument_id</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.get_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a request for investor position for the given future.
:param instrument_id: string, instrument id. If an empty string, then get</p>
<blockquote>
<div>positions for all the held instruments.</div></blockquote>
<p>The returned information will be accessible through the corresponding callback function.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.get_order">
<code class="descname">get_order</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.get_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Return order information.
:param order_ref: string, the order reference number returned when placing an order via</p>
<blockquote>
<div>open_market_order, open_limit_order, close_market_order or close_limit_order.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: object}. The order object. None if no order if found by order_ref.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.get_order_status">
<code class="descname">get_order_status</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.get_order_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the status of an order.
:param order_ref: string, the order reference number returned when placing an order via</p>
<blockquote>
<div>open_market_order, open_limit_order, close_market_order or close_limit_order.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">OrderStatus. The status of the order. None if no order is found by order_ref.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.get_trading_account">
<code class="descname">get_trading_account</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.get_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a request for trading account information.
The returned information will be accessible through the corresponding callback function.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.has_data_feed">
<code class="descname">has_data_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.has_data_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Is data feed set?
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.has_long_position">
<code class="descname">has_long_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.has_long_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have long positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.has_pending_order">
<code class="descname">has_pending_order</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.has_pending_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.has_position">
<code class="descname">has_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.has_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.has_run">
<code class="descname">has_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.has_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Has current strategy started running&gt;
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.has_short_position">
<code class="descname">has_short_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.has_short_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Does current strategy have short positions?
:param instrument_id: string, instrument id. If None, use self.instrument_id().</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.highest_position_price">
<code class="descname">highest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.highest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.in_state">
<code class="descname">in_state</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current state machine in state named name?
:param name: string, name of a state.
:return string, name of the state.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.indicator">
<code class="descname">indicator</code><span class="sig-paren">(</span><em>name</em>, <em>kind=None</em>, <em>period=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.indicator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the last calculated value(s) for the given indicator alias.
:param kind: string, kind of the ohlc on which indicators are calculated.</p>
<blockquote>
<div>Valid values are &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.
If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> &#8211; string, name of the indicator.</li>
<li><strong>period</strong> &#8211; Periodicity or int/float, the period of the indicator. If None, use self.strategy_period().
If kind is &#8216;volatility-based&#8217;, type of period is int/float, indicating volatility threshold.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id on which the indicator is calculated.
If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object, indicator result.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.initialize_before_run">
<code class="descname">initialize_before_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.initialize_before_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.instrument_id">
<code class="descname">instrument_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.instrument_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.instrument_ids">
<code class="descname">instrument_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.instrument_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.is_day">
<code class="descname">is_day</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.is_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in day trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.is_night">
<code class="descname">is_night</code><span class="sig-paren">(</span><em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.is_night" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the given timestamp in night trading period?
:param timestamp: datetime, the given timestamp. If None, use self.now().
:return: boolean.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.is_order_pending">
<code class="descname">is_order_pending</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.is_order_pending" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.is_position_reached">
<code class="descname">is_position_reached</code><span class="sig-paren">(</span><em>target_position</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.is_position_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the current position for the given instrument is the same as target position.
:param target_position: int, the target position. If None, meaning that target position is unknown,</p>
<blockquote>
<div>then this method always returns False.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.is_position_single_sided">
<code class="descname">is_position_single_sided</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.is_position_single_sided" title="Permalink to this definition">¶</a></dt>
<dd><p>Is current position for the given instrument single sided?
Meaning either long or short positions, but not both.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return bool, True if position for the given instrument is single-sided, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.is_stop_loss_touched">
<code class="descname">is_stop_loss_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_loss</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.is_stop_loss_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop loss?
:param price: float, the current instrument price.
:param stop_loss: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop loss.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.is_stop_win_touched">
<code class="descname">is_stop_win_touched</code><span class="sig-paren">(</span><em>price</em>, <em>stop_win</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.is_stop_win_touched" title="Permalink to this definition">¶</a></dt>
<dd><p>Has price touched given stop win?
:param price: float, the current instrument price.
:param stop_win: float, the predefined stop loss price.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:return: bool, True if given price touches stop win.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.is_trading_connected">
<code class="descname">is_trading_connected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.is_trading_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.last_bar_so_far">
<code class="descname">last_bar_so_far</code><span class="sig-paren">(</span><em>periodicity</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.last_known_price">
<code class="descname">last_known_price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.last_known_price" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.latest_time_to_close_position">
<code class="descname">latest_time_to_close_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.latest_time_to_close_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.latest_time_to_open_position">
<code class="descname">latest_time_to_open_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.latest_time_to_open_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_cancel_order">
<code class="descname">log_cancel_order</code><span class="sig-paren">(</span><em>order_ref_id</em>, <em>order_ref</em>, <em>reason</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_cancel_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Log cancel order.
:param order_ref: string, order reference.
:param reason: string, the reason for order.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_connect_to_market">
<code class="descname">log_connect_to_market</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_connect_to_market" title="Permalink to this definition">¶</a></dt>
<dd><p>Log the action to connect to the market data server.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_connect_to_trading">
<code class="descname">log_connect_to_trading</code><span class="sig-paren">(</span><em>now</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_connect_to_trading" title="Permalink to this definition">¶</a></dt>
<dd><p>Log the action to connect to the trading server.
:param now: datetime, current timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_err_order_action">
<code class="descname">log_err_order_action</code><span class="sig-paren">(</span><em>order_ref</em>, <em>order_action</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_err_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_err_order_insert">
<code class="descname">log_err_order_insert</code><span class="sig-paren">(</span><em>order_ref</em>, <em>input_order</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_err_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_exception">
<code class="descname">log_exception</code><span class="sig-paren">(</span><em>e</em>, <em>tb</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_exception" title="Permalink to this definition">¶</a></dt>
<dd><p>Log exception.
:param Exception, the exception object.
:param tb string, the traceback.
:param other_data: dict{string: object}, other kinds of data.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_investor_position">
<code class="descname">log_investor_position</code><span class="sig-paren">(</span><em>investor_position</em>, <em>timestamp</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Log investor position.
:param investor_position: The investor position object.
:param is_last: boolean, is the result the last batch.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_ohlc">
<code class="descname">log_ohlc</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>bars</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Log ohlc.
:param instrument_id: string, the instrument id.
:param bars: dict{string: dict{Periodicity or int/float: Bar}} The bars.</p>
<blockquote>
<div>Outer keys are ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.
Inner keys are Periodicity or volatility thresholds, inner values are the generated bars.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_order">
<code class="descname">log_order</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>action</em>, <em>volume</em>, <em>order_ref</em>, <em>reason</em>, <em>transaction_id</em>, <em>order_kind='Market'</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Log order.
:param instrument_id: string, the instrument id.
:param action: OrderAction, the action of this order.
:param volume: int, volume to trade.</p>
<blockquote>
<div>Positive volume means long position, negative volume means short position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>order_ref</strong> &#8211; int, order reference.</li>
<li><strong>reason</strong> &#8211; string the reason for order.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param transaction_id, int, the transaction id.
:param order_kind: OrderKind. The kind of the order.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_order_action">
<code class="descname">log_order_action</code><span class="sig-paren">(</span><em>order_ref</em>, <em>order_action</em>, <em>rsp_info</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_order_insert">
<code class="descname">log_order_insert</code><span class="sig-paren">(</span><em>order_ref</em>, <em>input_order</em>, <em>rsp_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_rtn_order">
<code class="descname">log_rtn_order</code><span class="sig-paren">(</span><em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_rtn_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_signal">
<code class="descname">log_signal</code><span class="sig-paren">(</span><em>signal</em>, <em>tag=None</em>, <em>reason=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Log signal.
:param signal: EntrySignal, the signal to log.
:param tag: string, the tag to use, if None, the method will decide a tag name.
:param reason: string, some additional reason. Can be None if there is no reason.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_state_transition">
<code class="descname">log_state_transition</code><span class="sig-paren">(</span><em>start_state</em>, <em>end_state</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_state_transition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_stop_loss">
<code class="descname">log_stop_loss</code><span class="sig-paren">(</span><em>timestamp</em>, <em>direction</em>, <em>value</em>, <em>transaction_id</em>, <em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_stop_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Log stop loss.
Parameters:</p>
<blockquote>
<div><p>timestamp: datetime, the time when the stop loss is calculated.
direction: int, 1 means long stop loss, -1 means short stop loss.
value: float, the stop loss value.
transaction_id: string, transaction id.
name: string, a possible additional name for the stop loss line. This is helpful to</p>
<blockquote>
<div>support multiple stop lines (for example, a close-bar stop loss and an in-bar stop loss)
for the same transaction.</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_strategy">
<code class="descname">log_strategy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_strategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Log information about current strategy.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_strategy_info">
<code class="descname">log_strategy_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_strategy_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_trade">
<code class="descname">log_trade</code><span class="sig-paren">(</span><em>trade</em>, <em>extra_info</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_trade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_trading_account">
<code class="descname">log_trading_account</code><span class="sig-paren">(</span><em>account</em>, <em>is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Log trading account.
:param account, the trading account object.
:param is_last: boolean, is the result the last batch.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_with_tag">
<code class="descname">log_with_tag</code><span class="sig-paren">(</span><em>tag</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.log_with_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Log data with tag.
:param tag: string, the log message tag indicating the kind of the message, for example, BAR, ORDER, ACCOUNT.
:param data: dict{string: object}, the data to be logged. Keys are data item names, values are data items.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.long_position_profit">
<code class="descname">long_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.long_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held long positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.long_positions">
<code class="descname">long_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.long_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return long positions for future_id.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: int, the long position, positive value or zero.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.lowest_position_price">
<code class="descname">lowest_position_price</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.lowest_position_price" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the price of lowest long position.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;.
:param instrument_id: string, the instrument id whose position details are to be retrieved.</p>
<blockquote>
<div>If None, use self.instrument_id().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float, position price.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.margin">
<code class="descname">margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.margin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.margin_money">
<code class="descname">margin_money</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.margin_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.margin_rate_by_money">
<code class="descname">margin_rate_by_money</code><span class="sig-paren">(</span><em>direction</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.margin_rate_by_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.market">
<code class="descname">market</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.market_periods">
<code class="descname">market_periods</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>trading_day=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.market_periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.max_positions_to_open">
<code class="descname">max_positions_to_open</code><span class="sig-paren">(</span><em>price</em>, <em>direction</em>, <em>instrument_id=None</em>, <em>available_money=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.max_positions_to_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.mission_control">
<code class="descname">mission_control</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.mission_control" title="Permalink to this definition">¶</a></dt>
<dd><p>The mission control. The mission control is set through self.ctp_factory.set_mission_control.
:return: MissionControl. If no mission control is set, return None.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.now">
<code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.now" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.ohlc">
<code class="descname">ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.ohlc_in_last_days">
<code class="descname">ohlc_in_last_days</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>start=-1</em>, <em>end=None</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.ohlc_in_last_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced ohlc, which covers all bars from start to end (in days).
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>start</strong> &#8211; int, start day index. Must be negative. Index days from backward.</li>
<li><strong>end</strong> &#8211; int, end day index. Must be negative or None. Index days from backward.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.ohlcs">
<code class="descname">ohlcs</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.ohlcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_bar_from_zmq">
<code class="descname">on_bar_from_zmq</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_bar_from_zmq" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when there is a bar arrives from zeromq bar feed.
:param data: dict{string: object}, the bar information.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_bar_method">
<code class="descname">on_bar_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_bar_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the function pointer for on_bar.
:return: function pointer.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_before_run">
<code class="descname">on_before_run</code><span class="sig-paren">(</span><em>strategy</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_before_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_err_order_insert">
<code class="descname">on_err_order_insert</code><span class="sig-paren">(</span><em>order_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_err_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoke when insert order is considered to be invalid by the exchange.
:param order_info: dict, order information.</p>
<blockquote>
<div>Keys (non-exhaustively) include:
instrument_id, order_ref, traded_volume, left_volume, status, error_id, error_message</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_error_order_action">
<code class="descname">on_error_order_action</code><span class="sig-paren">(</span><em>order_action_error</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_error_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when cancel order is considered to be invalid by the exchange.
:param order_action_error: dict{string: object}. Information about the order action error.</p>
<blockquote>
<div>Keys (non-exhausively) include: instrument_id, order_ref, error_id, error_message, status_message.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_exit">
<code class="descname">on_exit</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated. Use on_after_run_actions instead.
The action to be invoked when a new trading_day ends.
Parameters:</p>
<blockquote>
<div>context: dict, can store arbitrary data.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_idle_event">
<code class="descname">on_idle_event</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_idle_event" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_investor_position">
<code class="descname">on_investor_position</code><span class="sig-paren">(</span><em>investor_position</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when investor position for a particular future arrived,
requested by get_investor_position.
:param investor_position: dict{string: object}</p>
<blockquote>
<div><dl class="docutils">
<dt>Keys (non-exhaustively) include:</dt>
<dd>instrument_id, volume, direction.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_market_connected">
<code class="descname">on_market_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_market_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_market_disconnected">
<code class="descname">on_market_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_market_disconnected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_market_rsp_error">
<code class="descname">on_market_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_market_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_market_rtn_depth_market_data">
<code class="descname">on_market_rtn_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em>, <em>timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_market_rtn_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Note: on_* methods which inherits from CtpCallbacks cannot have their parameters renamed.
Parameters:</p>
<blockquote>
<div>p_api: a Python object wrapper for a C pointer, do not need to care.
depth_market_data: CThostFtdcDepthMarketDataField, the data received from CTP market server.
timestamp: datetime, this parameter will be set only in backtesting to avoid parsing time from string.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_mission_control">
<code class="descname">on_mission_control</code><span class="sig-paren">(</span><em>message</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_mission_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when a message from control center is arrived.
:param message: string, the message from the the control center.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_order">
<code class="descname">on_order</code><span class="sig-paren">(</span><em>order_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when order status changes.
:param order_info: dict, order information. The dict includes the following keys (non-exhaustive):</p>
<blockquote>
<div>instrument_id, order_ref, action (type OrderAction), price, volume, timestamp, transaction_id,
traded_volume, left_volume, reason, order_kind (type OrderKind), status.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_order_action">
<code class="descname">on_order_action</code><span class="sig-paren">(</span><em>order_action_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_order_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when cancel order is considered to be invalid by front.
:param order_action_info: dict{string: object}, information about the order action.</p>
<blockquote>
<div>Keys (non-exhaustively) include:
broker_id, investor_id, order_ref, action_flag, volume_change, instrument_id, error_id, error_message</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_order_insert">
<code class="descname">on_order_insert</code><span class="sig-paren">(</span><em>order_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_order_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when insert order is considered to be invalid by front.
:param order_info: dict, order information.</p>
<blockquote>
<div>Keys (non-exhaustively) include:
instrument_id, order_ref, traded_volume, left_volume, status, error_id, error_message.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_start">
<code class="descname">on_start</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated. Use on_before_run_actions instead.
The action to be invoked when a new trading_day starts.
Parameters:</p>
<blockquote>
<div>context: dict, can store arbitrary data.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_tick">
<code class="descname">on_tick</code><span class="sig-paren">(</span><em>instrument_id</em>, <em>tick</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when there is some new market data.
Note: When current new data can cause one or more
ohlc bars to be generated, those bars are first generated, meaning that the callback on_bar
will be first invoked with the generated new bars, and then this callback will be invoked.
:param instrument_id: string, instrument id.
:param tick: dict{string: object}, tick data. The object has the following keys (non-exhaustive):</p>
<blockquote>
<div>timestamp, last_price, volume, ask_price1, ask_volume1, bid_price1, bid_volume1,
pre_open_interest, open_interest.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_timer">
<code class="descname">on_timer</code><span class="sig-paren">(</span><em>trigger_time</em>, <em>supposed_trigger_time</em>, <em>timer_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be invoked when some timer is triggered.
:param trigger_time: datetime, the time when the timer is actually triggered.</p>
<blockquote>
<div>trigger_time and supposed_trigger_time may be different because the timer may be a simulated timer.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>supposed_trigger_time</strong> &#8211; datetime, the time when the timer is supposed to be triggered.</li>
<li><strong>timer_name</strong> &#8211; string, the name of the triggered timer.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trade">
<code class="descname">on_trade</code><span class="sig-paren">(</span><em>trade_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when a trade occurs in the exchange. After an order is placed ,
when (part of) the order is traded, there is a callback to this action.
An order may be executed through several trades, so there may be several invocation
of this action for a single order.
:param trade_info: dict, providing information of the trade.</p>
<blockquote>
<div>Keys (non-exhaustively) include:
instrument_id, slippage, commission, profits, transaction_id, traded_volume, left_volume,
order_ref, current_traded_volume, current_traded_price, action, reason, kind, status.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_account">
<code class="descname">on_trading_account</code><span class="sig-paren">(</span><em>trading_account</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called when trading account information arrives, requested by get_trading_account.
:param trading_account: dict{string:object}</p>
<blockquote>
<div>Keys (non-exhaustively) include: balance, available, curr_margin, commission, close_profit.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_connected">
<code class="descname">on_trading_connected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_user_login</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_disconnected">
<code class="descname">on_trading_disconnected</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>status</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_disconnected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_err_rtn_order_action">
<code class="descname">on_trading_err_rtn_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>order_action</em>, <em>res_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_err_rtn_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_err_rtn_order_insert">
<code class="descname">on_trading_err_rtn_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>res_info</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_err_rtn_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_error">
<code class="descname">on_trading_rsp_error</code><span class="sig-paren">(</span><em>p_api</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em>, <em>other_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_order_action">
<code class="descname">on_trading_rsp_order_action</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order_action</em>, <em>res_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_order_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_order_insert">
<code class="descname">on_trading_rsp_order_insert</code><span class="sig-paren">(</span><em>p_api</em>, <em>input_order</em>, <em>res_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_order_insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_depth_market_data">
<code class="descname">on_trading_rsp_qry_depth_market_data</code><span class="sig-paren">(</span><em>p_api</em>, <em>depth_market_data</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_depth_market_data" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询行情响应。当客户端发出请求查询行情指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param depth_market_data: CThostFtdcDepthMarketDataField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_instrument">
<code class="descname">on_trading_rsp_qry_instrument</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询合约响应。当客户端发出请求查询合约指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api: c_void_p
:param instrument: CThostFtdcInstrumentField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_instrument_commission_rate">
<code class="descname">on_trading_rsp_qry_instrument_commission_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_commission_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_instrument_commission_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询手续费响应。
:param p_api: c_void_p
:param instrument_commission_rate: CThostFtdcInstrumentCommissionRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_instrument_margin_rate">
<code class="descname">on_trading_rsp_qry_instrument_margin_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_margin_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_instrument_margin_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询保证金响应。
:param p_api: c_void_p
:param instrument_margin_rate: CThostFtdcInstrumentMarginRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_instrument_order_comm_rate">
<code class="descname">on_trading_rsp_qry_instrument_order_comm_rate</code><span class="sig-paren">(</span><em>p_api</em>, <em>instrument_order_comm_rate</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_instrument_order_comm_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询下单撤单手续费响应。
:param p_api: c_void_p
:param instrument_order_comm_rate: CThostFtdcInstrumentOrderCommRateField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_investor_position">
<code class="descname">on_trading_rsp_qry_investor_position</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_investor_position" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>b_is_last</strong> &#8211; boolean, True if current information is the last from a possibly list of
information about the requested investor position. One piece of information is returned
for one position direction. If there is positions for both long and short trades for the asked future,
then this callback will be invoked twice, once for each position direction.
This callback will be invoked at most twice for an investor position request.</td>
</tr>
</tbody>
</table>
<p>Note: on_* methods which inherits from CtpCallbacks cannot have their parameters renamed.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_investor_position_detail">
<code class="descname">on_trading_rsp_qry_investor_position_detail</code><span class="sig-paren">(</span><em>p_api</em>, <em>investor_position_detail</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_investor_position_detail" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询投资者持仓明细响应。当客户端发出请求请求查询投资者持仓明细指令后，交易托管系统返回响应时，该方法会被调用。
:param p_api:c_void_p
:param investor_position_detail: CThostFtdcInvestorPositionDetailField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_order">
<code class="descname">on_trading_rsp_qry_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_order" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询报单响应
:param p_api: c_void_p
:param order: CThostFtdcOrderField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_trade">
<code class="descname">on_trading_rsp_qry_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_trade" title="Permalink to this definition">¶</a></dt>
<dd><p>请求查询成交响应
:param p_api: c_void_p
:param trade: CThostFtdcTradeField
:param rsp_info: CThostFtdcRspInfoField
:param n_request_id: int
:param b_is_last: boolean, True if it is the last response for this request
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_trading_account">
<code class="descname">on_trading_rsp_qry_trading_account</code><span class="sig-paren">(</span><em>p_api</em>, <em>trading_account</em>, <em>rsp_info</em>, <em>n_request_id</em>, <em>b_is_last</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rsp_qry_trading_account" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>b_is_last</strong> &#8211; boolean, True if current information is the last from a possibly list of
information about trading account. Normally, there should be only one piece of information
about a trading account. In case the account has multiple currencies (RMB, USD, GDP), there will be
multiple pieces of information, one piece for each currency.</td>
</tr>
</tbody>
</table>
<p>Note: on_* methods which inherits from CtpCallbacks cannot have their parameters renamed.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rtn_order">
<code class="descname">on_trading_rtn_order</code><span class="sig-paren">(</span><em>p_api</em>, <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rtn_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rtn_trade">
<code class="descname">on_trading_rtn_trade</code><span class="sig-paren">(</span><em>p_api</em>, <em>trade</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.on_trading_rtn_trade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.open_limit_order">
<code class="descname">open_limit_order</code><span class="sig-paren">(</span><em>price</em>, <em>volume</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.open_limit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a limit order at price. Note that for limit orders, there is no support for enforce_one_direction,
because limit orders cannot guarantee that all positions in one direction are fully closed.
The strategy is responsible for maintaining positions in a single direction, if desirable.
:param price: float, the price.
:param volume: int, the volume to open. Positive volume means open long; Negative volume means open short.
:param kind: OrderKind. Distinguish between Normal, FAK, FOK limit orders.
:param reason: string, a reason for the open operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>enforce_one_direction</strong> &#8211; boolean. If True, close existing positions (if any) which are in the
direction opposite to the direction indicated by volume.
For example, if volume &gt; 0 (meaning to open a long position), and if currently, the account holds some
short directions, enforce_one_direction is True will force the strategy to make an order to close
all short positions as well, resulting in two orders: one to close existing short positions, and the
other to open long directions. Note that the strategy will not wait for the first order to fully execute,
it will place two orders at the same time. This is a simplification, and can be improved in the future.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.
If None, no cancellation policy is specified. The cancellation policy does not affect the
order that has to be placed when enforce_one_direction is True.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.open_market_order">
<code class="descname">open_market_order</code><span class="sig-paren">(</span><em>volume</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.open_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Open market order for future_id. If there is only one future in current strategy, you don&#8217;t need to
provide future_id, self.future_id will be used implicitly.
:param volume: int, the volume to open. Positive volume means open long; Negative volume means open short.
:param reason: string, a reason for the open operation.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.</p>
<blockquote>
<div>Note that a smaller default transaction id does not mean that the order happens earlier.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>enforce_one_direction</strong> &#8211; boolean. If True, close existing positions (if any) which are in the
direction opposite to the direction indicated by volume.
For example, if volume &gt; 0 (meaning to open a long position), and if currently, the account holds some
short directions, enforce_one_direction is True will force the strategy to make an order to close
all short positions as well, resulting in two orders: one to close existing short positions, and the
other to open long directions. Note that the strategy will not wait for the first order to fully execute,
it will place two orders at the same time. This is a simplification, and can be improved in the future.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.
If None, no cancellation policy is specified. The cancellation policy does not affect the
order that has to be placed when enforce_one_direction is True.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.open_position">
<code class="descname">open_position</code><span class="sig-paren">(</span><em>volume</em>, <em>price=None</em>, <em>kind='Normal'</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em>, <em>cancellation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.open_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a position for the instrument given by instrument_id.
:param volume: int, the position to open,</p>
<blockquote>
<div>positive number means long position, negative number means short position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>price</strong> &#8211; float, if None, send a market order. If not None, send a limit order at that price.</li>
<li><strong>kind</strong> &#8211; OrderKind, the order kind.</li>
<li><strong>reason</strong> &#8211; string, reason for this open position operation.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
<li><strong>transaction_id</strong> &#8211; string, transaction id.</li>
<li><strong>enforce_one_direction</strong> &#8211; boolean. If True, close existing positions (if any) which are in the
direction opposite to the direction indicated by volume.</li>
<li><strong>cancellation</strong> &#8211; AbstractOrderCancellation, the cancellation policy for current order.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div><p>needs to close positions in the opposite direction.</p>
</div></blockquote>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.periods">
<code class="descname">periods</code><span class="sig-paren">(</span><em>kind=None</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.periods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.place_market_order">
<code class="descname">place_market_order</code><span class="sig-paren">(</span><em>action</em>, <em>volume</em>, <em>reason=''</em>, <em>instrument_id=None</em>, <em>transaction_id=None</em>, <em>enforce_one_direction=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.place_market_order" title="Permalink to this definition">¶</a></dt>
<dd><p>make market order for instrument id.
:param instrument_id: string, instrument id. If None, use self.instrument_id.
:param action: OrderAction, the action kind of current order.
:param volume: int, the volume to close. Positive volume means open close; Negative volume means close short.
:param reason: string, a reason for the close operation.
:param transaction_id: int, the transaction id, if None, use an automatically calculated id.
:param enforce_one_direction: boolean. If True, close existing positions (if any) which are in the</p>
<blockquote>
<div>direction opposite to the direction indicated by volume.
For example, if volume &gt; 0 (meaning to open a long position), and if currently, the account holds some
short directions, enforce_one_direction is True will force the strategy to make an order to close
all short positions as well, resulting in two orders: one to close existing short positions, and the
other to open long directions. Note that the strategy will not wait for the first order to fully execute,
it will place two orders at the same time. This is a simplification, and can be improved in the future.</div></blockquote>
<dl class="docutils">
<dt>:return:f</dt>
<dd><dl class="first last docutils">
<dt>[dict{string:object}], the list of orders. It is a list because enforce_one_direction</dt>
<dd><p class="first">may cause the strategy to place two orders. Each element is a dict containing the following keys:
order_ref: string, the value is string, the order reference.
transaction_id: string, the value is string, the transaction id.
enforce_one_direction: string, the value is bool, True if the order is placed because the strategy</p>
<blockquote class="last">
<div>needs to close positions in the opposite direction.</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.position_details">
<code class="descname">position_details</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.position_details" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.position_profit">
<code class="descname">position_profit</code><span class="sig-paren">(</span><em>direction=None</em>, <em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held positions.
:param direction: string, can be &#8216;long&#8217; or &#8216;short&#8217;, specifies the direction of the position whose</p>
<blockquote>
<div>profit is to be calculated.
If None, assume that there is only one direction position, and use self.single_sided_position.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; string, the condition to select positions. Values can be the following:
highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</li>
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.positions">
<code class="descname">positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.positions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.price">
<code class="descname">price</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.last_known_price().
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:return float, the last known price, None if no price is known for the given instrument.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.product">
<code class="descname">product</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return name of the product to which this strategy belongs.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.profit">
<code class="descname">profit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.profit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.remove_bar_arrival_action">
<code class="descname">remove_bar_arrival_action</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.remove_bar_arrival_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the specified bar arrival action.
:param name: string, the bar arrival action name.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.remove_order_cancellations">
<code class="descname">remove_order_cancellations</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.remove_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove order cancellations.
:param order_ref: string, full order reference.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.remove_timer">
<code class="descname">remove_timer</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.remove_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the timer with name.
:param name: string, the timer name.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.safe_instrument_id">
<code class="descname">safe_instrument_id</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.safe_instrument_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the final instrument id.
:param instrument_id: string.
:return: string, the final instrument id.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.send_message">
<code class="descname">send_message</code><span class="sig-paren">(</span><em>message</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.send_message" title="Permalink to this definition">¶</a></dt>
<dd><p>Send message using self.message_sender.
:param message: string, the message to send.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_all_callbacks">
<code class="descname">set_all_callbacks</code><span class="sig-paren">(</span><em>all_callbacks</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_all_callbacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.all_callbacks to all_callbacks.
:param all_callbacks: OrderedDict{string: AbstractStrategyCallbacks},</p>
<blockquote>
<div>The set of individual strategy callbacks. Keys are strategy callback names,
values are callbacks. Note that it is an ordered dict. So when callbacks are invoked,
they follow the order that is given here. The callback names are useful to find
corresponding strategy callbacks from outside.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_ctp_factory">
<code class="descname">set_ctp_factory</code><span class="sig-paren">(</span><em>ctp_factory</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_ctp_factory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_market">
<code class="descname">set_market</code><span class="sig-paren">(</span><em>market</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_market" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_market_and_trading">
<code class="descname">set_market_and_trading</code><span class="sig-paren">(</span><em>market</em>, <em>trading</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_market_and_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_should_exit">
<code class="descname">set_should_exit</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_should_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self._should_exit to the given boolean.
:param b: boolean, the value to set self._should_exit.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_should_use_remote_account_and_position">
<code class="descname">set_should_use_remote_account_and_position</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_should_use_remote_account_and_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_step_action">
<code class="descname">set_step_action</code><span class="sig-paren">(</span><em>action</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_step_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_strategy_callbacks">
<code class="descname">set_strategy_callbacks</code><span class="sig-paren">(</span><em>callbacks</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_strategy_callbacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.strategy_callbacks according to callbacks.
:param callbacks: AbstractStrategyCallbacks, the external strategy callbacks.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_trading">
<code class="descname">set_trading</code><span class="sig-paren">(</span><em>trading</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_use_mid_ask_bid">
<code class="descname">set_use_mid_ask_bid</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.set_use_mid_ask_bid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.setup_order_cancellations">
<code class="descname">setup_order_cancellations</code><span class="sig-paren">(</span><em>order_ref</em>, <em>order_place_time</em>, <em>instrument_id</em>, <em>cancellation</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.setup_order_cancellations" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup order cancellation.
:param order_ref: string, full order reference.
:param order_place_time: datetime, the time when the order is placed.
:param instrument_id: string, the instrument to trade.
:param cancellation: AbstractOrderCancellation, order cancellation policy.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.short_position_profit">
<code class="descname">short_position_profit</code><span class="sig-paren">(</span><em>condition='average_price'</em>, <em>price=None</em>, <em>instrument_id=None</em>, <em>percent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.short_position_profit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the profit of held short positions.
:param condition: string, the condition to select positions. Values can be the following:</p>
<blockquote>
<div>highest_price: use the highest price of the held position to calculate profit.
lowest_price: use the lowest price of the held position.
average_price: use the average price of the held position.
This condition is needed because the positions of the given direction for the given instrument
may have different entry prices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>price</strong> &#8211; float, the current price of the instrument. If None, use the last known price for that instrument.</li>
<li><strong>instrument_id</strong> &#8211; string, the instrument id whose position details are to be retrieved.
If None, use self.instrument_id().</li>
<li><strong>percent</strong> &#8211; boolean, if True, the profit is returned as a percentage, otherwise, as difference
between the current price and the position price.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return float, the position profit. Positive number means profit, negative number means loss.</dt>
<dd>The percent parameter decides if the returned number is a percentage or actual price delta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.short_positions">
<code class="descname">short_positions</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.short_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return long positions for future_id.
:param instrument_id: string, instrument id. If None, use self.instrument_id().
:return: int, the short position, negative value or zero.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.should_exit">
<code class="descname">should_exit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.should_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Should current strategy exit?
:return: boolean, True if current strategy should exit.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.should_use_remote_account_and_position">
<code class="descname">should_use_remote_account_and_position</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.should_use_remote_account_and_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sign 1 or -1 for the position direction. This is useful
when calculating volumes from directions.
:param direction: string or int, can be &#8216;long&#8217; or &#8216;short&#8217;.</p>
<blockquote>
<div>Or an integer, positive number means long, negative number mean short.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int, return 1 if direction is &#8216;long&#8217;, otherwise -1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.single_sided_position">
<code class="descname">single_sided_position</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.single_sided_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for given instrument.
Single sided means: assuming that there is no both long and short positions for the instrument, then</p>
<blockquote>
<div><ol class="arabic simple">
<li>If long position is positive, return the long position number (positive).</li>
<li>If short position is negative, return the short position number (negative).</li>
<li>Otherwise return 0.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:return int, single-sided position. If the instrument have both long and short side positions,</dt>
<dd>return None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.single_sided_positions">
<code class="descname">single_sided_positions</code><span class="sig-paren">(</span><em>instrument_ids=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.single_sided_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single sided position for the given instrument ids.
:param instrument_ids: [string], the required instrument ids.</p>
<blockquote>
<div>If None, use self.instrument_ids().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict{string: int}, meaning dict{instrument_id: position}.
Keys are the same as instrument_ids. Values are the single sided positions for those instruments.
If an instrument has no position, its corresponding value is 0.
If an instrument has both long and short sided positions, its corresponding value is None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.state">
<code class="descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the current state in stat machine.
Note: the current state may not be the same as current object.
:return: string, tne name of the current state in self.state_machine.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.store_ohlcs">
<code class="descname">store_ohlcs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.store_ohlcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Store OHLCS for all instruments, all registered periods into files.
Only needed in real-trading mode.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.strategy_last_bar_so_far">
<code class="descname">strategy_last_bar_so_far</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.strategy_last_bar_so_far" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.strategy_name">
<code class="descname">strategy_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.strategy_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of current strategy.
:return: string, name of the current strategy.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.strategy_ohlc">
<code class="descname">strategy_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.strategy_ohlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.strategy_period">
<code class="descname">strategy_period</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.strategy_period" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.strategy_period_kind">
<code class="descname">strategy_period_kind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.strategy_period_kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.tick_size">
<code class="descname">tick_size</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.tick_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.today_bars">
<code class="descname">today_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.today_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from today.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.today_ohlc">
<code class="descname">today_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.today_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return today&#8217;s ohlc, the sliced part only contain bars from today.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.trading">
<code class="descname">trading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.trading" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.trading_account_id">
<code class="descname">trading_account_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.trading_account_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Current trading account id.
:return: string, the trading account id.</p>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.trading_day">
<code class="descname">trading_day</code><span class="sig-paren">(</span><em>now=None</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.trading_day" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.transaction_id_from_order_ref">
<code class="descname">transaction_id_from_order_ref</code><span class="sig-paren">(</span><em>order_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.transaction_id_from_order_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.volume_multiple">
<code class="descname">volume_multiple</code><span class="sig-paren">(</span><em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.volume_multiple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.yesterday_bars">
<code class="descname">yesterday_bars</code><span class="sig-paren">(</span><em>ohlc</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>instrument_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.yesterday_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bar slice in ohlc, which covers all bars from yesterday.
:param ohlc: OHLC, the ohlc object.
:param now: datetime, an optional timestamp indicating current time, if None,</p>
<blockquote>
<div>use the last timestamp in ohlc as current time.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>instrument_id</strong> &#8211; string, instrument id. If None, use self.instrument_id().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">slice, the slice used to index into ohlc. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.yesterday_ohlc">
<code class="descname">yesterday_ohlc</code><span class="sig-paren">(</span><em>instrument_id=None</em>, <em>kind=None</em>, <em>period=None</em>, <em>now=None</em>, <em>is_trading_day=True</em>, <em>ohlc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.MeanReversionRSI2575Strategy.yesterday_ohlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sliced part from the given ohlc, the sliced part only contain bars from yesterday.
:param instrument_id: string, the instrument id. If None, use self.instrument_id().
:param kind: string, ohlc kind such as &#8216;time-based&#8217; or &#8216;volatility-based&#8217;.</p>
<blockquote>
<div>If None, defaults to &#8216;time-based&#8217;.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>period</strong> &#8211; Periodicity, the periodicity of the ohlc to return.
If None, use self.strategy_period().</li>
<li><strong>now</strong> &#8211; datetime, an optional timestamp indicating current time, if None,
use the last timestamp in ohlc as current time.</li>
<li><strong>is_trading_day</strong> &#8211; boolean, if True, count days by trading days, otherwise, by calendar days.</li>
<li><strong>ohlc</strong> &#8211; OHLC, the ohlc object. If not None, use this ohlc, instead of using
instrument_id, kind and period to find the ohlc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">OHLC, the sliced OHLC. If no such bars from ohlc, return None.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.main">
<code class="descclassname">ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctxalgoctp.ctp.strategies.mean_reversion_RSI25_75.main" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, .
      Last updated on Jun 21, 2016.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="static/jquery.js"></script>
      <script type="text/javascript" src="static/underscore.js"></script>
      <script type="text/javascript" src="static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>